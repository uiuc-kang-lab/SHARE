{"idx": 0, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\n\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [Business_Hours].business_id, filter = 12)\ndf2 = df1.where(element = [Days].day_of_week, filter = 'Monday')\nres = df2.select([Business_Hours].opening_time)\n```"}
{"idx": 1, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = orders.order_date, filter = '>= 2022-01-01')\ndf2 = df1.where(element = orders.order_date, filter = '< 2022-06-01')\nres = df2.select(orders.order_id, customers.customer_name)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = '>= 2022-01-01')\ndf2 = df1.where(element = [MASK], filter = '< 2022-06-01')\nres = df2.select([MASK], [MASK])\n```"}
{"idx": 2, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(olist_orders.order_id).agg(sum(olist_order_payments.payment_value) as order_payment)\ndf2 = df.select(olist_customers.customer_unique_id, olist_orders.order_id, date(olist_orders.order_purchase_timestamp) as purchase_date, df1.order_payment)\ndf3 = df2.groupby(olist_customers.customer_unique_id).agg(count(distinct(olist_orders.order_id)) as num_orders, avg(df1.order_payment) as avg_payment_per_order, min(purchase_date) as first_purchase_date, max(purchase_date) as last_purchase_date)\ndf4 = df3.select(customer_unique_id, num_orders, avg_payment_per_order, case when (julianday(last_purchase_date) - julianday(first_purchase_date)) < 7 then 1.0 else (julianday(last_purchase_date) - julianday(first_purchase_date)) / 7.0 as lifespan_weeks)\nres = df4.orderby(by = avg_payment_per_order, desc).limit(3)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.groupby([MASK]).agg(sum([MASK]) as [MASK])\ndf2 = df.select([MASK], [MASK], date([MASK]) as [MASK], df1.[MASK])\ndf3 = df2.groupby([MASK]).agg(count(distinct([MASK])) as [MASK], avg(df1.[MASK]) as [MASK], min([MASK]) as [MASK], max([MASK]) as [MASK])\ndf4 = df3.select([MASK], [MASK], [MASK], case when (julianday([MASK]) - julianday([MASK])) < 7 then 1.0 else (julianday([MASK]) - julianday([MASK])) / 7.0 as [MASK])\nres = df4.orderby(by = [MASK], desc).limit(3)\n```"}
{"idx": 3, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = player.debut, filter = 'is not null').where(element = player.final_game, filter = 'is not null')\ndf2 = df1.select(player.player_id, player.debut, player.final_game, abs(year(player.final_game) - year(player.debut)) as dy, abs(month(player.final_game) - month(player.debut)) as dm, abs(day(player.final_game) - day(player.debut)) as dd)\ndf3 = df2.select(player.player_id, round((dy * 1.0) + (dm * 1.0 / 12.0) + (dd * 1.0 / 365.0), 2) as span_years)\nres = df3.select(round(avg(span_years * 1.0), 2))\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = 'is not null').where(element = [MASK], filter = 'is not null')\ndf2 = df1.select([MASK], [MASK], [MASK], abs(year([MASK]) - year([MASK])) as dy, abs(month([MASK]) - month([MASK])) as dm, abs(day([MASK]) - day([MASK])) as dd)\ndf3 = df2.select([MASK], round((dy * 1.0) + (dm * 1.0 / 12.0) + (dd * 1.0 / 365.0), 2) as span_years)\nres = df3.select(round(avg(span_years * 1.0), 2))\n```"}
{"idx": 4, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(batting.player_id).select(batting.player_id, sum(batting.g) as games_played, sum(batting.r) as runs, sum(batting.h) as hits, sum(batting.hr) as home_runs)\nmax_vals = df1.max(batting.g, batting.r, batting.h, batting.hr)\nres1 = df1.where(element = batting.g, filter = max_vals.max_games_played).select(player.name_given, 'games_played' as category, batting.g as value)\nres2 = df1.where(element = batting.r, filter = max_vals.max_runs).select(player.name_given, 'runs' as category, batting.r as value)\nres3 = df1.where(element = batting.h, filter = max_vals.max_hits).select(player.name_given, 'hits' as category, batting.h as value)\nres4 = df1.where(element = batting.hr, filter = max_vals.max_home_runs).select(player.name_given, 'home_runs' as category, batting.hr as value)\nres = res1.union(res2).union(res3).union(res4).orderby(by = ['category', 'name_given'])\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.groupby([MASK]).select([MASK], sum([MASK].g) as games_played, sum([MASK].r) as runs, sum([MASK].h) as hits, sum([MASK].hr) as home_runs)\nmax_vals = df1.max(sum([MASK].g), sum([MASK].r), sum([MASK].h), sum([MASK].hr))\nres1 = df1.where(element = sum([MASK].g), filter = max_vals.max_games_played).select(player.name_given, 'games_played' as category, sum([MASK].g) as value)\nres2 = df1.where(element = sum([MASK].r), filter = max_vals.max_runs).select(player.name_given, 'runs' as category, sum([MASK].r) as value)\nres3 = df1.where(element = sum([MASK].h), filter = max_vals.max_hits).select(player.name_given, 'hits' as category, sum([MASK].h) as value)\nres4 = df1.where(element = sum([MASK].hr), filter = max_vals.max_home_runs).select(player.name_given, 'home_runs' as category, sum([MASK].hr) as value)\nres = res1.union(res2).union(res3).union(res4).orderby(by = ['category', 'player.name_given'])\n```"}
{"idx": 5, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = airports_data.city, filter = 'Abakan')\ntmp_res1 = df1.select(airports_data.coordinates).with_columns(\n    dep_coord = cast(trim(replace(replace(airports_data.coordinates, '(', ''), ')', ''), ' '), real),\n    arr_coord = cast(trim(replace(replace(airports_data.coordinates, '(', ''), ')', ''), ' '), real)\n)\n\ndf2 = df.select(flights.departure_airport, flights.arrival_airport)\ntmp_res2 = df2.join(tmp_res1, on = flights.departure_airport, airports_data.airport_code).join(tmp_res1, on = flights.arrival_airport, airports_data.airport_code)\n\ntmp_res3 = tmp_res2.select(\n    case(when(airports_data.city < tmp_res1.city, airports_data.city, tmp_res1.city) as city1,\n    case(when(airports_data.city < tmp_res1.city, tmp_res1.city, airports_data.city) as city2,\n    2.0 * 6371.0 * asin(sqrt(pow(sin(((tmp_res1.lat - tmp_res3.lat) * 3.14159265359 / 180.0) / 2.0), 2) + cos(tmp_res3.lat * 3.14159265359 / 180.0) * cos(tmp_res1.lat * 3.14159265359 / 180.0) * pow(sin(((tmp_res3.lon - tmp_res1.lon) * 3.14159265359 / 180.0) / 2.0), 2)))\n).groupby(city1, city2).agg(avg(distance_km))\nres = tmp_res3.select(max(avg_distance_km))\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [MASK], filter = 'Abakan')\ntmp_res1 = df1.select([MASK]).with_columns(\n    dep_coord = cast(trim(replace(replace([MASK], '(', ''), ')', ''), ' '), real),\n    arr_coord = cast(trim(replace(replace([MASK], '(', ''), ')', ''), ' '), real)\n)\n\ndf2 = df.select([MASK], [MASK]).join(tmp_res1, on = [MASK], [MASK]).join(tmp_res1, on = [MASK], [MASK])\n\ntmp_res3 = tmp_res2.select(\n    case(when([MASK] < tmp_res1.[MASK], [MASK], tmp_res1.[MASK]) as [MASK],\n    case(when([MASK] < tmp_res1.[MASK], tmp_res1.[MASK], [MASK]) as [MASK],\n    2.0 * 6371.0 * asin(sqrt(pow(sin(((tmp_res1.[MASK] - [MASK]) * 3.14159265359 / 180.0) / 2.0), 2) + cos([MASK] * 3.14159265359 / 180.0) * cos(tmp_res1.[MASK] * 3.14159265359 / 180.0) * pow(sin(((tmp_res3.[MASK] - tmp_res1.[MASK]) * 3.14159265359 / 180.0) / 2.0), 2)))\n).groupby([MASK], [MASK]).agg(avg([MASK])\nres = tmp_res3.select(max([MASK])\n```"}
{"idx": 6, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = airports_data.city, filter = 'is not null').where(element = airports_data.city, filter = '<> airports_data.city')\ntmp_res1 = df1.select(airports_data.city as city1, airports_data.city as city2, 2 * 6371 * asin(sqrt(pow(sin((airports_data.coordinates[1] - airports_data.coordinates[1]) * pi() / 180) / 2) + cos(airports_data.coordinates[1] * pi() / 180) * cos(airports_data.coordinates[1] * pi() / 180) * pow(sin((airports_data.coordinates[0] - airports_data.coordinates[0]) * pi() / 180) / 2))) as dist_km)\ndf2 = tmp_res1.groupby(by = [min(airports_data.city, airports_data.city), max(airports_data.city, airports_data.city)]).agg(avg(dist_km))\ndf3 = df2.select(case(element = avg(dist_km), when = '< 1000', then = '0-999', when = '< 2000', then = '1000-1999', when = '< 3000', then = '2000-2999', when = '< 4000', then = '3000-3999', when = '< 5000', then = '4000-4999', when = '< 6000', then = '5000-5999', else = '6000+'), count() as pair_cnt)\nres = df3.orderby(by = pair_cnt, asc).limit(1).select(pair_cnt)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [MASK], filter = 'is not null').where(element = [MASK], filter = '<> [MASK]')\ntmp_res1 = df1.select([MASK] as [MASK], [MASK] as [MASK], 2 * 6371 * asin(sqrt(pow(sin((([MASK] - [MASK]) * pi() / 180) / 2) + cos([MASK] * pi() / 180) * cos([MASK] * pi() / 180) * pow(sin((([MASK] - [MASK]) * pi() / 180) / 2))) as dist_km)\ndf2 = tmp_res1.groupby(by = [min([MASK], [MASK]), max([MASK], [MASK])]).agg(avg(dist_km))\ndf3 = df2.select(case(element = avg(dist_km), when = '< 1000', then = '0-999', when = '< 2000', then = '1000-1999', when = '< 3000', then = '2000-2999', when = '< 4000', then = '3000-3999', when = '< 5000', then = '4000-4999', when = '< 6000', then = '5000-5999', else = '6000+'), count() as pair_cnt)\nres = df3.orderby(by = pair_cnt, asc).limit(1).select(pair_cnt)\n```"}
{"idx": 7, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = parties.party_type, filter = 'LIKE %MOTORCYCLE%')\ndf2 = df1.where(element = parties.party_safety_equipment_1, filter = 'LIKE %HELMET%').or(element = parties.party_safety_equipment_2, filter = 'LIKE %HELMET%')\ndf3 = df2.groupby(parties.case_id).select(parties.case_id, parties.party_safety_equipment_1, parties.party_safety_equipment_2)\ndf4 = df.where(element = parties.party_type, filter = 'LIKE %MOTORCYCLE%').select(parties.case_id, parties.party_safety_equipment_1, parties.party_safety_equipment_2).except(df3)\ndf5 = df4.groupby(by = 'party_safety_equipment_1, party_safety_equipment_2').select(case_id).count(distinct = True)\ndf6 = df3.groupby(by = 'party_safety_equipment_1, party_safety_equipment_2').select(case_id).count(distinct = True)\nres = df.select(df5.helmet, df6.helmet, df5.no_helmet, round((df5.helmet * 100.0 / df5.total_collisions), 2))\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [parties.party_type], filter = 'LIKE %MOTORCYCLE%')\ndf2 = df1.where(element = [parties.party_safety_equipment_1], filter = 'LIKE %HELMET%').or(element = [parties.party_safety_equipment_2], filter = 'LIKE %HELMET%')\ndf3 = df2.groupby([parties.case_id]).select([parties.case_id, parties.party_safety_equipment_1, parties.party_safety_equipment_2])\ndf4 = df.where(element = [parties.party_type], filter = 'LIKE %MOTORCYCLE%').select([parties.case_id, parties.party_safety_equipment_1, parties.party_safety_equipment_2]).except(df3)\ndf5 = df4.groupby(by = '[parties.party_safety_equipment_1, parties.party_safety_equipment_2]').select([parties.case_id]).count(distinct = True)\ndf6 = df3.groupby(by = '[parties.party_safety_equipment_1, parties.party_safety_equipment_2]').select([parties.case_id]).count(distinct = True)\nres = df.select(df5.[parties.party_safety_equipment_1], df6.[parties.party_safety_equipment_1], df5.[parties.party_safety_equipment_2], round((df5.[parties.party_safety_equipment_1] * 100.0 / df4.[parties.case_id]), 2)\n```"}
{"idx": 8, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = collisions.primary_collision_factor, filter = 'is not null').where(element = collisions.primary_collision_factor, filter = \"is not ''\")\ndf2 = df1.groupby(by = [collisions.db_year, collisions.primary_collision_factor]).count()\ndf3 = df2.orderby(by = [collisions.db_year, collisions.primary_collision_factor], desc = 'count').select(collisions.db_year, collisions.primary_collision_factor, count).limit(2)\ndf4 = df3.groupby(by = collisions.db_year).agg({'primary_collision_factor': 'group_concat'})\ndf5 = df4.groupby(by = 'primary_collision_factor').count()\nres = df5.where(element = 'count', filter = 1).select(collisions.db_year, 'primary_collision_factor')\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [MASK], filter = 'is not null').where(element = [MASK], filter = \"is not ''\")\ndf2 = df1.groupby(by = [MASK, [MASK]]).count()\ndf3 = df2.orderby(by = [MASK, [MASK]], desc = 'count').select([MASK], [MASK], count).limit(2)\ndf4 = df3.groupby(by = [MASK]).agg({'[MASK]': 'group_concat'})\ndf5 = df4.groupby(by = '[MASK]').count()\nres = df5.where(element = 'count', filter = 1).select([MASK], '[MASK]')\n```"}
{"idx": 9, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = case_ids.db_year, filter = 'IN', values = [2011, 2021]).where(element = collisions.pcf_violation_category, filter = 'IS NOT NULL').where(element = collisions.pcf_violation_category, filter = \"!=''\")\ndf2 = df1.where(element = collisions_with_year.db_year, filter = 2021).groupby(collisions_with_year.pcf_violation_category).orderby(by = count(*), desc).limit(1)\ndf3 = df1.groupby(collisions_with_year.db_year).select(100.0 * sum(case when collisions_with_year.pcf_violation_category = df2.pcf_violation_category then 1 else 0) / count(*))\nres = df3.where(element = collisions_with_year.db_year, filter = 2011).select(subtract(df3.where(element = collisions_with_year.db_year, filter = 2021).select(share_pct)))\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [MASK], filter = 'IN', values = [2011, 2021]).where(element = [MASK], filter = 'IS NOT NULL').where(element = [MASK], filter = \"!=''\")\ndf2 = df1.where(element = [MASK], filter = 2021).groupby([MASK]).orderby(by = count(*), desc).limit(1)\ndf3 = df1.groupby([MASK]).select(100.0 * sum(case when [MASK] = df2.[MASK] then 1 else 0) / count(*))\nres = df3.where(element = [MASK], filter = 2011).select(subtract(df3.where(element = [MASK], filter = 2021).select([MASK])))\n```"}
{"idx": 10, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = Belts.name, filter = 'NXT Championship').where(element = Matches.title_change, filter = 0).where(element = Matches.duration, filter = 'is not null').where(element = Matches.duration, filter = 'contains :')\ndf2 = df1.select(Matches.id, Matches.winner_id, Matches.loser_id, cast(substr(Matches.duration, 1, instr(Matches.duration, ':') - 1) as integer) * 60 + cast(substr(Matches.duration, instr(Matches.duration, ':') + 1) as integer) as duration_seconds)\ndf3 = df2.orderby(by = duration_seconds, asc).limit(1)\nres = df3.select(Wrestlers.name as winner_name, Wrestlers.name as loser_name)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = 'NXT Championship').where(element = [MASK], filter = 0).where(element = [MASK], filter = 'is not null').where(element = [MASK], filter = 'contains :')\ndf2 = df1.select([MASK], [MASK], [MASK], cast(substr([MASK], 1, instr([MASK], ':') - 1) as integer) * 60 + cast(substr([MASK], instr([MASK], ':') + 1) as integer) as [MASK])\ndf3 = df2.orderby(by = [MASK], asc).limit(1)\nres = df3.select([MASK] as winner_name, [MASK] as loser_name)\n```"}
{"idx": 11, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\n\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [Business_Hours].business_id, filter = 12)\ndf2 = df1.where(element = [Days].day_of_week, filter = 'Monday')\nres = df2.select([Business_Hours].opening_time)\n```"}
{"idx": 12, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(ball_by_ball.bowler).select(ball_by_ball.bowler, sum(coalesce(batsman_scored.runs_scored, 0) + coalesce(extra_runs.extra_runs, 0)) as runs_conceded)\ndf2 = df.where(wicket_taken.kind_out, filter = 'not in', values = ['run out', 'retired hurt', 'obstructing the field']).groupby(ball_by_ball.bowler).count() as wickets\nres = df.select(player.player_id as bowler_id, player.player_name as bowler_name, round(1.0 * df1.runs_conceded, 2) as bowling_average, df1.runs_conceded, df2.wickets).orderby(by = [bowling_average, wickets, runs_conceded], asc, desc, asc).limit(1)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.groupby([MASK]).select([MASK], sum(coalesce([MASK1].runs_scored, 0) + coalesce([MASK2].extra_runs, 0)) as runs_conceded)\ndf2 = df.where([MASK3].kind_out, filter = 'not in', values = ['run out', 'retired hurt', 'obstructing the field']).groupby([MASK]).count() as wickets\nres = df.select([MASK4].player_id as bowler_id, [MASK4].player_name as bowler_name, round(1.0 * df1.runs_conceded, 2) as bowling_average, df1.runs_conceded, df2.wickets).orderby(by = [bowling_average, wickets, runs_conceded], asc, desc, asc).limit(1)\n```"}
{"idx": 13, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(ball_by_ball.striker, ball_by_ball.match_id).agg(sum(batsman_scored.runs_scored))\ndf2 = df1.where(element = sum(batsman_scored.runs_scored), filter = '> 50')\nres = df2.avg(sum(batsman_scored.runs_scored))\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.groupby([MASK], [MASK]).agg(sum([MASK]))\ndf2 = df1.where(element = sum([MASK]), filter = '> 50')\nres = df2.avg(sum([MASK]))\n```"}
{"idx": 14, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(player_match.player_id, match_id, team_id).agg(sum(batsman_scored.runs_scored) as runs)\ndf2 = df.where(element = match.match_winner, filter = 'is not null')\ndf3 = df2.where(element = df1.runs, filter = '>= 100')\ndf4 = df3.where(element = df1.team_id, filter = '<>', match.match_winner)\nres = df4.select(player.player_name).distinct().orderby(by = player.player_name)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.groupby([MASK], [MASK], [MASK]).agg(sum([MASK]) as [MASK])\ndf2 = df.where(element = [MASK], filter = 'is not null')\ndf3 = df2.where(element = [MASK], filter = '>= 100')\ndf4 = df3.where(element = [MASK], filter = '<>')\nres = df4.select([MASK]).distinct().orderby(by = [MASK])\n```"}
{"idx": 15, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = match.season_id, filter = 5)\ndf2 = df.groupby(ball_by_ball.striker).agg(sum(batsman_scored.runs_scored))\ndf3 = df.groupby(player_match.player_id).agg(count(distinct(match.match_id)) as matches_played)\ndf4 = df.groupby(wicket_taken.player_out).agg(count() as dismissals)\ndf5 = df.select(player.player_name, round(df2.sum(batsman_scored.runs_scored) / df3.count(distinct(match.match_id)), 2) as avg_runs_per_match, round(df2.sum(batsman_scored.runs_scored) / df4.count(), 2) as batting_average).where(element = df3.count(distinct(match.match_id)), filter = '> 0').orderby(by = [avg_runs_per_match, desc, batsman_scored.runs_scored], limit = 5)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = 5)\ndf2 = df.groupby([MASK]).agg(sum([MASK]))\ndf3 = df.groupby([MASK]).agg(count(distinct([MASK])) as [MASK])\ndf4 = df.groupby([MASK]).agg(count() as [MASK])\ndf5 = df.select([MASK], round(df2.sum([MASK]) / df3.count(distinct([MASK])), 2) as [MASK], round(df2.sum([MASK]) / df4.count(), 2) as [MASK]).where(element = df3.count(distinct([MASK])), filter = '> 0').orderby(by = [MASK, desc, [MASK]], limit = 5)\n```"}
{"idx": 16, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(ball_by_ball.match_id, ball_by_ball.striker).agg(sum(batsman_scored.runs_scored))\ndf2 = df.groupby(player_match_runs.player_id).agg(avg(player_match_runs.runs_in_match * 1.0))\ndf3 = df2.groupby(player.country_name).agg(avg(player_avg.avg_runs_per_match))\nres = df3.orderby(by = avg(player_avg.avg_runs_per_match), desc).limit(5).select(player.country_name, avg(player_avg.avg_runs_per_match))\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.groupby([MASK], [MASK]).agg(sum([MASK]))\ndf2 = df.groupby([MASK]).agg(avg([MASK] * 1.0))\ndf3 = df2.groupby([MASK]).agg(avg([MASK]))\nres = df3.orderby(by = [MASK], desc).limit(5).select([MASK], [MASK])\n```"}
{"idx": 17, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.select(ball_by_ball.match_id, ball_by_ball.innings_no, ball_by_ball.over_id, ball_by_ball.ball_id, ball_by_ball.bowler, \n               coalesce(batsman_scored.runs_scored, 0) as bat_runs, coalesce(extra_runs.extra_runs, 0) as ex_runs)\ndf2 = df1.groupby(ball_by_ball.match_id, ball_by_ball.innings_no, ball_by_ball.over_id, ball_by_ball.bowler).agg(sum(bat_runs + ex_runs) as over_total_runs)\ndf3 = df2.orderby(by = over_total_runs, desc).orderby(by = innings_no, asc).orderby(by = over_id, asc).select(over_total_runs, row_number() as rn)\ndf4 = df3.where(element = rn, filter = 1)\ndf5 = df4.select(match_best_over.match_id, match_best_over.innings_no, match_best_over.over_id, match_best_over.bowler, player.player_name, match_best_over.over_total_runs, avg(match_best_over.over_total_runs))\nres = df5.orderby(by = match_best_over.match_id)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.select([MASK], [MASK], [MASK], [MASK], [MASK], coalesce([MASK], 0) as [MASK], coalesce([MASK], 0) as [MASK])\ndf2 = df1.groupby([MASK], [MASK], [MASK], [MASK]).agg(sum([MASK] + [MASK]) as [MASK])\ndf3 = df2.orderby(by = [MASK], desc).orderby(by = [MASK], asc).orderby(by = [MASK], asc).select([MASK], row_number() as [MASK])\ndf4 = df3.where(element = [MASK], filter = 1)\ndf5 = df4.select([MASK], [MASK], [MASK], [MASK], [MASK], [MASK], [MASK])\nres = df5.orderby(by = [MASK])\n```"}
{"idx": 18, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = olist_orders.order_status, filter = 'delivered')\ndf2 = df1.where(element = olist_orders.order_purchase_timestamp, filter = \"like '2016%'\")\ndf3 = df1.where(element = olist_orders.order_purchase_timestamp, filter = \"like '2017%'\")\ndf4 = df1.where(element = olist_orders.order_purchase_timestamp, filter = \"like '2018%'\")\n\nres = df.select(\n    month = df.orderby(by = months.mon).select(months.mon),\n    orders_2016 = df2.count(),\n    orders_2017 = df3.count(),\n    orders_2018 = df4.count()\n)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [olist_orders.order_status], filter = 'delivered')\ndf2 = df1.where(element = [olist_orders.order_purchase_timestamp], filter = \"like '2016%'\")\ndf3 = df1.where(element = [olist_orders.order_purchase_timestamp], filter = \"like '2017%'\")\ndf4 = df1.where(element = [olist_orders.order_purchase_timestamp], filter = \"like '2018%'\")\n\nres = df.select(\n    month = df.orderby(by = [months.mon]).select([months.mon]),\n    orders_2016 = [df2.count()],\n    orders_2017 = [df3.count()],\n    orders_2018 = [df4.count()]\n)\n```"}
{"idx": 19, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = olist_orders.order_status, filter = 'delivered').where(element = olist_orders.order_delivered_customer_date, filter = 'is not null')\ndf2 = df1.where(element = cast(olist_orders.order_delivered_customer_date, function = 'year'), filter = 'in (2016, 2017, 2018)')\ndf3 = df2.groupby(by = cast(olist_orders.order_delivered_customer_date, function = 'year'), by = cast(olist_orders.order_delivered_customer_date, function = 'month')).count()\ndf4 = df3.groupby(by = cast(olist_orders.order_delivered_customer_date, function = 'year')).sum()\ndf5 = df4.orderby(by = annual_delivered_orders, asc).limit(1)\nres = df.select(max(df3.delivered_orders))\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [olist_orders.order_status], filter = 'delivered').where(element = [olist_orders.order_delivered_customer_date], filter = 'is not null')\ndf2 = df1.where(element = cast([olist_orders.order_delivered_customer_date], function = 'year'), filter = 'in (2016, 2017, 2018)')\ndf3 = df2.groupby(by = cast([olist_orders.order_delivered_customer_date], function = 'year'), by = cast([olist_orders.order_delivered_customer_date], function = 'month')).count()\ndf4 = df3.groupby(by = cast([olist_orders.order_delivered_customer_date], function = 'year')).sum()\ndf5 = df4.orderby(by = [annual_delivered_orders], asc).limit(1)\nres = df.select(max([df3.delivered_orders]))\n```"}
{"idx": 20, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = olist_orders.order_status, filter = 'delivered')\ndf2 = df1.groupby(olist_customers.customer_unique_id, olist_customers.customer_city, olist_customers.customer_state).agg(count_distinct(olist_orders.order_id), avg(olist_order_payments.payment_value))\nres = df2.orderby(by = [count_distinct(olist_orders.order_id), avg(olist_order_payments.payment_value)], desc).limit(3)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [olist_orders.order_status], filter = 'delivered')\ndf2 = df1.groupby([olist_customers.customer_unique_id, olist_customers.customer_city, olist_customers.customer_state]).agg([count_distinct(olist_orders.order_id), avg(olist_order_payments.payment_value)])\nres = df2.orderby(by = [count_distinct(olist_orders.order_id), avg(olist_order_payments.payment_value)], desc).limit(3)\n```"}
{"idx": 21, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = olist_orders.order_status, filter = 'delivered')\ndf2 = df1.groupby(olist_customers.customer_city).agg(total_payments = sum(olist_order_payments.payment_value), delivered_order_count = count(distinct(olist_orders.order_id)))\ndf3 = df2.orderby(by = total_payments, asc).limit(5)\nres = df3.select(avg(total_payments), avg(delivered_order_count))\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = 'delivered')\ndf2 = df1.groupby([MASK]).agg(total_payments = sum([MASK]), delivered_order_count = count(distinct([MASK])))\ndf3 = df2.orderby(by = total_payments, asc).limit(5)\nres = df3.select(avg(total_payments), avg(delivered_order_count))\n```"}
{"idx": 22, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = olist_orders.order_status, filter = 'delivered')\ndf2 = df1.select(olist_order_items.seller_id, olist_order_items.order_id, olist_orders.customer_id, (olist_order_items.price - olist_order_items.freight_value) as profit)\ndf3 = df2.select(olist_order_items.seller_id, olist_order_items.order_id, olist_customers.customer_unique_id, profit)\ndf4 = df3.groupby(olist_order_items.seller_id).agg(distinct_customer_unique_ids = count(distinct(olist_customers.customer_unique_id)), total_profit = sum(profit), distinct_orders = count(olist_order_items.order_id))\ndf5 = df.where(element = olist_order_reviews.review_score, filter = 5).where(element = olist_orders.order_status, filter = 'delivered').groupby(olist_order_items.seller_id).agg(five_star_orders = count(olist_order_items.order_id))\nres1 = df4.orderby(by = distinct_customer_unique_ids, desc).orderby(by = olist_order_items.seller_id).limit(1).select('Highest number of distinct customer unique IDs (delivered orders)', olist_order_items.seller_id, distinct_customer_unique_ids)\nres2 = df4.orderby(by = total_profit, desc).orderby(by = olist_order_items.seller_id).limit(1).select('Highest profit = SUM(price - freight_value) (delivered orders)', olist_order_items.seller_id, total_profit)\nres3 = df4.orderby(by = distinct_orders, desc).orderby(by = olist_order_items.seller_id).limit(1).select('Highest number of distinct orders (delivered orders)', olist_order_items.seller_id, distinct_orders)\nres4 = df5.orderby(by = five_star_orders, desc).orderby(by = olist_order_items.seller_id).limit(1).select('Most 5-star rated orders (delivered orders)', olist_order_items.seller_id, five_star_orders)\nres = res1.union(res2).union(res3).union(res4)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [olist_orders.order_status], filter = 'delivered')\ndf2 = df1.select([olist_order_items.seller_id, olist_order_items.order_id, olist_orders.customer_id, (olist_order_items.price - olist_order_items.freight_value) as profit])\ndf3 = df2.select([olist_order_items.seller_id, olist_order_items.order_id, olist_customers.customer_unique_id, profit])\ndf4 = df3.groupby([olist_order_items.seller_id]).agg(distinct_customer_unique_ids = count(distinct([olist_customers.customer_unique_id])), total_profit = sum(profit), distinct_orders = count([olist_order_items.order_id]))\ndf5 = df.where(element = [olist_order_reviews.review_score], filter = 5).where(element = [olist_orders.order_status], filter = 'delivered').groupby([olist_order_items.seller_id]).agg(five_star_orders = count([olist_order_items.order_id]))\nres1 = df4.orderby(by = [distinct_customer_unique_ids], desc).orderby(by = [olist_order_items.seller_id]).limit(1).select('Highest number of distinct customer unique IDs (delivered orders)', [olist_order_items.seller_id], [distinct_customer_unique_ids])\nres2 = df4.orderby(by = [total_profit], desc).orderby(by = [olist_order_items.seller_id]).limit(1).select('Highest profit = SUM(price - freight_value) (delivered orders)', [olist_order_items.seller_id], [total_profit])\nres3 = df4.select([res])\nres = res1.union(res2).union(res3).union(res4)\n```"}
{"idx": 23, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(olist_products.product_category_name, olist_order_payments.payment_type).count()\ndf2 = df1.rankby(by = count, desc).where(element = rank, filter = 1)\nres = df2.select(avg(count))\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.groupby([MASK], [MASK]).count()\ndf2 = df1.rankby(by = count, desc).where(element = [MASK], filter = 1)\nres = df2.select(avg([MASK])\n```"}
{"idx": 24, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(olist_order_items.product_id).select(olist_order_payments.payment_type, count(olist_order_items.product_id) as payment_count)\ndf2 = df1.groupby(olist_order_payments.payment_type).orderby(by = count(olist_order_items.product_id), desc).limit(3)\ndf3 = df2.select(olist_order_payments.payment_type, count(olist_order_items.product_id) as payment_count)\nres = df3.orderby(by = payment_count, desc).limit(3)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.groupby([MASK]).select([MASK], count([MASK]) as [MASK])\ndf2 = df1.groupby([MASK]).orderby(by = count([MASK]), desc).limit(3)\ndf3 = df2.select([MASK], count([MASK]) as [MASK])\nres = df3.orderby(by = [MASK], desc).limit(3)\n```"}
{"idx": 25, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.orderby(by = olist_geolocation.geolocation_state, olist_geolocation.geolocation_city, olist_geolocation.geolocation_zip_code_prefix, olist_geolocation.geolocation_lat, olist_geolocation.geolocation_lng).lag(olist_geolocation.geolocation_state, olist_geolocation.geolocation_city, olist_geolocation.geolocation_zip_code_prefix, olist_geolocation.geolocation_lat, olist_geolocation.geolocation_lng)\ndf2 = df1.where(element = olist_geolocation.geolocation_lat, filter = 'is not null')\ndf3 = df2.select(olist_geolocation.prev_state, olist_geolocation.prev_city, olist_geolocation.prev_zip, olist_geolocation.prev_lat, olist_geolocation.prev_lng, olist_geolocation.curr_state, olist_geolocation.curr_city, olist_geolocation.curr_zip, olist_geolocation.curr_lat, olist_geolocation.curr_lng, distance = 111.045 * acos(cos(radians(olist_geolocation.prev_lat)) * cos(radians(olist_geolocation.curr_lat)) * cos(radians(olist_geolocation.curr_lng) - radians(olist_geolocation.prev_lng)) + sin(radians(olist_geolocation.prev_lat)) * sin(radians(olist_geolocation.curr_lat))))\nres = df3.orderby(by = distance, desc).limit(1)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.orderby(by = [MASK], [MASK], [MASK], [MASK], [MASK]).lag([MASK], [MASK], [MASK], [MASK], [MASK])\ndf2 = df1.where(element = [MASK], filter = 'is not null')\ndf3 = df2.select([MASK], [MASK], [MASK], [MASK], [MASK], [MASK], [MASK], [MASK], [MASK], [MASK], [MASK], distance = 111.045 * acos(cos(radians([MASK])) * cos(radians([MASK])) * cos(radians([MASK]) - radians([MASK])) + sin(radians([MASK])) * sin(radians([MASK]))))\nres = df3.orderby(by = distance, desc).limit(1)\n```"}
{"idx": 26, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = language.name, filter = 'English')\ndf2 = df1.where(element = category.name, filter = 'Children')\ndf3 = df2.where(element = film.rating, filter = 'IN', values = ['G', 'PG'])\ndf4 = df3.where(element = film.length, filter = '<= 120')\ndf5 = df4.where(element = film.release_year, filter = 'BETWEEN 2000 AND 2010')\ndf6 = df5.groupby(actor.actor_id).orderby(by = count(distinct(film.film_id)), desc).limit(1)\nres = df6.select(actor.first_name || ' ' || actor.last_name)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = 'English')\ndf2 = df1.where(element = [MASK], filter = 'Children')\ndf3 = df2.where(element = [MASK], filter = 'IN', values = ['G', 'PG'])\ndf4 = df3.where(element = [MASK], filter = '<= 120')\ndf5 = df4.where(element = [MASK], filter = 'BETWEEN 1000 AND 2010')\ndf6 = df5.groupby([MASK]).orderby(by = count(distinct([MASK])), desc).limit(1)\nres = df6.select([MASK])\n```"}
{"idx": 27, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = city.city, filter = 'LIKE A% OR LIKE %-%')\ndf2 = df.groupby(rental.rental_id, inventory.film_id).select(rental.rental_id, inventory.film_id, max(coalesce(rental.return_date, rental.rental_date) - rental.rental_date, default = 0) * 24.0 as rental_hours)\ndf3 = df2.groupby(film_category.category_id, category.name).select(film_category.category_id, category.name, sum(rental_hours) as total_rental_hours)\nres = df3.orderby(by = total_rental_hours, desc).limit(1).select(category.name, total_rental_hours)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = 'LIKE A% OR LIKE %-%')\ndf2 = df.groupby([MASK], [MASK]).select([MASK], [MASK], max(coalesce([MASK] - [MASK], default = 0) * 24.0 as [MASK]))\ndf3 = df2.groupby([MASK], [MASK]).select([MASK], [MASK], sum([MASK]) as [MASK])\nres = df3.orderby(by = [MASK], desc).limit(1).select([MASK], [MASK])\n```"}
{"idx": 28, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = trees.boroname, filter = 'is not null').where(element = trees.boroname, filter = \"!= '').where(element = income_trees.Estimate_Median_income, filter = '> 0').where(element = income_trees.Estimate_Mean_income, filter = '> 0')\ndf2 = df1.select(trees.zipcode).where(element = trees.zipcode, filter = '!= 0').where(element = trees.zipcode, filter = 'is not null').where(element = trees.zipcode, filter = '!= '').select(trees.zipcode).union(df1.select(income_trees.zipcode))\ndf3 = df2.groupby(trees.boroname).agg(count = count(), avg_mean_income = avg(income_trees.Estimate_Mean_income))\nres = df3.orderby(by = count, desc).limit(3)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = 'is not null').where(element = [MASK], filter = \"!= '').where(element = [MASK], filter = '> 0').where(element = [MASK], filter = '> 0')\ndf2 = df1.select([MASK]).where(element = [MASK], filter = '!= 0').where(element = [MASK], filter = 'is not null').where(element = [MASK], filter = \"!= '').select([MASK]).union(df1.select([MASK]))\ndf3 = df2.groupby([MASK]).agg(count = count(), avg_mean_income = avg([MASK]))\nres = df3.orderby(by = count, desc).limit(3)\n```"}
{"idx": 29, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = trees.boroname, filter = 'Bronx').where(element = trees.health, filter = 'Good').where(element = trees.health, filter = 'is not null')\nres = df.select(round((df1.count() * 100.0) / df.where(element = trees.boroname, filter = 'Bronx').count(), 2))\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = '[MASK]').where(element = [MASK], filter = 'Good').where(element = [MASK], filter = 'is not null')\nres = df.select(round((df1.count() * 100.0) / df.where(element = [MASK], filter = '[MASK]').count(), 2))\n```"}
{"idx": 30, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(companies_industries.industry).orderby(by = count(distinct(companies_industries.company_id)), desc).limit(1)\ntmp_res1 = df.where(element = companies_industries.industry, filter = df1.select(companies_industries.industry))\ndf2 = df.where(element = companies_dates.date_joined, filter = 'between 2019 and 2021').where(element = companies_industries.industry, filter = tmp_res1.select(companies_industries.industry))\ndf3 = df2.groupby(cast(companies_dates.date_joined, integer)).count(distinct(companies_industries.company_id))\nres = df.select(round(avg(df3.count()), 2), tmp_res1.select(companies_industries.industry))\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.groupby([MASK]).orderby(by = count(distinct([MASK])), desc).limit(1)\ntmp_res1 = df.where(element = [MASK], filter = df1.select([MASK]))\ndf2 = df.where(element = [MASK], filter = 'between 2019 and 2021').where(element = [MASK], filter = tmp_res1.select([MASK]))\ndf3 = df2.groupby(cast([MASK], integer)).count(distinct([MASK]))\nres = df.select(round(avg(df3.count()), 2), tmp_res1.select([MASK]))\n```"}
{"idx": 31, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(artists.ArtistId, artists.Name).agg(sum(invoice_items.UnitPrice * invoice_items.Quantity) as TotalSales)\ndf2 = df1.orderby(by = TotalSales, desc).limit(1)\ntmp_res1 = df2.select(artists.ArtistId)\n\ndf3 = df.where(invoice_items.TrackId, filter = 'in', subquery = tmp_res1)\ndf4 = df3.groupby(customers.CustomerId, customers.FirstName).agg(sum(invoice_items.UnitPrice * invoice_items.Quantity) as AmountSpent)\ndf5 = df4.where(AmountSpent, filter = '< 1')\nres = df5.orderby(by = AmountSpent, asc, customers.FirstName).select(customers.FirstName, round(AmountSpent, 2) as AmountSpent)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.groupby([MASK], [MASK]).agg(sum([MASK] * [MASK]) as TotalSales)\ndf2 = df1.orderby(by = TotalSales, desc).limit(1)\ntmp_res1 = df2.select([MASK])\n\ndf3 = df.where([MASK], filter = 'in', subquery = tmp_res1)\ndf4 = df3.groupby([MASK], [MASK]).agg(sum([MASK] * [MASK]) as AmountSpent)\ndf5 = df4.where(AmountSpent, filter = '< 1')\nres = df5.orderby(by = AmountSpent, asc, [MASK]).select([MASK], round(AmountSpent, 2) as AmountSpent)\n```"}
{"idx": 32, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(artists.ArtistId).select(artists.ArtistId, artists.Name, sum(invoice_items.UnitPrice * invoice_items.Quantity) as Sales)\ndf2 = df1.orderby(by = Sales, desc, artists.Name, asc).limit(1)\ndf3 = df1.orderby(by = Sales, asc, artists.Name, asc).limit(1)\ndf4 = df.where(invoices.CustomerId, df2.select(ArtistId)).select(invoices.CustomerId, 'TOP' as which, sum(invoice_items.UnitPrice * invoice_items.Quantity) as spend).union(df.where(invoices.CustomerId, df3.select(ArtistId)).select(invoices.CustomerId, 'BOTTOM' as which, sum(invoice_items.UnitPrice * invoice_items.Quantity) as spend))\ndf5 = df4.groupby(which).select(which, avg(spend) as avg_spend)\nres = df.select(abs(coalesce(df5.where(which, 'TOP').select(avg_spend), 0.0) - coalesce(df5.where(which, 'BOTTOM').select(avg_spend), 0.0)) as abs_diff_avg_spend)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.groupby([MASK]).select([MASK], [MASK], sum([MASK] * [MASK]) as Sales)\ndf2 = df1.orderby(by = Sales, desc, [MASK], asc).limit(1)\ndf3 = df1.orderby(by = Sales, asc, [MASK], asc).limit(1)\ndf4 = df.where([MASK], df2.select([MASK])).select([MASK], 'TOP' as which, sum([MASK] * [MASK]) as spend).union(df.where([MASK], df3.select([MASK])).select([MASK], 'BOTTOM' as which, sum([MASK] * [MASK]) as spend))\ndf5 = df4.groupby(which).select(which, avg(spend) as avg_spend)\nres = df.select(abs(coalesce(df5.where(which, 'TOP').select(avg_spend), 0.0) - coalesce(df5.where(which, 'BOTTOM').select(avg_spend), 0.0)) as abs_diff_avg_spend)\n```"}
{"idx": 33, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(customers.Country).having(element = count(*), filter = '> 4')\ndf2 = df.where(invoices.BillingCountry, filter = 'in', df1.select(customers.Country))\ndf3 = df2.groupby(invoices.BillingCountry).select(invoices.Total).sum()\ndf4 = df3.select().with_index().orderby(by = sum(invoices.Total)).limit((df3.count() + 1) / 2).limit((df3.count() + 2) / 2)\nres = df4.select(avg(sum(invoices.Total)))\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.groupby([MASK]).having(element = count(*), filter = '> 4')\ndf2 = df.where([MASK], filter = 'in', df1.select([MASK]))\ndf3 = df2.groupby([MASK]).select([MASK]).sum()\ndf4 = df3.select().with_index().orderby(by = [MASK]).limit((df3.count() + 1) / 2).limit((df3.count() + 2) / 2)\nres = df4.select(avg([MASK]))\n```"}
{"idx": 34, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(customer.customer_id, month(payment.payment_date)).agg(sum(payment.amount) as monthly_amount)\ndf2 = df1.orderby(by = monthly_amount).limit(1)\ndf3 = df1.groupby(customer.customer_id).agg(avg(abs(monthly_amount - lag(monthly_amount, by = month(payment.payment_date)))))\ndf4 = df3.where(monthly_amount - lag(monthly_amount, by = month(payment.payment_date)) is not null)\ndf5 = df4.groupby(customer.customer_id).agg(avg(abs(monthly_amount - lag(monthly_amount, by = month(payment.payment_date)))))\ndf6 = df.select(customer.first_name || ' ' || customer.last_name).orderby(by = avg(abs(monthly_amount - lag(monthly_amount, by = month(payment.payment_date)))), desc).limit(1)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.groupby([MASK], [MASK]).agg(sum([MASK]) as [MASK])\ndf2 = df1.orderby(by = [MASK]).limit(1)\ndf3 = df1.groupby([MASK]).agg(avg(abs([MASK] - lag([MASK], by = [MASK])))\ndf4 = df3.where([MASK] - lag([MASK], by = [MASK]) is not null)\ndf5 = df4.groupby([MASK]).agg(avg(abs([MASK] - lag([MASK], by = [MASK])))\ndf6 = df.select([MASK]).orderby(by = avg(abs([MASK] - lag([MASK], by = [MASK]))), desc).limit(1)\n```"}
{"idx": 35, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = hardware_fact_sales_monthly.fiscal_year, filter = 'IN', values = [2020, 2021])\ndf2 = df1.groupby(hardware_dim_product.segment, hardware_fact_sales_monthly.fiscal_year).agg(count_distinct(hardware_fact_sales_monthly.product_code))\ndf3 = df2.pivot(index = hardware_dim_product.segment, values = [2020, 2021])\ndf4 = df3.select(hardware_dim_product.segment, 2020, 2021)\ndf5 = df4.where(element = 2020, filter = '!=', value = 0).orderby(by = [pct_increase_unique_products_2020_to_2021, 2020], desc)\nres = df5.select(hardware_dim_product.segment, 2020, 2021, pct_increase_unique_products_2020_to_2021)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [MASK], filter = 'IN', values = [2020, 2021])\ndf2 = df1.groupby([MASK], [MASK]).agg(count_distinct([MASK]))\ndf3 = df2.pivot(index = [MASK], values = [2020, 2021])\ndf4 = df3.select([MASK], 2020, 2021)\ndf5 = df4.where(element = 2020, filter = '!=', value = 0).orderby(by = [pct_increase_unique_products_2020_to_2021, 2020], desc)\nres = df5.select([MASK], 2020, 2021, pct_increase_unique_products_2020_to_2021)\n```"}
{"idx": 36, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = hardware_fact_sales_monthly.date, filter = '>= 2021-01-01').where(element = hardware_fact_sales_monthly.date, filter = '< 2022-01-01')\ndf2 = df1.groupby(hardware_dim_product.division, hardware_fact_sales_monthly.product_code).agg(total_qty_2021 = sum(hardware_fact_sales_monthly.sold_quantity))\ndf3 = df2.orderby(by = total_qty_2021, desc).limit(3)\nres = df3.groupby(hardware_dim_product.division).agg(avg_qty_sold_top3_products_2021 = avg(total_qty_2021))\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [hardware_fact_sales_monthly.date], filter = '>= 2021-01-01').where(element = [hardware_fact_sales_monthly.date], filter = '< 2022-01-01')\ndf2 = df1.groupby([hardware_dim_product.division], [hardware_fact_sales_monthly.product_code]).agg(total_qty_2021 = sum([hardware_fact_sales_monthly.sold_quantity]))\ndf3 = df2.orderby(by = [total_qty_2021], desc).limit(3)\nres = df3.groupby([hardware_dim_product.division]).agg(avg_qty_sold_top3_products_2021 = avg([total_qty_2021]))\n```"}
{"idx": 37, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\n\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [Business_Hours].business_id, filter = 12)\ndf2 = df1.where(element = [Days].day_of_week, filter = 'Monday')\nres = df2.select([Business_Hours].opening_time)\n```"}
{"idx": 38, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\n\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [Business_Hours].business_id, filter = 12)\ndf2 = df1.where(element = [Days].day_of_week, filter = 'Monday')\nres = df2.select([Business_Hours].opening_time)\n```"}
{"idx": 39, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = times.calendar_year, filter = 2019).where(element = promotions.promo_total_id, filter = 1).where(element = channels.channel_total_id, filter = 1).where(element = countries.country_name, filter = 'France')\ndf2 = df.where(element = times.calendar_year, filter = 2020).where(element = promotions.promo_total_id, filter = 1).where(element = channels.channel_total_id, filter = 1).where(element = countries.country_name, filter = 'France')\ndf3 = df1.groupby(sales.prod_id, times.calendar_year, times.calendar_month_number).select(sales.amount_sold)\ndf4 = df2.groupby(sales.prod_id, times.calendar_month_number).select(sales.amount_sold)\n\ndf5 = df.select(df3.prod_id, df3.calendar_year, df3.calendar_month_number, df3.sales_amt).join(df4, on = [df3.prod_id, df4.prod_id, df3.calendar_month_number, df4.calendar_month_number])\ndf6 = df5.where(element = df3.sales_amt, filter = '!=', element = df4.sales_amt).select(df5.prod_id, df5.calendar_month_number, (df5.sales_amt - df4.sales_amt) * 1.0 / df4.sales_amt * df5.sales_amt + df5.sales_amt)\n\ndf7 = df.where(element = times.calendar_year, filter = 2021).where(element = currency.country, filter = 'France')\ndf8 = df6.select(df6.prod_id, df6.calendar_month_number, df6.projected_2021_amt).join(df7, on = [df6.calendar_month_number, df7.month])\ndf9 = df8.select(df8.prod_id, df8.calendar_month_number, df8.projected_2021_amt * df7.to_us)\n\nres = df9.groupby(df8.calendar_month_number).select(df8.calendar_month_number, round(avg(df8.projected_2021_usd), 2))\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [MASK], filter = 2019).where(element = [MASK], filter = 1).where(element = [MASK], filter = 1).where(element = [MASK], filter = 'France')\ndf2 = df.where(element = [MASK], filter = 2020).where(element = [MASK], filter = 1).where(element = [MASK], filter = 1).where(element = [MASK], filter = 'France')\ndf3 = df1.groupby([MASK], [MASK], [MASK]).select([MASK])\ndf4 = df2.groupby([MASK], [MASK]).select([MASK])\n\ndf5 = df.select(df3.[MASK], df3.[MASK], df3.[MASK]).join(df4, on = [df3.[MASK], df4.[MASK]])\ndf6 = df5.where(element = df3.[MASK], filter = '!=', element = df4.[MASK]).select(df5.[MASK], df5.[MASK], (df5.[MASK] - df4.[MASK]) * 1.0 / df4.[MASK] * df5.[MASK] + df5.[MASK])\n\ndf7 = df.where(element = [MASK], filter = 2021).where(element = [MASK], filter = 'France')\ndf8 = df6.select(df6.[MASK], df6.[MASK], df6.[MASK]).join(df7, on = [df6.[MASK], df7.[MASK]])\ndf9 = df8.select(df8.[MASK], df8.select([MASK])\n\nres = df9.groupby([MASK], [MASK], filter = 12)\nres = df9.select([MASK])\n```"}
{"idx": 40, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = countries.country_name, filter = 'France')\ndf2 = df1.where(element = times.calendar_year, filter = 'IN', values = [2019, 2020])\ndf3 = df2.where(element = promotions.promo_id, filter = 1)\ndf4 = df3.where(element = channels.channel_id, filter = 1)\ndf5 = df4.groupby(times.calendar_year, times.calendar_month_number).agg(sales.amount_sold = sum(sales.amount_sold))\ndf6 = df5.select(sales_local = sales.amount_sold)\n\ndf7 = df.where(element = times.calendar_year, filter = 2021)\ndf8 = df7.where(element = currency.country, filter = 'France')\ndf9 = df8.groupby(times.calendar_month_number).agg(projected_local_2021 = case(when(sales_local_2019 = null or sales_local_2019 = 0, then null, else ((sales_local_2021 - sales_local_2019) * 1.0 / sales_local_2019 * sales_local_2021) + sales_local_2021))\n\ndf10 = df9.select(projected_local_2021)\ndf11 = df10.multiply(element = projected_local_2021, other = currency.to_us).round(2)\n\ndf12 = df11.groupby(times.calendar_month_number).agg(avg_monthly_projected_usd = avg(projected_usd))\n\ndf13 = df12.orderby(by = avg_monthly_projected_usd).select(avg_monthly_projected_usd, row_number = row_number(), count = count())\ndf14 = df13.where(element = row_number, filter = 'IN', values = [(count + 1) / 2, (count + 2) / 2])\nres = df14.select(avg(avg_monthly_projected_usd))\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [MASK], filter = 'France')\ndf2 = df1.where(element = [MASK], filter = 'IN', values = [2019, 2020])\ndf3 = df2.where(element = [MASK], filter = 1)\ndf4 = df3.where(element = [MASK], filter = 1)\ndf5 = df4.groupby([MASK], [MASK]).agg(sales.amount_sold = sum(sales.amount_sold))\ndf6 = df5.select(sales_local = sales.amount_sold)\n\ndf7 = df.where(element = [MASK], filter = 2021)\ndf8 = df7.where(element = [MASK], filter = 'France')\ndf9 = df8.groupby([MASK]).agg(projected_local_2021 = case(when(sales_local_2019 = null or sales_local_2019 = 0, then null, else ((sales_local_2021 - sales_local_2019) * 1.0 / sales_local_2019 * sales_local_2021) + sales_local_2021))\n\ndf10 = df9.select(projected_local_2021)\ndf11 = df10.multiply(element = projected_local_2021, other = [MASK]).round(2)\n\ndf12 = df11.groupby([MASK]).agg(avg_monthly_projected_usd = avg(projected_usd))\n\ndf13 = df12.orderby(by = avg_monthly_projected_usd).select(avg_monthly_projected_usd, row_number = row_number(), count = count())\ndf14 = df.where(element = [MASK], filter = 'Monday')\nres = df.select(avg(avg_monthly_projected_usd))\n```"}
{"idx": 41, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = countries.country_name, filter = 'Italy')\ndf2 = df1.where(element = sales.time_id, filter = '>= 2021-12-01').where(element = sales.time_id, filter = '< 2022-01-01')\ndf3 = df2.select(sales.cust_id, sum(multiply(sales.quantity_sold, subtract(costs.unit_price, costs.unit_cost))) as total_profit).groupby(sales.cust_id)\ndf4 = df3.aggregate(min(total_profit) as min_profit, max(total_profit) as max_profit)\ndf5 = df3.select(cust_profit.cust_id, cust_profit.total_profit, df4.min_profit, df4.max_profit, case when df4.max_profit = df4.min_profit then 1 else min(10, cast((cust_profit.total_profit - df4.min_profit, as float) / (df4.max_profit - df4.min_profit) / 10.0), as int) + 1 end as bucket)\nres = df5.groupby(bucket).select(bucket, count(), min(total_profit), max(total_profit))\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [countries.country_name], filter = 'Italy')\ndf2 = df1.where(element = [sales.time_id], filter = '>= 2021-12-01').where(element = [sales.time_id], filter = '< 2022-01-01')\ndf3 = df2.select([sales.cust_id], sum(multiply([sales.quantity_sold], subtract([costs.unit_price], [costs.unit_cost])) as [total_profit]).groupby([sales.cust_id])\ndf4 = df3.aggregate(min([total_profit]) as [min_profit], max([total_profit]) as [max_profit])\ndf5 = df3.select([cust_profit.cust_id], [cust_profit.total_profit], [df4.min_profit], [df4.max_profit], case when [df4.max_profit] = [df4.min_profit] then 1 else min(10, cast(([cust_profit.total_profit] - [df4.min_profit], as float) / ([df4.max_profit] - [df4.min_profit]) / 10.0), as int) + 1 end as [bucket])\nres = df5.groupby([bucket]).select([bucket], count(), min([total_profit]), max([total_profit]))\n```"}
{"idx": 42, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = countries.country_name, filter = 'Italy')\ndf2 = df1.where(element = sales.time_id, filter = '>= 2021-12-01').where(element = sales.time_id, filter = '< 2022-01-01')\ndf3 = df2.select(sales.cust_id, sales.amount_sold - (sales.quantity_sold * costs.unit_cost) as profit).groupby(sales.cust_id)\ndf4 = df3.select(cust_id, profit).ntile(10, by = profit, order = asc)\nres = df4.groupby(ntile(profit, 10, order = asc)).select(min(profit) as lowest_profit, max(profit) as highest_profit)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = 'Italy')\ndf2 = df1.where(element = [MASK], filter = '>= 2021-12-01').where(element = [MASK], filter = '< 2022-01-01')\ndf3 = df2.select([MASK], [MASK] - ([MASK] * [MASK]) as [MASK]).groupby([MASK])\ndf4 = df3.select([MASK], [MASK]).ntile(10, by = [MASK], order = asc)\nres = df4.groupby(ntile([MASK], 10, order = asc)).select(min([MASK]) as [MASK], max([MASK]) as [MASK])\n```"}
{"idx": 43, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\n\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [Business_Hours].business_id, filter = 12)\ndf2 = df1.where(element = [Days].day_of_week, filter = 'Monday')\nres = df2.select([Business_Hours].opening_time)\n```"}
{"idx": 44, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = cities.insert_date, filter = '>= date(2022-06-01)').where(element = cities.insert_date, filter = '< date(2022-07-01)')\ndf2 = df1.groupby(cities.country_code_2, cities.insert_date).select(cities.country_code_2, cities.insert_date)\ndf3 = df2.select(cities.country_code_2, julianday(cities.insert_date) - row_number() over (partition by cities.country_code_2 order by cities.insert_date) as grp)\ndf4 = df3.groupby(cities.country_code_2, grp).count(cities.insert_date) as streak_len\ndf5 = df4.max(streak_len)\nres = df4.where(element = streak_len, filter = df5.max_len).select(cities.country_code_2).groupby(cities.country_code_2).orderby(cities.country_code_2)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [MASK], filter = '>= date(2022-06-01)').where(element = [MASK], filter = '< date(2022-07-01)')\ndf2 = df1.groupby([MASK], [MASK]).select([MASK], [MASK])\ndf3 = df2.select([MASK], julianday([MASK]) - row_number() over (partition by [MASK] order by [MASK]) as [MASK])\ndf4 = df3.groupby([MASK], [MASK]).count([MASK]) as [MASK]\ndf5 = df4.max([MASK])\nres = df4.where(element = [MASK], filter = df5.max([MASK])).select([MASK]).groupby([MASK]).orderby([MASK])\n```"}
{"idx": 45, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = cities.insert_date, filter = \">= '2022-01-01\").where(element = cities.insert_date, filter = '< '2022-02-01')\ndf2 = df1.groupby(cities_countries.country_name).having(element = count(distinct(cities.insert_date)), filter = '= 9')\ndf3 = df1.where(element = cities_countries.country_name, filter = 'in', value = df2.select(cities_countries.country_name))\ndf4 = df3.select(cities.country_name, cities.insert_date).distinct()\ndf5 = df4.orderby(by = cities.insert_date).window(partition_by = cities.country_name, frame = row).select(julianday(cities.insert_date) - row_number() over (partition by cities.country_name order by cities.insert_date) as grp)\ndf6 = df5.groupby(cities.country_name, grp).select(min(cities.insert_date) as run_start, max(cities.insert_date) as run_end, count() as consecutive_days)\ndf7 = df6.orderby(by = [consecutive_days, run_start], desc).select(cities.country_name, run_start, run_end, consecutive_days).limit(1)\ndf8 = df3.where(element = cities.insert_date, filter = 'between', value = df7.select(run_start, run_end))\nres = df8.groupby(cities.country_name, run_start, run_end, consecutive_days).select(cities.country_name, run_start, run_end, consecutive_days, sum(if(cities.capital = 1, 1, 0)) as capital_entries, count() as total_entries, 1.0 * sum(if(cities.capital = 1, 1, 0)) / count() as capital_entry_proportion)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [MASK], filter = \">= '2022-01-01\").where(element = [MASK], filter = \"< '2022-02-01\")\ndf2 = df1.groupby([MASK]).having(element = count(distinct([MASK])), filter = '= 9')\ndf3 = df1.where(element = [MASK], filter = 'in', value = df2.select([MASK]))\ndf4 = df3.select([MASK], [MASK]).distinct()\ndf5 = df4.orderby(by = [MASK]).window(partition_by = [MASK], frame = row).select(julianday([MASK]) - row_number() over (partition by [MASK] order by [MASK]) as grp)\ndf6 = df5.groupby([MASK], grp).select(min([MASK]) as run_start, max([MASK]) as run_end, count() as consecutive_days)\ndf7 = df6.orderby(by = [consecutive_days, run_start], desc).select([MASK], run_start, run_end, consecutive_days).limit(1)\ndf8 = df3.where(element = [MASK], filter = 'between', value = df7.select(run_start, run_end))\nres = df8.groupby([MASK], run_start, run_end, consecutive_days).select([MASK], run_start, run_end, consecutive_days, sum(if([MASK] = 1, 1, 0)) as capital_entries, count() as total_entries, 1.0 * sum(if([MASK] = 1, 1, 0)) as capital_proportion)\n```"}
{"idx": 46, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = cities.insert_date, filter = 'between 2021 and 2023').where(element = cities.insert_date, filter = 'in (4, 5, 6)')\ndf2 = df1.groupby(cities.insert_date).agg(count())\ndf3 = df2.select(cities.insert_date, count(cities.insert_date) as month_total)\ndf4 = df3.select(cast(cities.insert_date, integer) as year, cast(substring(cities.insert_date, 1, 2), integer) as month_num, substring(cities.insert_date, 1, 2) as month, month_total)\ndf5 = df4.groupby(cast(cities.insert_date, integer), cast(substring(cities.insert_date, 1, 2), integer), substring(cities.insert_date, 1, 2)).agg(sum(month_total) over(order by cast(cities.insert_date, integer), rows between unbounded preceding and current row) as running_total)\ndf6 = df5.select(cast(cities.insert_date, integer) as year, cast(substring(cities.insert_date, 1, 2), integer) as month_num, substring(cities.insert_date, 1, 2) as month, month_total, running_total, lag(month_total) over(order by cast(cities.insert_date, integer), partition by cast(substring(cities.insert_date, 1, 2), integer)) as prev_month_total, lag(running_total) over(order by cast(cities.insert_date, integer), partition by cast(substring(cities.insert_date, 1, 2), integer)) as prev_running_total)\ndf7 = df6.where(element = cast(cities.insert_date, integer), filter = 'in (2022, 2023)')\ndf8 = df7.select(year, case(cast(substring(cities.insert_date, 1, 2), integer), when(4, 'April'), when(5, 'May'), when(6, 'June')) as month, month_total as cities_added_in_month, running_total as cumulative_running_total_for_month, round(100.0 * (month_total - prev_month_total) / nullif(prev_month_total, 0), 2) as yoy_growth_month_total_pct, round(100.0 * (running_total - prev_running_total) / nullif(prev_running_total, 0), 2) as yoy_growth_running_total_pct, order by cast(substring(cities.insert_date, 1, 2), integer), cast(cities.insert_date, integer))\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = 'between 2021 and 2023').where(element = [MASK], filter = 'in (4, 5, 6)')\ndf2 = df1.groupby([MASK]).agg(count())\ndf3 = df2.select([MASK], count([MASK]) as [MASK])\ndf4 = df3.select(cast([MASK], integer) as [MASK], cast(substring([MASK], 1, 2), integer) as [MASK], substring([MASK], 1, 2) as [MASK], count([MASK]))\ndf5 = df4.groupby(cast([MASK], integer), cast(substring([MASK], 1, 2), integer), substring([MASK], 1, 2)).agg(sum(count([MASK])) over(order by cast([MASK], integer), rows between unbounded preceding and current row) as [MASK])\ndf6 = df5.select(cast([MASK], integer) as [MASK], cast(substring([MASK], 1, 2), integer) as [MASK], substring([MASK], 1, 2) as [MASK], count([MASK]), [MASK], lag(count([MASK])) over(order by cast([MASK], integer), partition by cast(substring([MASK], 1, 2), integer)) as [MASK], lag([MASK]) over(order by cast([MASK], integer), partition by cast(substring([MASK], 1, 2), integer)) as [MASK])\ndf7 = df6.where(element = [MASK], filter = 'in (12)')\ndf7 = df.where(element = [MASK], filter = 'in (2022, 2023)')\ndf8 = df7.select([MASK], case(cast(substring([MASK], 1, 2), integer), when(4, 'April'), when(5, 'May'), when(6, 'June')) as [MASK], count([MASK]) as [MASK], [MASK], round(100.0 * (count([MASK]) - lag(count([MASK])) over(order by cast([MASK], integer), partition by cast(substring([MASK], 1, 2), integer)), 2) as [MASK], round(100.0 * ([MASK] - lag([MASK]) over(order by cast([MASK], integer), partition by cast(substring([MASK], 1, 2), integer)), 2) as [MASK], order by cast(substring([MASK], 1, 2), integer), cast([MASK], integer))\n```"}
{"idx": 47, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\n\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [Business_Hours].business_id, filter = 12)\ndf2 = df1.where(element = [Days].day_of_week, filter = 'Monday')\nres = df2.select([Business_Hours].opening_time)\n```"}
{"idx": 48, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = pizza_clean_runner_orders.cancellation, filter = 'IS NULL').or_where(element = pizza_clean_runner_orders.cancellation, filter = \"''\")\ndf2 = df.select(pizza_recipes.pizza_id, split(toppings))\ndf3 = df2.select(split(toppings) as topping_id)\ndf4 = df1.join(df3, on = pizza_recipes.pizza_id).join(pizza_toppings, on = topping_id)\nres = df4.groupby(pizza_toppings.topping_name).count().orderby(by = [count(*), pizza_toppings.topping_name])\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [pizza_clean_runner_orders.cancellation], filter = 'IS NULL').or_where(element = [pizza_clean_runner_orders.cancellation], filter = \"''\")\ndf2 = df.select([pizza_recipes.pizza_id], [split(toppings)])\ndf3 = df2.select([split(toppings)] as [topping_id])\ndf4 = df1.join(df3, on = [pizza_recipes.pizza_id]).join([pizza_toppings], on = [topping_id])\nres = df4.groupby([pizza_toppings.topping_name]).count().orderby(by = [count(*), [pizza_toppings.topping_name]])\n```"}
{"idx": 49, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = pizza_clean_runner_orders.cancellation, filter = 'IS NULL').or_where(element = pizza_clean_runner_orders.cancellation, filter = '== \"\"')\ndf2 = df.select(pizza_get_extras.order_id, sum(pizza_get_extras.extras_count) as extra_cnt).groupby(pizza_get_extras.order_id)\ndf3 = df1.join(pizza_names, on = pizza_clean_customer_orders.pizza_id).where(element = pizza_names.pizza_name, filter = 'Meatlovers').or_where(element = pizza_names.pizza_name, filter = 'Vegetarian')\nres = df3.select(sum((base_price + extra_cnt * 1)))\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = 'IS NULL').or_where(element = [MASK], filter = '== \"\"')\ndf2 = df.select([MASK], sum([MASK]) as [MASK]).groupby([MASK])\ndf3 = df1.join([MASK], on = [MASK]).where(element = [MASK], filter = 'Meatlovers').or_where(element = [MASK], filter = 'Vegetarian')\nres = df3.select(sum(([MASK] + [MASK] * 1))\n```"}
{"idx": 50, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(customer_transactions.customer_id, date(customer_transactions.txn_date, 'start of month')).agg(case(customer_transactions.txn_type, when in(['deposit', 'credit'], then(customer_transactions.txn_amount), when in(['withdrawal', 'debit', 'purchase'], then(-customer_transactions.txn_amount), else(customer_transactions.txn_amount))))\ndf2 = df.groupby(customer_transactions.customer_id).agg(min(date(customer_transactions.txn_date, 'start of month')), max(date(customer_transactions.txn_date, 'start of month')))\ndf3 = df.select(customer_transactions.customer_id, min(date(customer_transactions.txn_date, 'start of month')) as month_start, max(date(customer_transactions.txn_date, 'start of month')) as max_month)\ndf4 = df3.union(df.select(customer_transactions.customer_id, date(month_start, '+1 month') as month_start, max_month))\ndf5 = df4.groupby(customer_transactions.customer_id, month_start).agg(coalesce(monthly_net.net_change, 0))\nres = df5.orderby(by = [customer_transactions.customer_id, month_start]).select(customer_transactions.customer_id, date(month_start, '+1 month', '-1 day') as month_end, monthly_change as monthly_change_amount, sum(monthly_change) over (partition by customer_transactions.customer_id, order by month_start rows between unbounded preceding and current row) as closing_balance)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.groupby([MASK], date([MASK], 'start of month')).agg(case([MASK], when in(['deposit', 'credit'], then([MASK]), when in(['withdrawal', 'debit', 'purchase'], then(-[MASK]), else([MASK])))\ndf2 = df.groupby([MASK]).agg(min(date([MASK], 'start of month')), max(date([MASK], 'start of month')))\ndf3 = df.select([MASK], min(date([MASK], 'start of month')) as month_start, max(date([MASK], 'start of month')) as max_month)\ndf4 = df3.union(df.select([MASK], date(month_start, '+1 month') as month_start, max_month))\ndf5 = df4.groupby([MASK], month_start).agg(coalesce([MASK].net_change, 0))\nres = df5.orderby(by = [MASK], month_start).select([MASK], date(month_start, '+1 month', '-1 day') as month_end, [MASK] as monthly_change_amount, sum([MASK]) over (partition by [MASK], order by month_start rows between unbounded preceding and current row) as closing_balance)\n```"}
{"idx": 51, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\n\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [Business_Hours].business_id, filter = 12)\ndf2 = df1.where(element = [Days].day_of_week, filter = 'Monday')\nres = df2.select([Business_Hours].opening_time)\n```"}
{"idx": 52, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(customer_transactions.customer_id).agg(monthly_net = sum(case(customer_transactions.txn_type, when 'deposit', customer_transactions.txn_amount, when 'withdrawal', -customer_transactions.txn_amount, else 0)))\ndf2 = df1.groupby(customer_transactions.customer_id).agg(monthly_balance = sum(monthly_net.net_amount) over(order by customer_transactions.txn_date, 'start of month' rows between unbounded preceding and current row))\ndf3 = df2.select(customer_transactions.customer_id, monthly_balance.month_start, monthly_balance.net_amount, lag(monthly_balance.monthly_balance) over(order by customer_transactions.txn_date, 'start of month') as prev_monthly_balance, row_number() over(order by customer_transactions.txn_date, 'start of month' desc) as rn)\ndf4 = df3.where(element = rn, filter = 1).select(customer_transactions.customer_id, monthly_balance.month_start, monthly_balance.net_amount, monthly_balance.closing_balance, prev_monthly_balance)\ndf5 = df4.select(case(when(coalesce(prev_monthly_balance, 0) = 0, then monthly_balance.closing_balance * 100.0, else (monthly_balance.closing_balance - prev_monthly_balance) * 100.0 / prev_monthly_balance) as growth_rate)\nres = df5.where(element = growth_rate, filter = '> 5.0').count().multiply(100.0 / df5.count())\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.groupby([MASK]).agg(monthly_net = sum(case([MASK], when 'deposit', [MASK], when 'withdrawal', -[MASK], else 0)))\ndf2 = df1.groupby([MASK]).agg(monthly_balance = sum(monthly_net.net_amount) over(order by [MASK], 'start of month' rows between unbounded preceding and current row))\ndf3 = df2.select([MASK], monthly_balance.month_start, monthly_balance.net_amount, lag(monthly_balance.monthly_balance) over(order by [MASK], 'start of month') as prev_monthly_balance, row_number() over(order by [MASK], 'start of month' desc) as rn)\ndf4 = df3.where(element = rn, filter = 1).select([MASK], monthly_balance.month_start, monthly_balance.net_amount, monthly_balance.closing_balance, prev_monthly_balance)\ndf5 = df4.select(case(when(coalesce(prev_monthly_balance, 0) = 0, then monthly_balance.closing_balance * 100.0, else (monthly_balance.closing_balance - prev_monthly_balance) * 100.0 / prev_monthly_balance) as growth_rate)\nres = df5.where(element = growth_rate, filter = '> 5.0').count().multiply(100.0 / df5.count())\n```"}
{"idx": 53, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.select(bitcoin_transactions.member_id, date(bitcoin_transactions.txn_date) as txn_date, \n               case(when lower(bitcoin_transactions.txn_type) = 'buy', bitcoin_transactions.quantity, when lower(bitcoin_transactions.txn_type) = 'sell', -bitcoin_transactions.quantity, else 0) as qty_delta)\n\ndf2 = df1.groupby(bitcoin_transactions.member_id).select(bitcoin_transactions.txn_date, distinct)\n\ndf3 = df2.select(months, distinct)\n\ndf4 = df3.select(bitcoin_transactions.member_id, months).crossjoin()\n\ndf5 = df4.select(months, member_id).groupby(bitcoin_transactions.member_id, months).agg({'qty_delta': 'sum'})\n\ndf6 = df5.select(months, member_id, coalesce(qty_delta, 0) as balance_asof_month_start)\n\ndf7 = df6.groupby(months).agg({'balance_asof_month_start': 'sum'})\n\ndf8 = df7.select(months, case when balance_asof_month_start < 0, 0, balance_asof_month_start) as total_balance_prev_month)\n\ndf9 = df8.groupby(months).rank(by = total_balance_prev_month, order = asc).where(rank > 1)\n\nres = df9.select(months, total_balance_prev_month).orderby(by = months)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.select([MASK], date([MASK]) as [MASK], \n               case(when lower([MASK]) = 'buy', [MASK], when lower([MASK]) = 'sell', -[MASK], else 0) as [MASK])\n\ndf2 = df1.groupby([MASK]).select([MASK], distinct)\n\ndf3 = df2.select([MASK], distinct)\n\ndf4 = df3.select([MASK]).crossjoin()\n\ndf5 = df4.select([MASK], [MASK]).groupby([MASK], [MASK]).agg({'[MASK]': 'sum'})\n\ndf6 = df5.select([MASK], [MASK], coalesce([MASK], 0) as [MASK])\n\ndf7 = df6.groupby([MASK]).agg({'[MASK]': 'sum'})\n\ndf8 = df7.select([MASK], case when [MASK] < 0, 0, [MASK]) as [MASK]\n\ndf9 = df8.groupby([MASK]).rank(by = [MASK], order = asc).where(rank > 1)\n\nres = df9.select([MASK], [MASK]).orderby(by = [MASK])\n```"}
{"idx": 54, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(customer_transactions.customer_id, date(customer_transactions.txn_date)).select(customer_transactions.customer_id, date(customer_transactions.txn_date), sum(case when lower(customer_transactions.txn_type) = 'deposit' then customer_transactions.txn_amount else -customer_transactions.txn_amount end) as net_amount)\ndf2 = df1.groupby(customer_transactions.customer_id).select(customer_transactions.customer_id, min(date(customer_transactions.txn_date)) as min_date, max(date(customer_transactions.txn_date)) as max_date)\ndf3 = df2.select(customer_transactions.customer_id, min_date as txn_date, max_date)\ntmp_res3 = df3.union(df3.select(customer_transactions.customer_id, add(date(min_date), 1) as txn_date, max_date))\n\ndf4 = tmp_res3.select(customer_transactions.customer_id, txn_date, coalesce(df1.net_amount, 0) as net_amount)\n\ndf5 = df4.groupby(customer_transactions.customer_id, txn_date).select(customer_transactions.customer_id, txn_date, sum(net_amount) over(order by txn_date rows between unbounded preceding and current row) as running_balance)\n\ndf6 = df5.groupby(customer_transactions.customer_id).select(customer_transactions.customer_id, txn_date, running_balance, count() over(order by txn_date rows between 29 preceding and current row) as days_in_window, avg(running_balance) over(order by txn_date rows between 29 preceding and current row) as avg_30_raw)\n\ndf7 = df6.select(customer_transactions.customer_id, txn_date, strftime('%Y-%m-01', txn_date) as month_start, case when days_in_window = 30 then max(avg_30_raw, 0) else null end as avg_30)\n\ndf8 = df7.where(avg_30 is not null).groupby(customer_transactions.customer_id, month_start).select(customer_transactions.customer_id, month_start, max(avg_30) as max_30_day_avg)\n\ndf9 = df8.groupby(customer_transactions.customer_id).select(min(month_start) as baseline_month)\n\nres = df8.where(month_start > df9.baseline_month).groupby(month_start).select(month_start, sum(max_30_day_avg))\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.groupby([MASK], date([MASK])).select([MASK], date([MASK]), sum(case when lower([MASK]) = 'deposit' then [MASK] else -[MASK] end) as [MASK])\ndf2 = df1.groupby([MASK]).select([MASK], min(date([MASK])) as [MASK], max(date([MASK])) as [MASK])\ndf3 = df2.select([MASK], [MASK] as [MASK])\ntmp_res3 = df3.union(df3.select([MASK], add([MASK], 1) as [MASK]))\n\ndf4 = tmp_res3.select([MASK], [MASK], coalesce(df1.[MASK], 0) as [MASK])\n\ndf5 = df4.groupby([MASK], [MASK]).select([MASK], [MASK], sum([MASK]) over(order by [MASK] rows between unbounded preceding and current row) as [MASK])\n\ndf6 = df5.groupby([MASK]).select([MASK], [MASK], [MASK], count() over(order by [MASK] rows between 29 preceding and current row) as [MASK], avg([MASK]) over(order by [MASK] rows between 29 preceding and current row) as [MASK])\n\ndf7 = df6.select([MASK], [MASK], strftime('%Y-%m-01', [MASK]) as [MASK], case when [MASK] = 30 then max([MASK], 0) else null end as [MASK])\n\ndf8 = df7.where([MASK] is not null).groupby([MASK], [MASK]).select([MASK]).select([MASK])\nres = df8.select([MASK])\n```"}
{"idx": 55, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.select(customer_transactions.customer_id, date(customer_transactions.txn_date) as txn_date, case(customer_transactions.txn_type, 'deposit', customer_transactions.txn_amount, 'purchase', -customer_transactions.txn_amount, 'withdrawal', -customer_transactions.txn_amount, 0))\ndf2 = df1.groupby(customer_transactions.customer_id, txn_date).agg(sum(customer_transactions.signed_amount) as net_change)\ndf3 = df2.groupby(customer_transactions.customer_id).agg(min(txn_date) as min_date, max(txn_date) as max_date)\ndf4 = df3.expand().union(df3.select(customer_id, date(min_date, '+1 day') as d, max_date))\ndf5 = df4.groupby(customer_id).agg(cal_with_change.customer_id, cal_with_change.txn_date, coalesce(daily_change.net_change, 0) as net_change)\ndf6 = df5.groupby(customer_id).agg(max(0, sum(net_change) over (partition by customer_id order by txn_date rows between unbounded preceding and current row)) as balance)\ndf7 = df6.groupby(strftime('%Y-%m', txn_date) as month, customer_id).agg(max(balance) as max_daily_balance)\nres = df7.groupby(month).agg(sum(max_daily_balance) as monthly_total_max_balance).orderby(by = month)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.select([MASK], date([MASK]) as [MASK], case([MASK], 'deposit', [MASK], 'purchase', -[MASK], 'withdrawal', -[MASK], 0))\ndf2 = df1.groupby([MASK], date([MASK])).agg(sum([MASK]) as [MASK])\ndf3 = df2.groupby([MASK]).agg(min(date([MASK])) as [MASK], max(date([MASK])) as [MASK])\ndf4 = df3.expand().union(df3.select([MASK], date([MASK], '+1 day') as [MASK], [MASK]))\ndf5 = df4.groupby([MASK]).agg([MASK].customer_id, [MASK].txn_date, coalesce([MASK].net_change, 0) as [MASK])\ndf6 = df5.groupby([MASK]).agg(max(0, sum([MASK].net_change) over (partition by [MASK] order by [MASK] rows between unbounded preceding and current row)) as [MASK])\ndf7 = df6.groupby(strftime('%Y-%m', [MASK]) as [MASK], [MASK]).agg(max([MASK]) as [MASK])\nres = df7.groupby([MASK]).agg(sum([MASK]) as [MASK]).orderby(by = [MASK])\n```"}
{"idx": 56, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = shopping_cart_events.page_id, filter = 'NOT IN (1, 2, 12, 13)')\ndf2 = df1.where(element = shopping_cart_page_hierarchy.product_id, filter = 'IS NOT NULL')\ndf3 = df2.groupby(shopping_cart_page_hierarchy.product_id, shopping_cart_page_hierarchy.page_name).select(shopping_cart_events.visit_id, shopping_cart_page_hierarchy.product_id, shopping_cart_page_hierarchy.page_name, shopping_cart_event_identifier.event_name)\ndf4 = df3.where(element = shopping_cart_event_identifier.event_name, filter = 'Page View').count()\ndf5 = df3.where(element = shopping_cart_event_identifier.event_name, filter = 'Add to Cart').count()\ndf6 = df3.where(element = shopping_cart_event_identifier.event_name, filter = 'Purchase').count()\ndf7 = df3.groupby(shopping_cart_page_hierarchy.product_id, shopping_cart_page_hierarchy.page_name).select(shopping_cart_page_hierarchy.product_id, shopping_cart_page_hierarchy.page_name, max(if(shopping_cart_event_identifier.event_name = 'Add to Cart', 1, 0)) as has_add, max(if(shopping_cart_event_identifier.event_name = 'Purchase', 1, 0)) as has_purchase)\ndf8 = df7.where(element = has_add, filter = '1').where(element = has_purchase, filter = '0').count()\nres = df4.select(shopping_cart_page_hierarchy.product_id, shopping_cart_page_hierarchy.page_name, df5, df6, df8)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [MASK], filter = 'NOT IN (1, 2, 12, 13)')\ndf2 = df1.where(element = [MASK], filter = 'IS NOT NULL')\ndf3 = df2.groupby([MASK], [MASK]).select([MASK], [MASK], [MASK], [MASK])\ndf4 = df3.where(element = [MASK], filter = 'Page View').count()\ndf5 = df3.where(element = [MASK], filter = 'Add to Cart').count()\ndf6 = df3.where(element = [MASK], filter = 'Purchase').count()\ndf7 = df3.groupby([MASK], [MASK]).select([MASK], [MASK], max(if([MASK] = 'Add to Cart', 1, 0)) as [MASK], max(if([MASK] = 'Purchase', 1, 0)) as [MASK])\ndf8 = df7.where(element = [MASK], filter = '1').where(element = [MASK], filter = '0').count()\nres = df4.select([MASK], [MASK], df5, df6, df8)\n```"}
{"idx": 57, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = interest_metrics._year, filter = '2018').where(element = interest_metrics._month, filter = '09').select(interest_metrics.interest_id, interest_metrics.composition, interest_metrics.index_value)\ndf2 = df1.select(interest_metrics.interest_id, (interest_metrics.composition * 1.0) / interest_metrics.index_value as avg_composition)\ndf3 = df2.orderby(by = avg_composition, desc).select(interest_metrics.interest_id, avg_composition).limit(1)\ndf4 = df.where(element = interest_metrics._year, filter = '2018').where(element = interest_metrics._month, filter = '10').select(interest_metrics.interest_id, interest_metrics.composition, interest_metrics.index_value)\ndf5 = df4.select(interest_metrics.interest_id, (interest_metrics.composition * 1.0) / interest_metrics.index_value as avg_composition)\ndf6 = df5.orderby(by = avg_composition, desc).select(interest_metrics.interest_id, avg_composition).limit(1)\ndf7 = df.where(element = interest_metrics._year, filter = '2018').where(element = interest_metrics._month, filter = '11').select(interest_metrics.interest_id, interest_metrics.composition, interest_metrics.index_value)\ndf8 = df7.select(interest_metrics.interest_id, (interest_metrics.composition * 1.0) / interest_metrics.index_value as avg_composition)\ndf9 = df8.orderby(by = avg_composition, desc).select(interest_metrics.interest_id, avg_composition).limit(1)\ndf10 = df.where(element = interest_metrics._year, filter = '2018').where(element = interest_metrics._month, filter = '12').select(interest_metrics.interest_id, interest_metrics.composition, interest_metrics.index_value)\ndf11 = df10.select(interest_metrics.interest_id, (interest_metrics.composition * 1.0) / interest_metrics.index_value as avg_composition)\ndf12 = df11.orderby(by = avg_composition, desc).select(interest_metrics.interest_id, avg_composition).limit(1)\ndf13 = df.where(element = interest_metrics._year, filter = '2019').where(element = interest_metrics._month, filter = '01').select(interest_metrics.interest_id, interest_metrics.composition, interest_metrics.index_value)\ndf14 = df13.select(interest_metrics.interest_id, (interest_metrics.composition * 1.0) / interest_metrics.index_value as avg_composition)\ndf15 = df14.orderby(by = avg_composition, desc).select(interest_metrics.interest_id, avg_composition).limit(1)\ndf16 = df.where(element = interest_metrics._year, filter = '2019').where(element = interest_metrics._month, filter = '02').select(interest_metrics.interest_id, interest_metrics.composition, interest_metrics.index_value)\ndf17 = df16.select(interest_metrics.interest_id, (interest_metrics.composition * 1.0) / interest_metrics.index_value as avg_composition)\ndf18 = df17.orderby(by = avg_composition, desc).select(interest_metrics.interest_id, avg_composition).limit(1)\ndf19 = df.where(element = interest_metrics._year, filter = '2019').where(element = interest_metrics._month, filter = '03').select(interest_metrics.interest_id, interest_metrics.composition, interest_metrics.index_value)\ndf20 = df19.select(interest_metrics.interest_id, (interest_metrics.composition * 1.0) / interest_metrics.index_value as avg_composition)\ndf21 = df20.orderby(by = avg_composition, desc).select(interest_metrics.interest_id, avg_composition).limit(1)\ndf22 = df.select(interest_map.interest_name, df3.avg_composition, df15.avg_composition, df9.avg_composition, df6.avg_composition, df18.avg_composition, df12.avg_composition, df21.avg_composition)\ndf23 = df22.orderby(by = df22.month_start).select(df22.interest_name, df22.max_index_composition, df22.rolling_3_month_avg, df22.top_interest_1_month_ago, df22.top_interest_1_month_ago_max_index_composition, df22.top_interest_2_months_ago, df22.top_interest_2_months_ago_max_index_composition)\nres = df23\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [interest_metrics._year], filter = '2018').where(element = [interest_metrics._month], filter = '09').select([interest_metrics.interest_id, interest_metrics.composition, interest_metrics.index_value])\ndf2 = df1.select([interest_metrics.interest_id, (interest_metrics.composition * 1.0) / interest_metrics.index_value as avg_composition])\ndf3 = df2.orderby(by = avg_composition, desc).select([interest_metrics.interest_id, avg_composition]).limit(1)\ndf4 = df.where(element = [interest_metrics._year], filter = '2018').where(element = [interest_metrics._month], filter = '10').select([interest_metrics.interest_id, interest_metrics.composition, interest_metrics.index_value])\ndf5 = df4.select([interest_metrics.interest_id, (interest_metrics.composition * 1.0) / interest_metrics.index_value as avg_composition])\ndf6 = df5.orderby(by = avg_composition, desc).select([interest_metrics.interest_id, avg_composition]).limit(1)\ndf7 = df.where(element = [interest_metrics._year], filter = '2018').where(element = [interest_metrics._month], filter = '11').select([interest_metrics.interest_id, interest_metrics.composition, interest_metrics.index_value])\ndf8 = df7.select([interest_metrics.interest_id, (interest_metrics.composition * 1.0) / interest_metrics.index_value as avg_composition])\ndf9 = df.where(element = [interest_hours.opening_time], filter = 'Monday').select()\ndf10 = df.where(element = [interest_metrics._year], filter = '2018').where(element = [interest_metrics._month], filter = '12').select([interest_metrics.interest_id, interest_metrics.composition, interest_metrics.index_value])\ndf11 = df10.select([interest_metrics.interest_id, (interest_metrics.composition * 1.0) / interest_metrics.index_value as avg_composition])\ndf12 = df11.orderby(by = avg_composition, desc).select([interest_metrics.interest_id, avg_composition]).limit(1)\ndf13 = df.where(element = [interest_metrics._year], filter = '2019').where(element = [interest_metrics._month], filter = '01').select([interest_metrics.interest_id, interest_metrics.composition, interest_metrics.index_value])\ndf14 = df13.select([interest_metrics.interest_id, (interest_metrics.composition * 1.0) / interest_metrics.index_value as avg_composition])\ndf15 = df14.orderby(by = avg_composition, desc).select([interest_metrics.interest_id, avg_composition]).limit(1)\ndf16 = df.where(element = [interest_metrics._year], filter = '2019').where(element = [interest_metrics._month], filter = '02').select([interest_metrics.interest_id, interest_metrics.composition, interest_metrics.index_value])\ndf17 = df16.select([interest_metrics.interest_id, (interest_metrics.composition * 1.0) / interest_metrics.index_value as avg_composition])\ndf18 = df17.orderby(by = avg_composition, desc).select([interest_metrics.interest_id, avg_composition]).limit(1)\ndf19 = df.where(element = [interest_metrics._year], filter = '2019').where(element = [interest_metrics._month], filter = '03').select([interest_metrics.interest_id, interest_metrics.composition, interest_metrics.index_value])\ndf20 = df19.select([interest_metrics.interest_id, (interest_metrics.composition * 1.0) / interest_metrics.index_value as avg_composition])\ndf21 = df20.orderby(by = avg_composition, desc).select([interest_metrics.interest_id, avg_composition]).limit(1)\ndf22 = df.select([interest_map.interest_name, df3.avg_composition, df15.avg_composition, df9.avg_composition, df6.avg_composition, df18.avg_composition, df12.avg_composition, df21.avg_composition])\ndf23 = df22.orderby(by = df22.month_start).select([interest_map.interest_name, df22.max_index_composition, df22.rolling_3_month_avg, df22.top_interest_1_month_ago, df22.top_interest_1_month_ago_max_index_composition, df22.top_interest_2_months_ago, df22.top_interest_2_months_ago_max_index_composition])\nres = df23\n```"}
{"idx": 58, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = interest_metrics.composition, filter = 'is not null')\ndf2 = df1.orderby(by = [interest_metrics.composition, interest_metrics._year, interest_metrics._month], desc).limit(1)\ndf3 = df2.select(interest_metrics.interest_id, interest_metrics.month_year, interest_metrics.composition)\ndf4 = df3.orderby(by = interest_metrics.composition, desc).dense_rank()\ndf5 = df3.orderby(by = interest_metrics.composition, asc).dense_rank()\ndf6 = df.select(df4, df5).where(element = df4, filter = '<= 10').or(element = df5, filter = '<= 10')\nres = df6.orderby(by = df4, asc).orderby(by = interest_metrics.composition, desc).select(interest_map.interest_name, interest_metrics.month_year, interest_metrics.composition)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [interest_metrics.composition], filter = 'is not null')\ndf2 = df1.orderby(by = [interest_metrics.composition, interest_metrics._year, interest_metrics._month], desc).limit(1)\ndf3 = df2.select([interest_metrics.interest_id, interest_metrics.month_year, interest_metrics.composition])\ndf4 = df3.orderby(by = [interest_metrics.composition], desc).dense_rank()\ndf5 = df3.orderby(by = [interest_metrics.composition], asc).dense_rank()\ndf6 = df.select(df4, df5).where(element = df4, filter = '<= 10').or(element = df5, filter = '<= 10')\nres = df6.orderby(by = df4, asc).orderby(by = [interest_metrics.composition], desc).select([interest_map.interest_name, interest_metrics.month_year, interest_metrics.composition])\n```"}
{"idx": 59, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = orders.orderdate, filter = '>= 1998-01-01').where(element = orders.orderdate, filter = '< 1999-01-01')\ndf2 = df1.groupby(customers.customerid).agg(total_spent = sum(order_details.unitprice * order_details.quantity))\ndf3 = df2.where(element = total_spent, filter = '>= customergroupthreshold.rangebottom').where(element = total_spent, filter = '< customergroupthreshold.rangetop')\ndf4 = df2.count()\ndf5 = df3.groupby(customergroupthreshold.groupname).count(customers.customerid).orderby(by = customers_in_group, desc).orderby(by = customergroupthreshold.groupname)\nres = df5.select(customergroupthreshold.groupname, customers_in_group, round(100.0 * customers_in_group / df4, 2) as pct_of_customers_1998)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [orders.orderdate], filter = '>= 1998-01-01').where(element = [orders.orderdate], filter = '< 1999-01-01')\ndf2 = df1.groupby([customers.customerid]).agg(total_spent = sum([order_details.unitprice * order_details.quantity]))\ndf3 = df2.where(element = [total_spent], filter = '>= [customergroupthreshold.rangebottom]').where(element = [total_spent], filter = '< [customergroupthreshold.rangetop]')\ndf4 = df2.count()\ndf5 = df3.groupby([customergroupthreshold.groupname]).count([customers.customerid]).orderby(by = [customers_in_group], desc).orderby(by = [customergroupthreshold.groupname])\nres = df5.select([customergroupthreshold.groupname], [customers_in_group], round(100.0 * [customers_in_group] / [df4], 2) as [pct_of_customers_1998])\n```"}
{"idx": 60, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(orders.employeeid).select(orders.employeeid, count(orders.*), sum(case when orders.shippeddate is not null and orders.requireddate is not null and date(orders.shippeddate) >= date(orders.requireddate) then 1 else 0 end) as late_orders)\ndf2 = df1.where(element = count(orders.*), filter = '> 50')\ndf3 = df2.select(orders.employeeid, late_orders, (late_orders * 1.0 / count(orders.*)) as late_pct)\nres = df3.orderby(by = late_pct, desc).orderby(by = late_orders, desc).orderby(by = orders.employeeid).limit(3).select(orders.employeeid, late_orders, round(late_pct * 100.0, 2) as late_order_percentage)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.groupby([MASK]).select([MASK], count(*), sum(case when [MASK] is not null and [MASK] is not null and date([MASK]) >= date([MASK]) then 1 else 0 end) as late_orders)\ndf2 = df1.where(element = count(*), filter = '> 50')\ndf3 = df2.select([MASK], late_orders, (late_orders * 1.0 / count(*)) as late_pct)\nres = df3.orderby(by = late_pct, desc).orderby(by = late_orders, desc).orderby(by = [MASK]).limit(3).select([MASK], late_orders, round(late_pct * 100.0, 2) as late_order_percentage)\n```"}
{"idx": 61, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = Movie.year, filter = 'is not null').where(element = Movie.year, filter = 'length >= 4').where(element = Movie.year, filter = 'substr(year, -4) glob [0-9][0-9][0-9][0-9]')\ndf2 = df1.select(Movie.MID, cast(substr(Movie.year, -4) as int) as yr)\ndf3 = df2.join(M_Cast).join(Person).groupby(movie_cast_gender.yr, movie_cast_gender.MID).select(movie_cast_gender.yr, movie_cast_gender.MID, sum(case when Person.Gender = 'Female' then 1 else 0 end) as female_cnt, sum(case when Person.Gender in ('Male', 'None') or Person.Gender is null then 1 else 0 end) as non_female_cnt, count(Person.PID) as cast_cnt)\ndf4 = df3.select(movie_cast_gender.yr, count() as total_movies, sum(case when cast_cnt > 0 and non_female_cnt = 0 and female_cnt > 0 then 1 else 0 end) as exclusively_female_movies).groupby(movie_cast_gender.yr)\nres = df4.orderby(by = movie_cast_gender.yr).select(movie_cast_gender.yr, total_movies, round(100.0 * exclusively_female_movies / nullif(total_movies, 0), 2) as pct_exclusively_female)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [MASK], filter = 'is not null').where(element = [MASK], filter = 'length >= 4').where(element = [MASK], filter = 'substr([MASK], -4) glob [0-9][0-9][0-9][0-9]')\ndf2 = df1.select([MASK], cast(substr([MASK], -4) as int) as [MASK])\ndf3 = df2.join([MASK]).join([MASK]).groupby([MASK], [MASK]).select([MASK], [MASK], [MASK], sum(case when [MASK].Gender = 'Female' then 1 else 0 end) as [MASK], sum(case when [MASK].Gender in ('Male', 'None') or [MASK].Gender is null then 1 else 0 end) as [MASK], count([MASK].PID) as [MASK])\ndf4 = df3.select([MASK], count() as [MASK], sum(case when [MASK] > 0 and [MASK] = 0 and [MASK] > 0 then 1 else 0 end) as [MASK]).groupby([MASK])\nres = df4.orderby(by = [MASK]).select([MASK], [MASK], round(100.0 * [MASK] / nullif([MASK], 0), 2) as [MASK])\n```"}
{"idx": 62, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = Movie.year, filter = 'is not null').where(element = Movie.year, filter = \"!= '').cast(Movie.year, integer).distinct()\ndf2 = df.where(element = Movie.year, filter = 'between df1 and (df1 + 9)').count().orderby(by = count, desc).orderby(by = Movie.year, asc).limit(1)\nres = df2.select(Movie.year, count)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [Movie.year], filter = 'is not null').where(element = [Movie.year], filter = \"!= '').cast([Movie.year], integer).distinct()\ndf2 = df.where(element = [Movie.year], filter = 'between df1 and (df1 + 9)').count().orderby(by = count, desc).orderby(by = [Movie.year], asc).limit(1)\nres = df2.select([Movie.year], count)\n```"}
{"idx": 63, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = Movie.year, filter = 'is not null').where(element = Movie.year, filter = '!= \"\"').where(element = Movie.year, filter = 'is not null')\ndf2 = df1.groupby(M_Cast.PID, Movie.year).select(M_Cast.PID, Movie.year)\ndf3 = df2.groupby(M_Cast.PID).select(min(Movie.year) as first_year, max(Movie.year) as last_year)\ndf4 = df2.select(Movie.year, lead(Movie.year, partition by M_Cast.PID, order by Movie.year) as next_year)\ndf5 = df4.where(element = next_year, filter = 'is not null').where(element = subtract(next_year, Movie.year), filter = '>= 4')\nres = df3.where(element = M_Cast.PID, filter = 'not in', df5).count()\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [Movie.year], filter = 'is not null').where(element = [Movie.year], filter = '!= \"\"').where(element = [Movie.year], filter = 'is not null')\ndf2 = df1.groupby([M_Cast.PID], [Movie.year]).select([M_Cast.PID], [Movie.year])\ndf3 = df2.groupby([M_Cast.PID]).select(min([Movie.year]) as first_year, max([Movie.year]) as last_year)\ndf4 = df2.select([Movie.year], lead([Movie.year], partition by [M_Cast.PID], order by [Movie.year]) as next_year)\ndf5 = df4.where(element = [next_year], filter = 'is not null').where(element = subtract([next_year], [Movie.year]), filter = '>= 4')\nres = df3.where(element = [M_Cast.PID], filter = 'not in', df5).count()\n```"}
{"idx": 64, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(M_Cast.PID, M_Director.PID).count(distinct M_Cast.MID)\ndf2 = df.where(element = Person.Name, filter = 'Yash Chopra')\ndf3 = df.select(M_Cast.PID).where(element = M_Director.PID, filter = df2.PID)\ndf4 = df.groupby(M_Cast.PID).agg(max(df1))\ndf5 = df.select(M_Cast.PID).where(element = df1, filter = df4.max)\ndf6 = df.where(element = M_Cast.PID, filter = df5.PID).count(distinct M_Director.PID)\nres = df6.count()\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.groupby([MASK], [MASK]).count(distinct [MASK])\ndf2 = df.where(element = [MASK], filter = 'Yash Chopra')\ndf3 = df.select([MASK]).where(element = [MASK], filter = df2.[MASK])\ndf4 = df.groupby([MASK]).agg(max(df1))\ndf5 = df.select([MASK]).where(element = df1, filter = df4.max)\ndf6 = df.where(element = [MASK], filter = df5.[MASK]).count(distinct [MASK])\nres = df6.count()\n```"}
{"idx": 65, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = Person.Name, filter = 'Shahrukh Khan', 'Shah Rukh Khan', 'Shahrukh Kahn', 'Shah Rukh Kahn')\ntmp_res1 = df1.select(M_Cast.MID).distinct()\n\ndf2 = df.where(element = M_Cast.MID, filter = 'in', value = tmp_res1)\ntmp_res2 = df2.where(element = M_Cast.PID, filter = 'not in', value = df1.select(Person.PID)).select(M_Cast.PID).distinct()\n\ndf3 = df.where(element = M_Cast.MID, filter = 'in', value = tmp_res1)\ntmp_res3 = df3.select(M_Cast.PID).distinct()\n\ndf4 = df.where(element = M_Cast.MID, filter = 'in', value = tmp_res3)\ntmp_res4 = df4.where(element = M_Cast.PID, filter = 'not in', value = df1.select(Person.PID)).select(M_Cast.PID).distinct()\n\nres = df.select(count(distinct = tmp_res4))\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [Person.Name], filter = 'Shahrukh Khan', 'Shah Rukh Khan', 'Shahrukh Kahn', 'Shah Rukh Kahn')\ntmp_res1 = df1.select([M_Cast.MID]).distinct()\n\ndf2 = df.where(element = [M_Cast.MID], filter = 'in', value = tmp_res1)\ntmp_res2 = df2.where(element = [M_Cast.PID], filter = 'not in', value = df1.select([Person.PID])).select([M_Cast.PID]).distinct()\n\ndf3 = df.where(element = [M_Cast.MID], filter = 'in', value = tmp_res1)\ntmp_res3 = df3.select([M_Cast.PID]).distinct()\n\ndf4 = df.where(element = [M_Cast.MID], filter = 'in', value = tmp_res3)\ntmp_res4 = df4.where(element = [M_Cast.PID], filter = 'not in', value = df1.select([Person.PID])).select([M_Cast.PID]).distinct()\n\nres = df.select(count(distinct = tmp_res4))\n```"}
{"idx": 66, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(web_region.id, web_region.name).agg(total_sales_amt = sum(web_orders.total_amt_usd), num_orders = count(web_orders.id))\ndf2 = df.groupby(web_region.id).agg(max_rep_sales_amt = max(region_rep_sales.rep_total_sales_amt))\ndf3 = df1.join(df2, on = web_region.id)\ndf4 = df1.join(df2, on = web_region.id).where(element = region_rep_sales.rep_total_sales_amt, filter = max_rep_sales_amt)\nres = df4.orderby(by = [web_region.name, region_rep_sales.sales_rep_name])\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.groupby([MASK], [MASK]).agg(total_sales_amt = sum([MASK]), num_orders = count([MASK]))\ndf2 = df.groupby([MASK]).agg(max_rep_sales_amt = max([MASK]))\ndf3 = df1.join(df2, on = [MASK])\ndf4 = df1.join(df2, on = [MASK]).where(element = [MASK], filter = max_rep_sales_amt)\nres = df4.orderby(by = [MASK, [MASK]])\n```"}
{"idx": 67, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\n\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [Business_Hours].business_id, filter = 12)\ndf2 = df1.where(element = [Days].day_of_week, filter = 'Monday')\nres = df2.select([Business_Hours].opening_time)\n```"}
{"idx": 68, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = Student_Schedules.ClassStatus, filter = 2)\ndf2 = df1.where(element = Subjects.SubjectName, filter = 'like %English%')\ndf3 = df2.select(Student_Schedules.Grade).count()\ndf4 = df2.select(Student_Schedules.Grade).quantile([0.2, 0.4, 0.6, 0.8])\ndf5 = df2.select(Student_Schedules.StudentID, Students.StudLastName, Student_Schedules.Grade, count() as ge_rank, df3 as total_completed)\ndf6 = df5.orderby(by = ge_rank, desc).orderby(by = Student_Schedules.Grade, desc)\nres = df6.select(Students.StudLastName, case(element = ge_rank / total_completed, when <= 0.2, 'First', when <= 0.4, 'Second', when <= 0.6, 'Third', when <= 0.8, 'Fourth', else 'Fifth'))\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [MASK], filter = 2)\ndf2 = df1.where(element = [MASK], filter = 'like %English%')\ndf3 = df2.select([MASK]).count()\ndf4 = df2.select([MASK]).quantile([0.2, 0.4, 0.6, 0.8])\ndf5 = df2.select([MASK.StudentID], [MASK.StudLastName], [MASK.Grade], count() as ge_rank, df3 as total_completed)\ndf6 = df5.orderby(by = ge_rank, desc).orderby(by = [MASK.Grade], desc)\nres = df6.select([MASK.StudLastName], case(element = ge_rank / total_completed, when <= 0.2, 'First', when <= 0.4, 'Second', when <= 0.6, 'Third', when <= 0.8, 'Fourth', else 'Fifth'))\n```"}
{"idx": 69, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = Musical_Preferences.PreferenceSeq, filter = 1)\ntmp_res1 = df1.select(Musical_Styles.StyleID, Musical_Styles.StyleName).count()\n\ndf2 = df.where(element = Musical_Preferences.PreferenceSeq, filter = 2)\ntmp_res2 = df2.select(Musical_Styles.StyleID, Musical_Styles.StyleName).count()\n\ndf3 = df.where(element = Musical_Preferences.PreferenceSeq, filter = 3)\ntmp_res3 = df3.select(Musical_Styles.StyleID, Musical_Styles.StyleName).count()\n\nres = df.select(Musical_Styles.StyleID, Musical_Styles.StyleName, tmp_res1, tmp_res2, tmp_res3)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = 1)\ntmp_res1 = df1.select([MASK], [MASK]).count()\n\ndf2 = df.where(element = [MASK], filter = 2)\ntmp_res2 = df2.select([MASK], [MASK]).count()\n\ndf3 = df.where(element = [MASK], filter = 3)\ntmp_res3 = df3.select([MASK], [MASK]).count()\n\nres = df.select([MASK], [MASK], tmp_res1, tmp_res2, tmp_res3)\n```"}
{"idx": 70, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = Musical_Preferences.PreferenceSeq, filter = 'IN', values = [1, 2, 3])\ndf2 = df1.groupby(Musical_Styles.StyleID, Musical_Styles.StyleName).agg({'Musical_Preferences.PreferenceSeq': 'sum_weighted', weights = [3, 2, 1]})\ndf3 = df2.select(Musical_Styles.StyleID, Musical_Styles.StyleName, sum_weighted(Musical_Preferences.PreferenceSeq), avg(sum_weighted(Musical_Preferences.PreferenceSeq)) as avg_score)\ndf4 = df3.orderby(by = [sum_weighted(Musical_Preferences.PreferenceSeq), Musical_Styles.StyleName], desc)\nres = df4.select(Musical_Styles.StyleID, Musical_Styles.StyleName, sum_weighted(Musical_Preferences.PreferenceSeq), avg_score, abs(sum_weighted(Musical_Preferences.PreferenceSeq) - avg_score))\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [Musical_Preferences.PreferenceSeq], filter = 'IN', values = [1, 2, 3])\ndf2 = df1.groupby([Musical_Styles.StyleID, Musical_Styles.StyleName]).agg({[Musical_Preferences.PreferenceSeq]: 'sum_weighted'}, weights = [3, 2, 1])\ndf3 = df2.select([Musical_Styles.StyleID, Musical_Styles.StyleName], sum_weighted([Musical_Preferences.PreferenceSeq]), avg(sum_weighted([Musical_Preferences.PreferenceSeq])) as avg_score)\ndf4 = df3.orderby(by = [sum_weighted([Musical_Preferences.PreferenceSeq]), [Musical_Styles.StyleName]], desc)\nres = df4.select([Musical_Styles.StyleID, Musical_Styles.StyleName], sum_weighted([Musical_Preferences.PreferenceSeq]), avg_score, abs(sum_weighted([Musical_Preferences.PreferenceSeq]) - avg_score))\n```"}
{"idx": 71, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.orderby(by = Entertainer_Styles.StyleStrength, desc).limit(3)\ndf2 = df.orderby(by = Musical_Preferences.PreferenceSeq).limit(3)\n\ndf3 = df1.groupby(Entertainers.EntertainerID).select(Entertainers.EntStageName, Entertainer_Styles.StyleID as ent_style1, Entertainer_Styles.StyleID as ent_style2)\ndf4 = df2.groupby(Customers.CustomerID).select(Customers.CustLastName, Musical_Preferences.StyleID as cust_style1, Musical_Preferences.StyleID as cust_style2)\n\nres = df3.intersect(df4).where(element = Entertainers.EntertainerID, filter = 'exists in Customers.CustomerID').where(element = Customers.CustomerID, filter = 'exists in Entertainers.EntertainerID').where(element = Entertainers.EntertainerID, filter = 'ent_style1 = cust_style1 and ent_style2 = cust_style2').orwhere(element = Entertainers.EntertainerID, filter = 'ent_style1 = cust_style2 and ent_style2 = cust_style1')\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.orderby(by = [MASK], desc).limit(3)\ndf2 = df.orderby(by = [MASK]).limit(3)\n\ndf3 = df1.groupby([MASK]).select([MASK], [MASK] as [MASK], [MASK] as [MASK])\ndf4 = df2.groupby([MASK]).select([MASK], [MASK] as [MASK], [MASK] as [MASK])\n\nres = df3.intersect(df4).where(element = [MASK], filter = 'exists in [MASK]').where(element = [MASK], filter = 'exists in [MASK]').where(element = [MASK], filter = 'and [MASK] = [MASK] and [MASK] = [MASK]').orwhere(element = [MASK], filter = 'and [MASK] = [MASK] and [MASK] = [MASK]')\n```"}
{"idx": 72, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = salesorderheader.salespersonid, filter = 'is not null')\ndf2 = df1.groupby(salesorderheader.salespersonid, cast(salesorderheader.orderdate, '%Y')).agg(sum(salesorderheader.subtotal))\ndf3 = df.groupby(SalesPersonQuotaHistory.BusinessEntityID, cast(SalesPersonQuotaHistory.QuotaDate, '%Y')).agg(sum(SalesPersonQuotaHistory.SalesQuota))\nres = df.select(df2.on(salesorderheader.salespersonid, cast(salesorderheader.orderdate, '%Y')), df3.on(SalesPersonQuotaHistory.BusinessEntityID, cast(SalesPersonQuotaHistory.QuotaDate, '%Y'))).orderby(by = [SalesPersonQuotaHistory.BusinessEntityID, cast(SalesPersonQuotaHistory.QuotaDate, '%Y')])\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = 'is not null')\ndf2 = df1.groupby([MASK], cast([MASK], '%Y')).agg(sum([MASK]))\ndf3 = df.groupby([MASK], cast([MASK], '%Y')).agg(sum([MASK]))\nres = df.select(df2, df3).orderby(by = [MASK], [MASK])\n```"}
{"idx": 73, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.orderby(by = director_movies.date_published).groupby(director_mapping.name_id).agg(count(director_movies.movie_id), sum(director_movies.duration), avg(director_movies.avg_rating), sum(director_movies.total_votes))\ndf2 = df1.select(director_mapping.name_id, names.name, count(director_movies.movie_id), round(avg(julianday(director_movies.date_published) - lag(director_movies.date_published, director_mapping.name_id)), 2), round(avg(director_movies.avg_rating), 2), sum(coalesce(director_movies.total_votes, 0)), min(director_movies.avg_rating), max(director_movies.avg_rating), sum(coalesce(director_movies.duration, 0)))\nres = df2.orderby(by = [count(director_movies.movie_id), sum(director_movies.duration)], desc).limit(9)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.orderby(by = [MASK]).groupby([MASK]).agg(count([MASK]), sum([MASK]), avg([MASK]), sum([MASK]))\ndf2 = df1.select([MASK], [MASK], count([MASK]), round(avg([MASK]), 2), sum(coalesce([MASK], 0)), min([MASK]), max([MASK]), sum(coalesce([MASK], 0)))\nres = df2.orderby(by = [count([MASK]), sum([MASK])], desc).limit(9)\n```"}
{"idx": 74, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = ratings.avg_rating, filter = '> 8')\ndf2 = df1.groupby(genre.genre).count(distinct = genre.movie_id).orderby(by = count, desc).limit(3)\ndf3 = df1.groupby(director_mapping.name_id).count(distinct = director_mapping.movie_id)\ndf4 = df3.orderby(by = count, desc).orderby(by = director_mapping.name, asc).limit(4)\nres = df4.select(director_mapping.name, count)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [ratings.avg_rating], filter = '> 8')\ndf2 = df1.groupby([genre.genre]).count(distinct = [genre.movie_id]).orderby(by = count, desc).limit(3)\ndf3 = df1.groupby([director_mapping.name_id]).count(distinct = [director_mapping.movie_id])\ndf4 = df3.orderby(by = count, desc).orderby(by = [director_mapping.name], asc).limit(4)\nres = df4.select([director_mapping.name], count)\n```"}
{"idx": 75, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = bitcoin_transactions.txn_type, filter = 'BUY')\ndf2 = df1.groupby(bitcoin_members.region, cast(bitcoin_transactions.txn_date, 'integer')).agg(total_qty_bought = sum(bitcoin_transactions.quantity), total_usd_spent = sum(bitcoin_transactions.quantity * bitcoin_prices.price))\ndf3 = df2.select(bitcoin_members.region, cast(bitcoin_transactions.txn_date, 'integer') as yr, total_qty_bought, total_usd_spent, divide(total_usd_spent, total_qty_bought) as avg_purchase_price)\ndf4 = df3.groupby(bitcoin_members.region).agg(min(yr) as first_yr)\ndf5 = df3.where(element = bitcoin_members.region, filter = 'not in', value = df4.select(first_yr))\ndf6 = df5.groupby(bitcoin_members.region, cast(bitcoin_transactions.txn_date, 'integer')).rank(divide(total_usd_spent, total_qty_bought), desc)\ndf7 = df5.select(bitcoin_members.region, cast(bitcoin_transactions.txn_date, 'integer') as year, divide(total_usd_spent, total_qty_bought) as avg_purchase_price, region_rank_in_year, lag(divide(total_usd_spent, total_qty_bought)) over (partition by bitcoin_members.region, cast(bitcoin_transactions.txn_date, 'integer')) as prev_year_avg_purchase_price)\nres = df7.orderby(by = [year, region_rank_in_year, bitcoin_members.region]).select(bitcoin_members.region, year, avg_purchase_price, region_rank_in_year, ifnull(100 * (avg_purchase_price - lag(divide(total_usd_spent, total_qty_bought)) over (partition by bitcoin_members.region), 0) / lag(divide(total_usd_spent, total_qty_bought)) over (partition by bitcoin_members.region), null) as pct_change_vs_prev_year)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [bitcoin_transactions.txn_type], filter = 'BUY')\ndf2 = df1.groupby([bitcoin_members.region], cast([bitcoin_transactions.txn_date], 'integer')).agg(total_qty_bought = sum([bitcoin_transactions.quantity]), total_usd_spent = sum([bitcoin_transactions.quantity] * [bitcoin_prices.price]))\ndf3 = df2.select([bitcoin_members.region], cast([bitcoin_transactions.txn_date], 'integer') as [yr], total_qty_bought, total_usd_spent, divide(total_usd_spent, total_qty_bought) as [avg_purchase_price])\ndf4 = df3.groupby([bitcoin_members.region]).agg(min([yr]) as [first_yr])\ndf5 = df3.where(element = [bitcoin_members.region], filter = 'not in', value = df4.select([first_yr]))\ndf6 = df5.groupby([bitcoin_members.region], cast([bitcoin_transactions.txn_date], 'integer')).rank(divide(total_usd_spent, total_qty_bought), desc)\ndf7 = df5.select([bitcoin_members.region], cast([bitcoin_transactions.txn_date], 'integer') as [year], divide(total_usd_spent, total_qty_bought) as [avg_purchase_price], region_rank_in_year, lag(divide(total_usd_spent, total_qty_bought)) over (partition by [bitcoin_members.region], cast([bitcoin_transactions.txn_date], 'integer')) as [prev_year_avg_purchase_price])\nres = df7.orderby(by = [year, region, region_rank], cast([region, region, region, region, filter = 'Monday')\n```"}
{"idx": 76, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = bitcoin_prices.market_date, filter = '>= 2021-08-01').where(element = bitcoin_prices.market_date, filter = '<= 2021-08-10')\ndf2 = df1.where(element = bitcoin_prices.volume, filter = '!= 0')\ndf3 = df2.orderby(by = bitcoin_prices.market_date, desc).limit(1)\ndf4 = df1.select(bitcoin_prices.ticker, bitcoin_prices.market_date, cast(bitcoin_prices.volume as real) as volume, df3.bitcoin_prices.volume as prev_volume)\nres = df4.select(bitcoin_prices.ticker, bitcoin_prices.market_date, volume, prev_volume, round((volume - prev_volume) * 100.0 / prev_volume, 6) as daily_volume_pct_change).orderby(by = bitcoin_prices.ticker, bitcoin_prices.market_date)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = '>= 2021-08-01').where(element = [MASK], filter = '<= 2021-08-10')\ndf2 = df1.where(element = [MASK], filter = '!= 0')\ndf3 = df2.orderby(by = [MASK], desc).limit(1)\ndf4 = df1.select([MASK], [MASK], cast([MASK] as real) as [MASK], df3.[MASK] as [MASK])\nres = df4.select([MASK], [MASK], [MASK], [MASK], round((([MASK] - df3.[MASK]) * 100.0 / df3.[MASK]), 6) as [MASK]).orderby(by = [MASK], [MASK])\n```"}
{"idx": 77, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = university_faculty.FacRank, filter = 'is not null').where(element = university_faculty.FacSalary, filter = 'is not null')\navg_salary = df1.groupby(university_faculty.FacRank).agg(avg(university_faculty.FacSalary))\ndf2 = df.where(element = university_faculty.FacRank, filter = 'in', value = avg_salary.select(university_faculty.FacRank))\ndf3 = df2.select(university_faculty.FacRank, university_faculty.FacFirstName, university_faculty.FacLastName, university_faculty.FacSalary, abs(university_faculty.FacSalary - avg_salary.avg(university_faculty.FacSalary)) as diff_to_avg)\nmin_diff = df3.groupby(university_faculty.FacRank).agg(min(abs(university_faculty.FacSalary - avg_salary.avg(university_faculty.FacSalary))))\nres = df3.where(element = university_faculty.FacRank, filter = 'in', value = min_diff.select(university_faculty.FacRank)).where(element = diff_to_avg, filter = '=', value = min_diff.min(abs(university_faculty.FacSalary - avg_salary.avg(university_faculty.FacSalary))).select(min(abs(university_faculty.FacSalary - avg_salary.avg(university_faculty.FacSalary)))).orderby(by = university_faculty.FacRank, university_faculty.FacLastName, university_faculty.FacFirstName)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [MASK].FacRank, filter = 'is not null').where(element = [MASK].FacSalary, filter = 'is not null')\navg_salary = df1.groupby([MASK].FacRank).agg(avg([MASK].FacSalary))\ndf2 = df.where(element = [MASK].FacRank, filter = 'in', value = avg_salary.select([MASK].FacRank))\ndf3 = df2.select([MASK].FacRank, [MASK].FacFirstName, [MASK].FacLastName, [MASK].FacSalary, abs([MASK].FacSalary - avg_salary.avg([MASK].FacSalary)) as diff_to_avg)\nmin_diff = df3.groupby([MASK].FacRank).agg(min(abs([MASK].FacSalary - avg_salary.avg([MASK].FacSalary))))\nres = df3.where(element = [MASK].FacRank, filter = 'in', value = min_diff.select([MASK].FacRank)).where(element = diff_to_avg, filter = '=', value = min_diff.min(abs([MASK].FacSalary - avg_salary.avg([MASK].FacSalary))).select(min(abs([MASK].FacSalary - avg_salary.avg([MASK].FacSalary)))).orderby(by = [MASK].FacRank, [MASK].FacLastName, [MASK].FacFirstName)\n```"}
{"idx": 78, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = job_postings_fact.job_title_short, filter = 'Data Analyst')\ndf2 = df1.where(element = job_postings_fact.job_work_from_home, filter = 1)\ndf3 = df2.where(element = job_postings_fact.salary_year_avg, filter = 'is not null')\ndf4 = df3.groupby(skills_job_dim.skill_id).count()\ndf5 = df4.orderby(by = count, desc, skills_job_dim.skill_id).limit(3)\ndf6 = df1.join(df5, on = skills_job_dim.skill_id)\ndf7 = df6.select(job_postings_fact.job_id, job_postings_fact.salary_year_avg).distinct()\nres = df7.avg(job_postings_fact.salary_year_avg)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [job_postings_fact.job_title_short], filter = 'Data Analyst')\ndf2 = df1.where(element = [job_postings_fact.work_from_home], filter = 1)\ndf3 = df2.where(element = [job_postings_fact.salary_year_avg], filter = 'is not null')\ndf4 = df3.groupby([skills_job_dim.skill_id]).count()\ndf5 = df4.orderby(by = [count], desc, [skills_job_dim.skill_id]).limit(3)\ndf6 = df1.join(df5, on = [skills_job_dim.skill_id])\ndf7 = df6.select([job_postings_fact.job_id, job_postings_fact.salary_year_avg]).distinct()\nres = df7.avg([job_postings_fact.salary_year_avg])\n```"}
{"idx": 79, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(legislators.id_bioguide).having(element = min(legislators_terms.term_start), filter = 'between 1917-01-01 and 1999-12-31')\ndf2 = df.select(count())\ndf3 = df.where(element = legislators_terms.term_start, filter = 'between 1917-01-01 and 1999-12-31').select(periods = range(1, 20))\ndf4 = df.select(legislators.id_bioguide, legislators_terms.term_start, legislators_terms.term_end).where(element = legislators_terms.term_start, filter = 'between 1917-01-01 and 1999-12-31')\ndf5 = df3.cross_join(df1).cross_join(df2)\ndf6 = df.select(year_number, legislators.id_bioguide, date_add(first_start, years = year_number, days = -1), exists(legislators_terms, filter = 'where id_bioguide = legislators.id_bioguide and term_start <= date_add(first_start, years = year_number, days = -1) and coalesce(term_end, 9999-12-31) >= date_add(first_start, years = year_number, days = -1)'))\nres = df5.groupby(year_number).select(year_number, date_add('1917-01-01', years = year_number, days = -1), sum(case when df6.is_retained then 1 else 0 end), df2.n_cohort, round(1.0 * sum(case when df6.is_retained then 1 else 0 end) / df2.n_cohort, 6))\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.groupby([MASK]).having(element = min([MASK]), filter = 'between 1917-01-01 and 1999-12-31')\ndf2 = df.select([MASK])\ndf3 = df.where(element = [MASK], filter = 'between 1917-01-01 and 1999-12-31').select(periods = range(1, 20))\ndf4 = df.select([MASK], [MASK], [MASK]).where(element = [MASK], filter = 'between 1917-01-01 and 1999-12-31')\ndf5 = df3.cross_join(df1).cross_join(df2)\ndf6 = df.select([MASK], [MASK], date_add([MASK], years = [MASK], days = -1), exists([MASK], filter = 'where [MASK] = [MASK] and [MASK] <= date_add([MASK], years = [MASK], days = -1) and coalesce([MASK], 9999-12-31) >= date_add([MASK], years = [MASK], days = -1)'))\nres = df5.groupby([MASK]).select([MASK], date_add('1917-01-01', years = [MASK], days = -1), sum(case when df6.is_retained then 1 else 0 end), df2.[MASK], round(1.0 * sum(case when df6.is_retained then 1 else 0 end) / df2.[MASK], 6))\n```"}
{"idx": 80, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = legislators.gender, filter = 'M')\ndf2 = df.where(element = legislators_terms.state, filter = 'LA').where(element = legislators_terms.id_bioguide, filter = 'in', value = df1.select(legislators.id_bioguide))\ndf3 = df2.groupby(legislators_terms.id_bioguide).select(legislators_terms.id_bioguide, min(legislators_terms.term_start) as first_term_start)\ndf4 = df.where(element = legislation_date_dim.date, filter = 'between', value = df2.select(legislators_terms.term_start), and = 'and', value = df2.select(legislators_terms.term_end)).where(element = legislation_date_dim.date, filter = 'like', value = '%-12-31').select(legislators_terms.id_bioguide)\ndf5 = df4.groupby(legislators_terms.id_bioguide).select(legislators_terms.id_bioguide)\ndf6 = df.select((cast(substr(legislation_date_dim.date, 1, 4), as = 'integer') - cast(substr(df3.select(first_term_start, 1, 4), as = 'integer')), legislators_terms.id_bioguide).where(element = legislators_terms.id_bioguide, filter = 'in', value = df5.select(legislators_terms.id_bioguide)).where(element = subtract, filter = 'between', value = 30, and = 'and', value = 50)\nres = df6.groupby(subtract).count(legislators_terms.id_bioguide).orderby(by = subtract)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [MASK], filter = 'M')\ndf2 = df.where(element = [MASK], filter = 'LA').where(element = [MASK], filter = 'in', value = df1.select([MASK]))\ndf3 = df2.groupby([MASK]).select([MASK], min([MASK]) as first_term_start)\ndf4 = df.where(element = [MASK], filter = 'between', value = df2.select([MASK]), and = 'and', value = df2.select([MASK])).where(element = [MASK], filter = 'like', value = '%-12-31').select([MASK])\ndf5 = df4.groupby([MASK]).select([MASK])\ndf6 = df.select((cast(substr([MASK], 1, 4), as = 'integer') - cast(substr(df3.select(first_term_start, 1, 4), as = 'integer')), [MASK]).where(element = [MASK], filter = 'in', value = df5.select([MASK])).where(element = subtract, filter = 'between', value = 30, and = 'and', value = 50)\nres = df6.groupby(subtract).count([MASK]).orderby(by = subtract)\n```"}
{"idx": 81, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = legislators.gender, filter = 'F')\ndf2 = df1.orderby(by = legislators_terms.term_start, asc).select(legislators_terms.id_bioguide, legislators_terms.state)\ndf3 = df.where(element = legislators_terms.id_bioguide, filter = df2.select(legislators_terms.id_bioguide)).where(element = date(legislators_terms.term_start), filter = '<=', date(strftime('%Y', legislators_terms.term_end) || '-12-31')).where(element = date(legislators_terms.term_end), filter = '>=', date(strftime('%Y', legislators_terms.term_start) || '-12-31')).select(legislators_terms.id_bioguide).distinct()\ndf4 = df.where(element = legislators_terms.id_bioguide, filter = df3).groupby(legislators_terms.state).count().orderby(by = count, desc).orderby(by = legislators_terms.state).limit(1)\nres = df4.select(legislators_terms.state)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [MASK], filter = 'F')\ndf2 = df1.orderby(by = [MASK], asc).select([MASK], [MASK])\ndf3 = df.where(element = [MASK], filter = '<=', date(strftime('%Y', [MASK]) || '-12-31')).where(element = [MASK], filter = '>=', date(strftime('%Y', [MASK]) || '-12-31')).select([MASK]).distinct()\ndf4 = df.where(element = [MASK], filter = df3).groupby([MASK]).count().orderby(by = count, desc).orderby(by = [MASK]).limit(1)\nres = df4.select([MASK])\n```"}
{"idx": 82, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = legislators.gender, filter = 'M').or(element = legislators.gender, filter = 'F')\ndf2 = df1.where(element = legislators_terms.state, filter = 'is not null').where(element = legislators_terms.term_start, filter = 'is not null')\ndf3 = df2.groupby(legislators.id_bioguide, legislators.gender, legislators_terms.state).agg(min(legislators_terms.term_start) as first_start)\ndf4 = df.select(0, 2, 4, 6, 8, 10)\ndf5 = df3.cross_join(df4).select(legislators.id_bioguide, legislators.gender, legislators_terms.state, df4.yrs, date(add_years(df3.first_start, df4.yrs), format = '%Y-12-31') as asof_date)\ndf6 = df5.groupby(legislators.id_bioguide, legislators.gender, legislators_terms.state, df4.yrs).agg(count() as cohort_size, sum(if(exists(df.select(legislators_terms.id_bioguide).where(element = legislators_terms.id_bioguide, filter = df5.id_bioguide).where(element = legislators_terms.term_start, filter = '<= df5.asof_date).where(element = coalesce(legislators_terms.term_end, '9999-12-31'), filter = '>= df5.asof_date')), 1, 0)) as retained_cnt)\ndf7 = df6.groupby(legislators_terms.state).having(element = count(distinct(case(when(legislators.gender, 'M,F'), then(legislators.gender + ':' + df4.yrs, null))), filter = '= 12').and(element = min(retained_cnt), filter = '> 0'))\nres = df7.orderby(by = legislators_terms.state)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = 'M').or(element = [MASK], filter = 'F')\ndf2 = df1.where(element = [MASK], filter = 'is not null').where(element = [MASK], filter = 'is not null')\ndf3 = df2.groupby([MASK], [MASK], [MASK]).agg(min([MASK]) as first_start)\ndf4 = df.select([MASK], [MASK], [MASK], [MASK], [MASK], [MASK])\ndf5 = df3.cross_join(df4).select([MASK], [MASK], [MASK], [MASK], date(add_years([MASK], [MASK]), format = '%Y-12-31') as asof_date)\ndf6 = df5.groupby([MASK], [MASK], [MASK], [MASK]).agg(count() as cohort_size, sum(if(exists(df.select([MASK]).where(element = [MASK], filter = [MASK]).where(element = [MASK], filter = '<= [MASK]).where(element = coalesce([MASK], '9999-12-31'), filter = '>= [MASK]'), 1, 0)) as retained_cnt)\ndf7 = df6.groupby([MASK]).having(element = count(distinct(case(when([MASK], [MASK] + ':' + [MASK], null))), filter = '= 12').and(element = min([MASK]), filter = '> 0'))\nres = df7.orderby(by = [MASK])\n```"}
{"idx": 83, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(customer_payments.customer_id).agg(min(payment_ts) as first_ts)\ndf2 = df.where(element = customer_payments.payment_ts, filter = '>= first_ts').where(element = customer_payments.payment_ts, filter = '< datetime(first_ts, +7 days)')\ntmp_res1 = df2.select(customer_payments.customer_id, sum(customer_payments.amount) as ltv_7d)\n\ndf3 = df.where(element = customer_payments.payment_ts, filter = '>= first_ts').where(element = customer_payments.payment_ts, filter = '< datetime(first_ts, +30 days)')\ntmp_res2 = df3.select(customer_payments.customer_id, sum(customer_payments.amount) as ltv_30d)\n\ndf4 = df.where(element = customer_ltv.ltv_total, filter = '> 0')\nres = df4.select(avg(customer_ltv.ltv_total) as avg_ltv_total, avg(100.0 * tmp_res1.sum() / customer_ltv.ltv_total) as avg_pct_ltv_in_first_7_days, avg(100.0 * tmp_res2.sum() / customer_ltv.ltv_total) as avg_pct_ltv_in_first_30_days)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.groupby([MASK]).agg(min([MASK]) as first_ts)\ndf2 = df.where(element = [MASK], filter = '>= first_ts').where(element = [MASK], filter = '< datetime(first_ts, +7 days)')\ntmp_res1 = df2.select([MASK], sum([MASK]) as ltv_7d)\n\ndf3 = df.where(element = [MASK], filter = '>= first_ts').where(element = [MASK], filter = '< datetime(first_ts, +30 days)')\ntmp_res2 = df3.select([MASK], sum([MASK]) as ltv_30d)\n\ndf4 = df.where(element = [MASK], filter = '> 0')\nres = df4.select(avg([MASK]) as avg_ltv_total, avg(100.0 * tmp_res1.sum() / [MASK]) as avg_pct_ltv_in_first_7_days, avg(100.0 * tmp_res2.sum() / [MASK]) as avg_pct_ltv_in_first_30_days)\n```"}
{"idx": 84, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(film.film_id).agg(sum(payment.amount) as total_revenue)\ndf2 = df.groupby(film_actor.film_id).count()\ndf3 = df.select(film_actor.actor_id, film_actor.film_id, film.title, coalesce(df1.total_revenue, 0.0) as film_total_revenue, coalesce(df1.total_revenue, 0.0) * 1.0 / df2.count() as actor_share_revenue)\ndf4 = df3.orderby(by = actor_share_revenue desc, film_total_revenue desc, film.title).limit(3)\ndf5 = df.select(actor.actor_id, actor.first_name, actor.last_name, df4.film_id, film.title, df4.film_total_revenue, df4.actor_share_revenue, avg(df4.actor_share_revenue) over (partition by df4.actor_id))\nres = df5.orderby(by = actor.last_name, actor.first_name, df4.actor_share_revenue desc, film.title)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.groupby([MASK]).agg(sum([MASK]) as total_revenue)\ndf2 = df.groupby([MASK]).count()\ndf3 = df.select([MASK], [MASK], [MASK], coalesce(df1.total_revenue, 0.0) as film_total_revenue, coalesce(df1.total_revenue, 0.0) * 1.0 / df2.count() as actor_share_revenue)\ndf4 = df3.orderby(by = actor_share_revenue desc, film_total_revenue desc, [MASK]).limit(3)\ndf5 = df.select([MASK], [MASK], [MASK], df4.film_id, [MASK], df4.film_total_revenue, df4.actor_share_revenue, avg(df4.actor_share_revenue) over (partition by [MASK]))\nres = df5.orderby(by = [MASK], [MASK], actor_share_revenue desc, [MASK])\n```"}
{"idx": 85, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(film_actor.actor_id).count()\ndf2 = df1.orderby(by = count, desc).limit(5)\ndf3 = df.where(film_actor.actor_id, filter = 'in', value = df2.select(actor_id))\ndf4 = df.where(rental.customer_id, filter = 'in', value = df3.select(customer.customer_id))\nres = df.select(round((df4.count() / df.count(customer.customer_id, nullif = 0), 2) * 100))\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.groupby([MASK]).count()\ndf2 = df1.orderby(by = count, desc).limit(5)\ndf3 = df.where([MASK], filter = 'in', value = df2.select([MASK]))\ndf4 = df.where([MASK], filter = 'in', value = df3.select([MASK]))\nres = df.select(round((df4.count() / df.count([MASK], nullif = 0), 2) * 100))\n```"}
{"idx": 86, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.orderby(by = payment.payment_date, payment.payment_id).partition(by = customer.customer_id).select(payment.customer_id, payment.payment_date, rental.rental_id, row_number() as rn)\ndf2 = df1.where(element = rn, filter = 1).select(customer.customer_id, payment.payment_date as first_payment_date, inventory.inventory_id)\ndf3 = df2.select(first_rental.customer_id, film.rating)\ndf4 = df.groupby(customer.customer_id).select(customer.customer_id, coalesce(sum(payment.amount), 0.0) as total_spent, count(distinct(rental.rental_id)) as total_rentals)\nres = df3.groupby(film.rating).select(film.rating, avg(df4.total_spent), avg(subtract(df4.total_rentals, 1)))\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.orderby(by = [MASK], [MASK]).partition(by = [MASK]).select([MASK], [MASK], [MASK], row_number() as rn)\ndf2 = df1.where(element = rn, filter = 1).select([MASK], [MASK] as [MASK], [MASK])\ndf3 = df2.select([MASK], [MASK])\ndf4 = df.groupby([MASK]).select([MASK], coalesce(sum([MASK]), 0.0) as [MASK], count(distinct([MASK])) as [MASK])\nres = df3.groupby([MASK]).select([MASK], avg([MASK]), avg(subtract([MASK], 1)))\n```"}
{"idx": 87, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(payment.customer_id).agg(sum(payment.amount) as total_paid).orderby(by = total_paid, desc).limit(10)\ndf2 = df.where(element = payment.customer_id, filter = in(df1.customer_id)).groupby([payment.customer_id, date(payment.payment_date, 'start of month')]).agg(sum(payment.amount) as month_amount)\ndf3 = df2.select(month_amount).orderby(by = month_start).limit(10)\ndf4 = df3.groupby(month_start).agg(avg(month_amount) as avg_monthly_amount)\ndf5 = df.select(customer.customer_id, customer.first_name, customer.last_name, date(month_start, 'start of month') as month, round(month_amount - prev_month_amount, 2) as month_over_month_difference).orderby(by = abs(month_over_month_difference), desc).limit(1)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.groupby([MASK]).agg(sum([MASK]) as total_paid).orderby(by = total_paid, desc).limit(10)\ndf2 = df.where(element = [MASK], filter = in(df1.[MASK])).groupby([MASK, date([MASK], 'start of month')]).agg(sum([MASK]) as month_amount)\ndf3 = df2.select(month_amount).orderby(by = month_start).limit(10)\ndf4 = df3.groupby(month_start).agg(avg(month_amount) as avg_monthly_amount)\ndf5 = df.select([MASK], [MASK], date(month_start, 'start of month') as month, round(month_amount - prev_month_amount, 2) as month_over_month_difference).orderby(by = abs(month_over_month_difference), desc).limit(1)\n```"}
{"idx": 88, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(rental.staff_id).agg(count(rental.rental_date))\ndf2 = df1.groupby(store.store_id).agg(count(rental.rental_date))\ndf3 = df2.orderby(by = count(rental.rental_date), desc).limit(1)\nres = df3.select(store.store_id, strftime(rental.rental_date, '%Y'), strftime(rental.rental_date, '%m'), count(rental.rental_date))\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.groupby([MASK]).agg(count([MASK]))\ndf2 = df1.groupby([MASK]).agg(count([MASK]))\ndf3 = df2.orderby(by = count([MASK]), desc).limit(1)\nres = df3.select([MASK], strftime([MASK], '%Y'), strftime([MASK], '%m'), count([MASK]))\n```"}
{"idx": 89, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = word_list.words, filter = 'between 4 and 5').where(element = word_list.words, filter = \"starts with 'r'\")\ndf2 = df1.select(word_list.words as word, length(word_list.words) as len, group_concat(substring(word_list.words, i, 1)) as signature for i in range(1, length(word_list.words)))\ndf3 = df2.groupby(signature, len).having(element = count(*), filter = '>= 2')\nres = df2.join(df3, on = [signature, len]).orderby(by = word_list.words).limit(10)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [word_list.words], filter = 'between 4 and 5').where(element = [word_list.words], filter = \"starts with 'r'\")\ndf2 = df1.select([word_list.words] as [word], [length(word_list.words)] as [len], group_concat(substring([word_list.words], i, 1)) as [signature] for i in range(1, [length(word_list.words)]))\ndf3 = df2.groupby([signature], [len]).having(element = count(*), filter = '>= 2')\nres = df2.join(df3, on = [signature, len]).orderby(by = [word_list.words]).limit(10)\n```"}
{"idx": 90, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = alien_data.state, filter = 'is not null').where(element = alien_data.state, filter = '!= \"\"')\ndf2 = df1.groupby(alien_data.state).select(alien_data.state, count(alien_data.state) as alien_count, avg(alien_data.age) as avg_age, sum(case when alien_data.aggressive = 0 then 1 else 0 end) * 1.0 / count(alien_data.state) as pct_friendly, sum(case when alien_data.aggressive = 1 then 1 else 0 end) * 1.0 / count(alien_data.state) as pct_hostile)\ndf3 = df2.orderby(by = alien_data.alien_count, desc).limit(10)\ndf4 = df3.where(element = alien_data.avg_age, filter = '> 200').where(element = alien_data.pct_friendly, filter = '> alien_data.pct_hostile')\nres = df4.count()\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [MASK], filter = 'is not null').where(element = [MASK], filter = \"!= ''\")\ndf2 = df1.groupby([MASK]).select([MASK], count([MASK]) as [MASK], avg([MASK]) as [MASK], sum(case when [MASK] = 0 then 1 else 0 end) * 1.0 / count([MASK]) as [MASK], sum(case when [MASK] = 1 then 1 else 0 end) * 1.0 / count([MASK]) as [MASK])\ndf3 = df2.orderby(by = [MASK], desc).limit(10)\ndf4 = df3.where(element = [MASK], filter = '> [MASK]').where(element = [MASK], filter = '> [MASK]')\nres = df4.count()\n```"}
{"idx": 91, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(stores.store_id, stores.store_name).agg(count(orders.order_id) as total_orders)\ndf2 = df1.orderby(by = total_orders, desc, stores.store_id).limit(1)\ndf3 = df2.select(stores.store_id, stores.store_name, total_orders)\ndf4 = df.where(element = deliveries.delivery_status, filter = 'DELIVERED').where(element = deliveries.delivery_id, filter = 'is not null')\ndf5 = df3.join(df4, on = orders.order_id).groupby(stores.store_id, stores.store_name, total_orders).agg(count(deliveries.delivery_id) as delivered_orders)\nres = df3.select(stores.store_id, stores.store_name, total_orders, delivered_orders, divide(delivered_orders, total_orders, default = 0.0))\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.groupby([MASK], [MASK]).agg(count([MASK]) as [MASK])\ndf2 = df1.orderby(by = [MASK], desc, [MASK]).limit(1)\ndf3 = df2.select([MASK], [MASK], [MASK])\ndf4 = df.where(element = [MASK], filter = 'DELIVERED').where(element = [MASK], filter = 'is not null')\ndf5 = df3.join(df4, on = [MASK]).groupby([MASK], [MASK], [MASK]).agg(count([MASK]) as [MASK])\nres = df3.select([MASK], [MASK], [MASK], [MASK], divide([MASK], [MASK], default = 0.0))\n```"}
{"idx": 92, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = orders.order_status, filter = 'FINISHED').where(element = orders.order_created_month, filter = 'IN', values = [2, 3])\ndf2 = df1.groupby(stores.hub_id, hubs.hub_name, orders.order_created_year, orders.order_created_month).count()\ndf3 = df2.select(stores.hub_id, hubs.hub_name, orders.order_created_year, count() as finished_orders)\ndf4 = df3.groupby(stores.hub_id, hubs.hub_name, orders.order_created_year).select(stores.hub_id, hubs.hub_name, orders.order_created_year, sum(case(element = orders.order_created_month, when = 2, then = count()) as feb_finished, else = 0), sum(case(element = orders.order_created_month, when = 3, then = count()) as mar_finished))\ndf5 = df4.where(element = feb_finished, filter = '> 0').where(element = mar_finished, filter = '> feb_finished * 1.20')\ndf6 = df5.select(stores.hub_id, hubs.hub_name, orders.order_created_year, feb_finished, mar_finished, round((mar_finished - feb_finished) / feb_finished * 100, 2) as pct_increase).orderby(by = [pct_increase, desc, mar_finished, desc])\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [orders.order_status], filter = 'FINISHED').where(element = [orders.order_created_month], filter = 'IN', values = [2, 3])\ndf2 = df1.groupby([stores.hub_id], [hubs.hub_name], [orders.order_created_year], [orders.order_created_month]).count()\ndf3 = df2.select([stores.hub_id], [hubs.hub_name], [orders.order_created_year], count() as [finished_orders])\ndf4 = df3.groupby([stores.hub_id], [hubs.hub_name], [orders.order_created_year]).select([stores.hub_id], [hubs.hub_name], [orders.order_created_year], sum(case(element = [orders.order_created_month], when = 2, then = count()) as [feb_finished], else = 0), sum(case(element = [orders.order_created_month], when = 3, then = count()) as [mar_finished]))\ndf5 = df4.where(element = [feb_finished], filter = '> 0').where(element = [mar_finished], filter = '> [feb_finished] * 1.20')\ndf6 = df5.select([stores.hub_id], [hubs.hub_name], [orders.order_created_year], [feb_finished], [mar_finished], round((mar_finished - [feb_finished]) / [feb_finished] * 100, 2) as [pct_increase]).orderby(by = [[pct_increase], desc, [mar_finished], desc])\n```"}
{"idx": 93, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = deliveries.delivery_status, filter = 'DELIVERED')\ndf2 = df1.groupby(deliveries.driver_id, orders.order_created_year, orders.order_created_month, orders.order_created_day).count()\ndf3 = df2.groupby(deliveries.driver_id).avg(deliveries_in_day)\nres = df3.orderby(by = avg(deliveries_in_day), desc).limit(5)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = 'DELIVERED')\ndf2 = df1.groupby([MASK], [MASK], [MASK], [MASK]).count()\ndf3 = df2.groupby([MASK]).avg([MASK])\nres = df3.orderby(by = [MASK], desc).limit(5)\n```"}
{"idx": 94, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(Match.season, Match.home_team_api_id).agg(sum(Match.home_team_goal) + sum(Match.away_team_goal) as total_goals)\ndf2 = df1.groupby(Match.home_team_api_id).agg(max(total_goals) as best_season_goals)\ndf3 = df2.select(best_season_goals).orderby(by = best_season_goals).limit((df2.count() + 1) / 2).limit((df2.count() + 2) / 2)\nres = df3.avg(best_season_goals)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.groupby([MASK], [MASK]).agg(sum([MASK]) + sum([MASK]) as total_goals)\ndf2 = df1.groupby([MASK]).agg(max(total_goals) as best_season_goals)\ndf3 = df2.select(best_season_goals).orderby(by = best_season_goals).limit((df2.count() + 1) / 2).limit((df2.count() + 2) / 2)\nres = df3.avg(best_season_goals)\n```"}
{"idx": 95, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.select(Match.league_id, Match.home_team_api_id as team_api_id).union(df.select(Match.league_id, Match.away_team_api_id as team_api_id))\ndf2 = df.where(element = Match.home_team_goal, filter = '> Match.away_team_goal').groupby(Match.league_id, Match.home_team_api_id).count()\ndf3 = df.where(element = Match.away_team_goal, filter = '> Match.home_team_goal').groupby(Match.league_id, Match.away_team_api_id).count()\ndf4 = df2.union(df3)\ndf5 = df4.groupby(league_id, team_api_id).sum()\ndf6 = df.select(league_id, team_api_id, total_wins).where(element = total_wins, filter = '!= 0')\ndf7 = df.select(league_id, team_api_id, total_wins).where(element = total_wins, filter = '== 0')\ndf8 = df6.union(df7)\ndf9 = df8.orderby(by = total_wins, asc).orderby(by = team_api_id, asc).limit(1)\nres = df9.select(League.name, Team.team_long_name, total_wins)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.select([MASK], [MASK] as [MASK]).union(df.select([MASK], [MASK] as [MASK]))\ndf2 = df.where(element = [MASK], filter = '> [MASK]').groupby([MASK], [MASK]).count()\ndf3 = df.where(element = [MASK], filter = '< [MASK]').groupby([MASK], [MASK]).count()\ndf4 = df2.union(df3)\ndf5 = df4.groupby([MASK], [MASK]).sum()\ndf6 = df.select([MASK], [MASK], [MASK]).where(element = [MASK], filter = '!= 0')\ndf7 = df.select([MASK], [MASK], [MASK]).where(element = [MASK], filter = '== 0')\ndf8 = df6.union(df7)\ndf9 = df8.orderby(by = [MASK], asc).orderby(by = [MASK], asc).limit(1)\nres = df9.select([MASK], [MASK], [MASK])\n```"}
{"idx": 96, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = Match.home_team_goal, filter = '> Match.away_team_goal')\ntmp_res1 = df1.select(Match.league_id, Match.home_team_api_id as team_api_id, 1 as wins)\n\ndf2 = df.where(element = Match.away_team_goal, filter = '> Match.home_team_goal')\ntmp_res2 = df2.select(Match.league_id, Match.away_team_api_id as team_api_id, 1 as wins)\n\nres = (tmp_res1.union(tmp_res2).groupby(League.id, League.name, Team.team_api_id, Team.team_long_name).select(League.name as league_name, Team.team_long_name as team_name, sum(wins) as total_wins).orderby(by = [total_wins, League.name, Team.team_long_name]).limit(10))\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [Match.home_team_goal], filter = '> [Match.away_team_goal]')\ntmp_res1 = df1.select([Match.league_id], [Match.home_team_api_id] as [team_api_id], 1 as [wins])\n\ndf2 = df.where(element = [Match.away_team_goal], filter = '> [Match.home_team_goal]')\ntmp_res2 = df2.select([Match.league_id], [Match.away_team_api_id] as [team_api_id], 1 as [wins])\n\nres = (tmp_res1.union(tmp_res2).groupby([League.id], [League.name], [Team.team_api_id], [Team.team_long_name]).select([League.name] as [league_name], [Team.team_long_name] as [team_name], sum([wins]) as [total_wins]).orderby(by = [total_wins], [League.name], [Team.team_long_name]).limit(10))\n```"}
{"idx": 97, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = orders.order_date, filter = '>= 2022-01-01')\ndf2 = df1.where(element = orders.order_date, filter = '< 2022-06-01')\nres = df2.select(orders.order_id, customers.customer_name)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = '>= 2022-01-01')\ndf2 = df1.where(element = [MASK], filter = '< 2022-06-01')\nres = df2.select([MASK], [MASK])\n```"}
{"idx": 98, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\n\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [Business_Hours].business_id, filter = 12)\ndf2 = df1.where(element = [Days].day_of_week, filter = 'Monday')\nres = df2.select([Business_Hours].opening_time)\n```"}
{"idx": 99, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = orders.order_date, filter = '>= 2022-01-01')\ndf2 = df1.where(element = orders.order_date, filter = '< 2022-06-01')\nres = df2.select(orders.order_id, customers.customer_name)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = '>= 2022-01-01')\ndf2 = df1.where(element = [MASK], filter = '< 2022-06-01')\nres = df2.select([MASK], [MASK])\n```"}
{"idx": 100, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.select(Track.Milliseconds).aggregate(min, avg, max)\ndf2 = df1.select((min + avg) / 2.0 as mid_min_avg, (avg + max) / 2.0 as mid_avg_max)\ndf3 = df.select(Track.TrackId, case(Track.Milliseconds, when = '>= min_ms and < mid_min_avg', 'Short', when = '>= mid_min_avg and < mid_avg_max', 'Medium', when = '>= mid_avg_max and <= max_ms', 'Long') as length_type, Track.Milliseconds)\ndf4 = df.select(InvoiceLine.TrackId, sum(InvoiceLine.Quantity * InvoiceLine.UnitPrice) as revenue).groupby(InvoiceLine.TrackId)\nres = df3.groupby(length_type).select(length_type, round(min(Track.Milliseconds) / 60000.0, 4) as min_minutes, round(max(Track.Milliseconds) / 60000.0, 4) as max_minutes, round(coalesce(sum(revenue_by_track.revenue), 0), 2) as total_revenue).orderby(by = length_type, asc)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.aggregate(min(Track.Milliseconds), avg(Track.Milliseconds), max(Track.Milliseconds))\ndf2 = df1.select((min(Track.Milliseconds) + avg(Track.Milliseconds)) / 2.0 as mid_min_avg, (avg(Track.Milliseconds) + max(Track.Milliseconds)) / 2.0 as mid_avg_max)\ndf3 = df.select(Track.TrackId, case(Track.Milliseconds, when = '>= min(Track.Milliseconds) and < mid_min_avg', 'Short', when = '>= mid_min_avg and < mid_avg_max', 'Medium', when = '>= mid_avg_max and <= max(Track.Milliseconds)', 'Long') as length_type, Track.Milliseconds)\ndf4 = df.groupby(Track.TrackId).select(sum(InvoiceLine.Quantity * InvoiceLine.UnitPrice) as revenue)\nres = df3.groupby(length_type).select(length_type, round(min(Track.Milliseconds) / 60000.0, 4) as min_minutes, round(max(Track.Milliseconds) / 60000.0, 4) as max_minutes, round(coalesce(sum(df4.revenue), 0), 2) as total_revenue).orderby(by = length_type, asc)\n```"}
{"idx": 101, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = SalaryDataset.Location, filter = 'Mumbai', 'Pune', 'New Delhi', 'Hyderabad')\ndf2 = df1.where(element = SalaryDataset.Salary, filter = 'is not null', '>= 0')\ndf3 = df2.select(SalaryDataset.CompanyName, SalaryDataset.Location, cast(cast(SalaryDataset.Salary, real), real) as Salary)\ndf4 = df3.groupby(SalaryDataset.Location, SalaryDataset.CompanyName).agg(avg(Salary))\ndf5 = df2.select(SalaryDataset.Location, SalaryDataset.CompanyName, avg(Salary) as Average_Salary)\ndf6 = df5.orderby(by = Average_Salary, desc).limit(5)\nres = df6.select(SalaryDataset.Location as Location, SalaryDataset.CompanyName as Company Name, round(Average_Salary, 2) as Average Salary in State, round(df4.avg(Salary), 2) as Average Salary in Country)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [SalaryDataset.Location], filter = 'Mumbai', 'Pune', 'New Delhi', 'Hyderabad')\ndf2 = df1.where(element = [SalaryDataset.Salary], filter = 'is not null', '>= 0')\ndf3 = df2.select([SalaryDataset.CompanyName], [SalaryDataset.Location], cast(cast([SalaryDataset.Salary], real), real) as [Salary])\ndf4 = df3.groupby([SalaryDataset.Location], [SalaryDataset.CompanyName]).agg(avg([Salary]))\ndf5 = df2.select([SalaryDataset.Location], [SalaryDataset.CompanyName], avg([Salary]) as [Average_Salary])\ndf6 = df5.orderby(by = [Average_Salary], desc).limit(5)\nres = df6.select([SalaryDataset.Location] as [Location], [SalaryDataset.CompanyName] as [Company Name], round([Average_Salary], 2) as [Average Salary in State], round([df4.avg([Salary])], 2) as [Average Salary in Country])\n```"}
{"idx": 102, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.select(ball_by_ball.match_id, ball_by_ball.innings_no, ball_by_ball.over_id, ball_by_ball.ball_id, ball_by_ball.bowler, batsman_scored.runs_scored as bat_runs)\ndf2 = df1.except(df1.join(extra_runs, on = [match_id, innings_no, over_id, ball_id, extra_type = 'wides', 'wide', 'no ball', 'noball', 'no-ball'])\ndf3 = df2.groupby([match_id, bowler]).select(bowler, count() as balls_bowled, sum(bat_runs) as runs_conceded, count(wicket_taken.kind_out) as wickets)\ndf4 = df3.groupby(bowler).select(bowler, sum(balls_bowled) as balls_bowled, sum(runs_conceded) as runs_conceded, sum(wickets) as wickets)\ndf5 = df3.orderby(by = [wickets, runs_conceded, balls_bowled, match_id], desc).select(bowler, match_id, balls_bowled, runs_conceded, wickets, row_number() as rn)\ndf6 = df4.select(player.player_id as bowler_id, player.player_name as bowler_name, wickets as total_wickets, round((1.0 * runs_conceded / nullif(balls_bowled, 0)) * 6.0, 2) as economy_rate, round(1.0 * balls_bowled / nullif(wickets, 0), 2) as strike_rate, concat(wickets, '-', runs_conceded) as best_bowling_match)\nres = df6.orderby(by = [total_wickets, economy_rate, strike_rate, bowler_name])\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.select([MASK].match_id, [MASK].innings_no, [MASK].over_id, [MASK].ball_id, [MASK].bowler, [MASK].batsman_scored.runs_scored as bat_runs)\ndf2 = df1.except(df1.join([MASK], on = [MASK.match_id, [MASK].innings_no, [MASK].over_id, [MASK].ball_id, [MASK].extra_type = 'wides', 'wide', 'no ball', 'noball', 'no-ball'])\ndf3 = df2.groupby([MASK].bowler).select([MASK].bowler, count() as balls_bowled, sum([MASK].batsman_scored.runs_scored) as runs_conceded, count([MASK].wicket_taken.kind_out) as wickets)\ndf4 = df3.groupby([MASK].bowler).select([MASK].bowler, sum([MASK].balls_bowled) as balls_bowled, sum([MASK].runs_conceded) as runs_conceded, sum([MASK].wickets) as wickets)\ndf5 = df3.orderby(by = [MASK].wickets, [MASK].runs_conceded, [MASK].balls_bowled, [MASK].match_id), desc).select([MASK].bowler, [MASK].match_id, [MASK].balls_bowled, [MASK].runs_conceded, [MASK].wickets, row_number() as rn)\ndf6 = df2.select([MASK].opening_time)\nres = df.select([MASK])"}
{"idx": 103, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = orders.order_date, filter = '>= 2022-01-01')\ndf2 = df1.where(element = orders.order_date, filter = '< 2022-06-01')\nres = df2.select(orders.order_id, customers.customer_name)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = '>= 2022-01-01')\ndf2 = df1.where(element = [MASK], filter = '< 2022-06-01')\nres = df2.select([MASK], [MASK])\n```"}
{"idx": 104, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = model_score.model, filter = 'Stack').where(element = model_score.step, filter = 'in', values = [1, 2, 3])\ndf2 = df.where(element = model_score.model, filter = '<>', values = 'Stack').where(element = model_score.step, filter = 'in', values = [1, 2, 3]).groupby([model_score.name, model_score.version, model_score.step]).agg(max(model_score.test_score))\ndf3 = df1.select(model_score.name, model_score.version, model_score.step).where(element = model_score.test_score, filter = '>', other_element = df2.max_nonstack_test_score)\ndf4 = df.groupby(solution.name).count()\ndf5 = df3.groupby(model_score.name).count()\nres = df5.select(model_score.name).where(element = df5.qualified_occurrences, filter = '>', other_element = df4.solution_occurrences).orderby(by = model_score.name)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [MASK], filter = 'Stack').where(element = [MASK], filter = 'in', values = [1, 2, 3])\ndf2 = df.where(element = [MASK], filter = '<>', values = 'Stack').where(element = [MASK], filter = 'in', values = [1, 2, 3]).groupby([MASK, [MASK], [MASK]]).agg(max([MASK]))\ndf3 = df1.select([MASK], [MASK], [MASK]).where(element = [MASK], filter = '>', other_element = df2.max([MASK]))\ndf4 = df.groupby([MASK]).count()\ndf5 = df3.groupby([MASK]).count()\nres = df5.select([MASK]).where(element = df5.qualified_occurrences, filter = '>', other_element = df4.[MASK]).orderby(by = [MASK])\n```"}
{"idx": 105, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(model.name, model.version, model.step).select(model.name, model.version, model.step, max(if(model_score.model != 'Stack', model_score.test_score, null)) as max_non_stack_test, max(if(model_score.model = 'Stack', model_score.test_score)) as stack_test)\ndf2 = df1.groupby(model.name, model.version).select(model.name, model.version, if(max(max_non_stack_test < stack_test, 1, 0) = 1, 'strong', if(max(max_non_stack_test = stack_test, 1, 0) = 1, 'soft', null)) as status)\ndf3 = df.where(model.L1_model, filter = 'is not null').groupby(model.name, model.version, model.L1_model).select(model.name, model.version, model.L1_model)\ndf4 = df2.join(df3, on = [model.name, model.version]).where(element = status, filter = 'in', values = ['strong', 'soft']).groupby(status, model.L1_model).select(status, model.L1_model, count())\ndf5 = df4.orderby(by = [count(), model.L1_model], desc).select(status, model.L1_model, count())\nres = df5.where(element = 'rn', filter = 1).orderby(by = status)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.groupby([MASK], [MASK], [MASK]).select([MASK], [MASK], [MASK], max(if([MASK] != 'Stack', [MASK], null)) as [MASK], max(if([MASK] = 'Stack', [MASK])))\ndf2 = df1.groupby([MASK], [MASK]).select([MASK], [MASK], if(max([MASK] < [MASK], 1, 0) = 1, 'strong', if(max([MASK] = [MASK], 1, 0) = 1, 'soft', null)) as [MASK])\ndf3 = df.where([MASK], filter = 'is not null').groupby([MASK], [MASK], [MASK]).select([MASK], [MASK], [MASK])\ndf4 = df2.join(df3, on = [MASK], [MASK]).where(element = [MASK], filter = 'in', values = ['strong', 'soft']).groupby([MASK], [MASK]).select([MASK], [MASK], count())\ndf5 = df4.orderby(by = [count()], desc).select([MASK], [MASK], count())\nres = df5.where(element = 'rn', filter = 1).orderby(by = [MASK])\n```"}
{"idx": 106, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = model.L1_model, filter = 'is not null')\ndf2 = df1.select(model.L1_model).where(element = model.L1_model, filter = 'Stack').count()\ndf3 = df1.select(model.L1_model).where(element = model.L1_model, filter = 'not Stack').count()\nres = df.select(max(by(df2, df3)))\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [MASK], filter = 'is not null')\ndf2 = df1.select([MASK]).where(element = [MASK], filter = 'Stack').count()\ndf3 = df1.select([MASK]).where(element = [MASK], filter = 'not Stack').count()\nres = df.select(max(by(df2, df3)))\n```"}
{"idx": 107, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.select(packaging.id as root_packaging_id, packaging.id as leaf_packaging_id, 1.0 as qty_mult)\ndf2 = df1.union(df.select(expanded.root_packaging_id, packaging_relations.contains_id as leaf_packaging_id, expanded.qty_mult * packaging_relations.qty as qty_mult, where = 'exists packaging_relations.packaging_id in expanded.leaf_packaging_id'))\ndf3 = df2.groupby(expanded.root_packaging_id).agg(sum(expanded.qty_mult) as total_leaf_qty)\ndf4 = df3.where(element = packaging_relations.packaging_id, filter = 'is null')\nres = df4.avg(total_leaf_qty)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.select([MASK] as root_packaging_id, [MASK] as leaf_packaging_id, 1.0 as qty_mult)\ndf2 = df1.union(df.select([MASK], [MASK] as leaf_packaging_id, [MASK] * [MASK] as qty_mult, where = 'exists [MASK] in [MASK]'))\ndf3 = df2.groupby([MASK]).agg(sum([MASK]) as total_leaf_qty)\ndf4 = df3.where(element = [MASK], filter = 'is null')\nres = df4.avg(total_leaf_qty)\n```"}
{"idx": 108, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where_not_exists(packaging.id, in = packaging_relations.contains_id)\ndf2 = df1.select(packaging.id, packaging.name)\ndf3 = df.select(packaging_relations.contains_id, packaging_relations.qty)\ndf4 = df3.groupby(packaging_relations.contains_id).agg(sum(packaging_relations.qty))\ndf5 = df2.join(df4, on = packaging.id).where(element = sum(packaging_relations.qty), filter = '> 500')\nres = df5.select(packaging.name, packaging_relations.contains_id, sum(packaging_relations.qty))\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where_not_exists([MASK], in = [MASK])\ndf2 = df1.select([MASK], [MASK])\ndf3 = df.select([MASK], [MASK])\ndf4 = df3.groupby([MASK]).agg(sum([MASK]))\ndf5 = df2.join(df4, on = [MASK]).where(element = sum([MASK]), filter = '> 500')\nres = df5.select([MASK], [MASK], sum([MASK]))\n```"}
{"idx": 109, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\n\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [Business_Hours].business_id, filter = 12)\ndf2 = df1.where(element = [Days].day_of_week, filter = 'Monday')\nres = df2.select([Business_Hours].opening_time)\n```"}
{"idx": 110, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(picking_line.order_id, picking_line.product_id).agg(sum(picking_line.qty) as order_qty)\ndf2 = df.select(inventory.product_id, inventory.location_id, inventory.purchase_id, purchases.purchased as purchased_dt, inventory.qty as inv_qty)\ndf3 = df2.orderby(by = [inventory.purchase_id, inventory.inv_qty, inventory.location_id]).rank(by = inventory.purchase_id, inventory.inv_qty, inventory.location_id)\ndf4 = df1.join(df3, on = [df1.product_id, df3.product_id]).select(order_demand.order_id, order_demand.product_id, inv_ranked.location_id, inv_ranked.purchase_id, inv_ranked.purchased_dt, inv_ranked.inv_qty, order_demand.order_qty, inv_ranked.inv_before, max(0, min(order_demand.order_qty, inv_ranked.inv_before + inv_ranked.inv_qty) - inv_ranked.inv_before) as picked_qty)\ndf5 = df4.groupby(order_demand.order_id, order_demand.product_id, order_demand.order_qty).agg(sum(picked_qty) as total_picked_qty, case when order_demand.order_qty = 0 then null else 1.0 * sum(picked_qty) / order_demand.order_qty end as pick_pct)\nres = df5.groupby(products.name).agg(avg(pick_pct))\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.groupby([MASK], [MASK]).agg(sum([MASK]) as [MASK])\ndf2 = df.select([MASK], [MASK], [MASK], [MASK].purchased as [MASK], [MASK].qty as [MASK])\ndf3 = df2.orderby(by = [MASK], [MASK], [MASK]).rank(by = [MASK], [MASK], [MASK])\ndf4 = df1.join(df3, on = [MASK, [MASK]]).select([MASK].order_id, [MASK].product_id, inv_ranked.[MASK], inv_ranked.[MASK], inv_ranked.[MASK], inv_ranked.[MASK], order_demand.[MASK], inv_ranked.[MASK], max(0, min(order_demand.[MASK], inv_ranked.[MASK] + inv_ranked.[MASK]) - inv_ranked.[MASK]) as [MASK])\ndf5 = df4.groupby([MASK], [MASK], [MASK], [MASK]).agg(sum([MASK]) as [MASK], case when [MASK] = 0 then null else 1.0 * sum([MASK]) / [MASK] end as [MASK])\nres = df5.groupby([MASK]).agg(avg([MASK]))\n```"}
{"idx": 111, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = picking_line.order_id, filter = 421)\ndf2 = df.where(element = purchases.product_id, filter = 'in', value = df1.select(picking_line.product_id))\ndf3 = df2.orderby(by = [purchases.purchased, purchases.id]).cumsum(purchases.qty)\ndf4 = df.select(picking_line.order_id, picking_line.product_id, picking_line.qty as picked_qty)\ndf5 = df4.join(df3, on = [picking_line.product_id], how = 'inner')\ndf6 = df5.where(element = picking_line.picked_qty, filter = '<=', reference = df3.cum_qty).select(0)\ndf7 = df5.where(element = picking_line.picked_qty, filter = '>=', reference = df3.cum_qty).select(min(df3.layer_qty, picking_line.picked_qty - df3.cum_qty))\ndf8 = df5.select(picking_line.order_id, picking_line.product_id, purchases.purchased, case(when(df6.picked_qty > 0, then 0), else df7))\ndf9 = df.groupby(picking_line.product_id, products.name).select(picking_line.order_id, products.name, sum(df8.alloc_qty), case(when(sum(case(df8.alloc_qty > 0, then 1, else 0)) = 0, then null), else 1.0 * sum(df8.alloc_qty) / sum(case(df8.alloc_qty > 0, then 1, else 0))))\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [MASK], filter = 421)\ndf2 = df.where(element = [MASK], filter = 'in', value = df1.select([MASK]))\ndf3 = df2.orderby(by = [MASK]).cumsum([MASK])\ndf4 = df.select([MASK], [MASK], [MASK] as [MASK])\ndf5 = df4.join(df3, on = [MASK], how = 'inner')\ndf6 = df5.where(element = [MASK], filter = '<=', reference = df3.cumsum).select(0)\ndf7 = df5.where(element = [MASK], filter = '>=', reference = df3.cumsum).select(min([MASK], [MASK] - df3.cumsum))\ndf8 = df5.select([MASK], [MASK], [MASK], case(when([MASK] > 0, then 0), else [MASK]))\ndf9 = df.groupby([MASK], [MASK]).select([MASK], [MASK], sum([MASK]), case(when(sum(case([MASK] > 0, then 1, else 0)) = 0, then null), else 1.0 * sum([MASK]) / sum(case([MASK] > 0, then 1, else 0))))\n```"}
{"idx": 112, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = monthly_sales.mth, filter = '>= 2016-01-01')\ndf2 = df1.select(monthly_sales.product_id, monthly_sales.mth, monthly_sales.qty * 1.0 as qty)\ndf3 = df2.select(monthly_sales.product_id, df2.mth, df2.qty, (cast(strftime('%Y', df2.mth), integer) - 2016) * 12 + cast(strftime('%m', df2.mth), integer) as t)\ndf4 = df3.window(partition_by = monthly_sales.product_id, order_by = monthly_sales.mth, rows_between = 5 preceding and 6 following).avg(monthly_sales.qty)\ndf5 = df3.window(partition_by = monthly_sales.product_id, order_by = monthly_sales.mth, rows_between = 6 preceding and 5 following).avg(monthly_sales.qty)\ndf6 = df3.select(monthly_sales.product_id, monthly_sales.mth, monthly_sales.qty, (df4 + df5) / 2.0 as cma_qty)\ndf7 = df6.where(element = (df6.t), filter = 'between 7 and 30')\ndf8 = df7.select(monthly_sales.product_id, monthly_sales.mth, monthly_sales.qty, df6.cma_qty, when(df6.cma_qty, is null or df6.cma_qty = 0, then = null).else = monthly_sales.qty / df6.cma_qty as sales_to_cma_ratio)\ndf9 = df8.where(element = monthly_sales.mth, filter = '>= 2017-01-01').where(element = monthly_sales.mth, filter = '< 2018-01-01')\ndf10 = df9.groupby(products.id, products.name).having(element = count(*), filter = '= 12').having(element = min(y2017.sales_to_cma_ratio), filter = '> 2.0')\nres = df10.select(products.id as product_id, products.name as product_name)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = '>= 2016-01-01')\ndf2 = df1.select([MASK].product_id, [MASK].mth, [MASK].qty * 1.0 as qty)\ndf3 = df2.select([MASK].product_id, df2.mth, df2.qty, (cast(strftime('%Y', df2.mth), integer) - 2016) * 12 + cast(strftime('%m', df2.mth), integer) as t)\ndf4 = df3.window(partition_by = [MASK].product_id, order_by = [MASK].mth, rows_between = 5 preceding and 6 following).avg([MASK].qty)\ndf5 = df3.window(partition_by = [MASK].product_id, order_by = [MASK].mth, rows_between = 6 preceding and 5 following).avg([MASK].qty)\ndf6 = df3.select([MASK].product_id, [MASK].mth, [MASK].qty, (df4 + df5) / 2.0 as cma_qty)\ndf7 = df6.where(element = (df6.t), filter = 'between 7 and 30')\ndf8 = df7.select([MASK].product_id, [MASK].mth, [MASK].qty, df6.cma_qty, when(df6.cma_qty, is null or df6.cma_qty = 0, then = null).else = [MASK].qty / df6.cma_qty as sales_to_cma_ratio)\ndf3 = df.where(element = [MASK].mth, filter = '>= 2017-01-01').where(element = [MASK].mth, filter = '< 2018-01-01')\ndf4 = df3.groupby([MASK].id, [MASK].name).having(element = count(*), filter = '= 12').having(element = min([MASK].sales_to_cma_ratio), filter = '> 2.0')\nres = df4.select([MASK].id as product_id, [MASK].name as product_name)\n```"}
{"idx": 113, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = orders.order_date, filter = '>= 2022-01-01')\ndf2 = df1.where(element = orders.order_date, filter = '< 2022-06-01')\nres = df2.select(orders.order_id, customers.customer_name)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = '>= 2022-01-01')\ndf2 = df1.where(element = [MASK], filter = '< 2022-06-01')\nres = df2.select([MASK], [MASK])\n```"}
{"idx": 114, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = orders.order_date, filter = '>= 2022-01-01')\ndf2 = df1.where(element = orders.order_date, filter = '< 2022-06-01')\nres = df2.select(orders.order_id, customers.customer_name)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = '>= 2022-01-01')\ndf2 = df1.where(element = [MASK], filter = '< 2022-06-01')\nres = df2.select([MASK], [MASK])\n```"}
{"idx": 115, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.select(Match.season, Match.league_id, Match.country_id, Match.home_team_api_id as team_api_id, case(when Match.home_team_goal > Match.away_team_goal, 3, when Match.home_team_goal = Match.away_team_goal, 1, 0) as points)\ndf2 = df1.union(df.select(Match.season, Match.league_id, Match.country_id, Match.away_team_api_id as team_api_id, case(when Match.away_team_goal > Match.home_team_goal, 3, when Match.away_team_goal = Match.home_team_goal, 1, 0) as points))\ndf3 = df2.groupby(Match.season, Match.league_id, Match.country_id, team_api_id).agg(sum(points) as total_points)\ndf4 = df3.orderby(by = total_points, desc, team_api_id).select(Match.season, Team.team_long_name as champion_team, League.name as league, Country.name as country, total_points)\nres = df4.where(element = ranked.rn, filter = 1).orderby(by = Match.season, Country.name, League.name)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.select([MASK], [MASK], [MASK], [MASK].as(team_api_id), case(when [MASK] > [MASK], 3, when [MASK] = [MASK], 1, 0) as points)\ndf2 = df1.union(df.select([MASK], [MASK], [MASK], [MASK].as(team_api_id), case(when [MASK] > [MASK], 3, when [MASK] = [MASK], 1, 0) as points))\ndf3 = df2.groupby([MASK], [MASK], [MASK], team_api_id).agg(sum(points) as total_points)\ndf4 = df3.orderby(by = total_points, desc, team_api_id).select([MASK], Team.team_long_name as champion_team, League.name as league, Country.name as country, total_points)\nres = df4.where(element = ranked.rn, filter = 1).orderby(by = [MASK], [MASK], [MASK])\n```"}
{"idx": 116, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = veg_loss_rate_df.loss_rate_%, filter = 'is not null')\ndf2 = df1.select(veg_loss_rate_df.item_code, veg_loss_rate_df.item_name, cast(replace(veg_loss_rate_df.loss_rate_%, '%', ''), real) as loss_rate)\ndf3 = df2.aggregate(group_by = None, operations = {'avg(loss_rate)': 'avg', 'stddev(loss_rate)': 'stddev'})\ndf4 = df2.where(element = loss_rate, filter = '<', value = df3.avg_loss_rate - df3.stddev_loss_rate).count()\ndf5 = df2.where(element = loss_rate, filter = '>=', value = df3.avg_loss_rate + df3.stddev_loss_rate).count()\ndf6 = df2.where(element = loss_rate, filter = 'between', value1 = df3.avg_loss_rate - df3.stddev_loss_rate, value2 = df3.avg_loss_rate + df3.stddev_loss_rate).count()\nres = df.select(df3.avg_loss_rate, df3.stddev_loss_rate, df2.count(), df4, df5, df6)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [MASK], filter = 'is not null')\ndf2 = df1.select([MASK.item_code], [MASK.item_name], cast(replace([MASK.loss_rate], '%', ''), real) as [MASK.loss_rate])\ndf3 = df2.aggregate(group_by = None, operations = {'avg([MASK.loss_rate])': 'avg', 'stddev([MASK.loss_rate])': 'stddev'})\ndf4 = df2.where(element = [MASK.loss_rate], filter = '<', value = df3.avg([MASK.loss_rate]) - df3.stddev([MASK.loss_rate])).count()\ndf5 = df2.where(element = [MASK.loss_rate], filter = '>=', value = df3.avg([MASK.loss_rate]) + df3.stddev([MASK.loss_rate])).count()\ndf6 = df2.where(element = [MASK.loss_rate], filter = 'between', value1 = df3.avg([MASK.loss_rate]) - df3.stddev([MASK.loss_rate]), value2 = df3.avg([MASK.loss_rate]) + df3.stddev([MASK.loss_rate])).count()\nres = df.select(df3.avg([MASK.loss_rate]), df3.stddev([MASK.loss_rate]), df2.count(), df4, df5, df6)\n```"}
{"idx": 117, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\n\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [Business_Hours].business_id, filter = 12)\ndf2 = df1.where(element = [Days].day_of_week, filter = 'Monday')\nres = df2.select([Business_Hours].opening_time)\n```"}
{"idx": 118, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\n\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [Business_Hours].business_id, filter = 12)\ndf2 = df1.where(element = [Days].day_of_week, filter = 'Monday')\nres = df2.select([Business_Hours].opening_time)\n```"}
{"idx": 119, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = cleaned_weekly_sales.calendar_year, filter = 'IN', values = [2018, 2019, 2020])\ndf2 = df1.where(element = cleaned_weekly_sales.week_date, filter = 'BETWEEN', values = ['2018-06-15 -28 days', '2018-06-15 +28 days'])\ndf3 = df2.select(cast(cleaned_weekly_sales.calendar_year, integer) as year, cleaned_weekly_sales.week_date as week_date, cleaned_weekly_sales.sales as sales)\ndf4 = df3.groupby(cast(cleaned_weekly_sales.calendar_year, integer)).agg({'sales': 'sum', filter = 'CASE WHEN week_date >= 2018-06-15 -28 days AND week_date < 2018-06-15 THEN pre_4w, WHEN week_date >= 2018-06-15 AND week_date < 2018-06-15 +28 days THEN post_4w'})\nres = df4.select(cast(cleaned_weekly_sales.calendar_year, integer) as year, df4.sum(case = 'pre_4w', element = cleaned_weekly_sales.sales) as sales_pre_4w, df4.sum(case = 'post_4w', element = cleaned_weekly_sales.sales) as sales_post_4w, round((df4.sum(case = 'post_4w', element = cleaned_weekly_sales.sales) - df4.sum(case = 'pre_4w', element = cleaned_weekly_sales.sales)) * 100.0 / df4.sum(case = 'pre_4w', element = cleaned_weekly_sales.sales), 2) as pct_change_sales_post_vs_pre)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [MASK], filter = 'IN', values = [2018, 2019, 2020])\ndf2 = df1.where(element = [MASK], filter = 'BETWEEN', values = ['2018-06-15 -28 days', '2018-06-15 +28 days'])\ndf3 = df2.select([MASK], [MASK], [MASK])\ndf4 = df3.groupby([MASK]).agg({'[MASK]': 'sum', filter = 'CASE WHEN [MASK] >= 2018-06-15 -28 days AND [MASK] < 2018-06-15 THEN pre_4w, WHEN [MASK] >= 2018-06-15 AND [MASK] < 2018-06-15 +28 days THEN post_4w'})\nres = df4.select([MASK], df4.sum(case = 'pre_4w', element = [MASK]), df4.sum(case = 'post_4w', element = [MASK]), round((df4.sum(case = 'post_4w', element = [MASK]) - df4.sum(case = 'pre_4w', element = [MASK])) * 100.0 / df4.sum(case = 'pre_4w', element = [MASK]), 2) as pct_change_sales_post_vs_pre)\n```"}
{"idx": 120, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\n\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [Business_Hours].business_id, filter = 12)\ndf2 = df1.where(element = [Days].day_of_week, filter = 'Monday')\nres = df2.select([Business_Hours].opening_time)\n```"}
{"idx": 121, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = form_log.path, filter = '/regist/input')\ntmp_res1 = df1.groupby(form_log.session).agg(min(form_log.stamp), as = 'input_time')\n\ndf2 = df.where(element = form_log.path, filter = '/regist/confirm')\ntmp_res2 = df2.groupby(form_log.session).agg(min(form_log.stamp), as = 'confirm_time')\n\ndf3 = tmp_res1.join(tmp_res2, on = 'session', filter = 'confirm_time > input_time')\nres = df3.count(distinct = 'session')\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [MASK], filter = '/regist/input')\ntmp_res1 = df1.groupby([MASK]).agg(min([MASK]), as = 'input_time')\n\ndf2 = df.where(element = [MASK], filter = '/regist/confirm')\ntmp_res2 = df2.groupby([MASK]).agg(min([MASK]), as = 'confirm_time')\n\ndf3 = tmp_res1.join(tmp_res2, on = [MASK], filter = 'confirm_time > input_time')\nres = df3.count(distinct = [MASK])\n```"}
{"idx": 122, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = activity_log.path, filter = 'is not null')\ndf2 = df1.select(activity_log.session, activity_log.path, activity_log.stamp).orderby(by = activity_log.stamp).partitionby(by = activity_log.session)\ndf3 = df2.select(activity_log.session, activity_log.path).where(element = activity_log.session, filter = 'in', subquery = df2.select(activity_log.session).where(element = activity_log.path, filter = 'is first').or(element = activity_log.path, filter = 'is last'))\ndf4 = df3.groupby(activity_log.session, activity_log.path).count()\nres = df4.orderby(by = count, desc, activity_log.path)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = 'is not null')\ndf2 = df1.select([MASK], [MASK], [MASK]).orderby(by = [MASK]).partitionby(by = [MASK])\ndf3 = df2.select([MASK], [MASK]).where(element = [MASK], filter = 'in', subquery = df2.select([MASK]).where(element = [MASK], filter = 'is first').or(element = [MASK], filter = 'is last'))\ndf4 = df3.groupby([MASK], [MASK]).count()\nres = df4.orderby(by = count, desc, [MASK])\n```"}
{"idx": 123, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.with_orderby(by = read_log.stamp, partition_by = read_log.session).select(read_log.session, read_log.stamp, read_log.url, lag(read_log.url, 1), lag(read_log.url, 2))\ndf2 = df1.where(element = lag(read_log.url, 1), filter = '/detail').where(element = lag(read_log.url, 2), filter = '/detail').where(element = read_log.url, filter = 'is not null')\ndf3 = df2.select(read_log.url).groupby(read_log.url).orderby(by = count(), desc, read_log.url).limit(3)\nres = df3.select(read_log.url, count())\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.with_orderby(by = [MASK], partition_by = [MASK]).select([MASK], [MASK], [MASK], lag([MASK], 1), lag([MASK], 2))\ndf2 = df1.where(element = lag([MASK], 1), filter = '/detail').where(element = lag([MASK], 2), filter = '/detail').where(element = [MASK], filter = 'is not null')\ndf3 = df2.select([MASK]).groupby([MASK]).orderby(by = count(), desc, [MASK]).limit(3)\nres = df3.select([MASK], count())\n```"}
{"idx": 124, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = mst_users.birth_date, filter = 'is not null')\ndf2 = df1.select(mst_users.user_id, cast(strftime('%Y', 'now') - cast(strftime('%Y', mst_users.birth_date) - case when strftime('%m-%d', 'now') < strftime('%m-%d', mst_users.birth_date) then 1 else 0, as integer) as age)\ndf3 = df2.select(mst_users.user_id, case when age between 20 and 29 then '20s', when age between 30 and 39 then '30s', when age between 40 and 49 then '40s', when age between 50 and 59 then '50s', else 'others' as age_category)\nres = df3.groupby(age_category).count(distinct(mst_users.user_id)).orderby(by = age_category, asc)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [MASK], filter = 'is not null')\ndf2 = df1.select([MASK], cast(strftime('%Y', 'now') - cast(strftime('%Y', [MASK]) - case when strftime('%m-%d', 'now') < strftime('%m-%d', [MASK]) then 1 else 0, as integer) as [MASK]))\ndf3 = df2.select([MASK], case when [MASK] between 20 and 29 then '20s', when [MASK] between 30 and 39 then '30s', when [MASK] between 40 and 49 then '40s', when [MASK] between 50 and 59 then '50s', else 'others' as [MASK])\nres = df3.groupby([MASK]).count(distinct([MASK])).orderby(by = [MASK], asc)\n```"}
{"idx": 125, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = activity_log.action, filter = 'click').where(element = activity_log.path, filter = '/detail').select(activity_log.session).groupby(activity_log.session).agg(min(activity_log.stamp))\ndf2 = df.where(element = activity_log.action, filter = 'conversion').where(element = activity_log.path, filter = '/complete').select(activity_log.session).groupby(activity_log.session).agg(min(activity_log.stamp))\ntmp_res1 = df1.union(df2)\n\ndf3 = df.where(element = activity_log.search_type, filter = 'is not null').where(element = activity_log.search_type, filter = '!= \"\"').where(element = activity_log.stamp, filter = '< tmp_res1.first_target_stamp).groupby(activity_log.session, activity_log.path, activity_log.search_type).agg(count())\ndf4 = df3.groupby(activity_log.session).agg(min(df3.pre_event_count))\ntmp_res2 = df4.orderby(by = df4.min_pre_event_count).limit(1)\n\nres = df.where(element = pre_events.pre_event_count, filter = tmp_res2.min_pre_event_count).orderby(by = pre_events.session, pre_events.path, pre_events.search_type)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [activity_log.action], filter = 'click').where(element = [activity_log.path], filter = '/detail').select([activity_log.session]).groupby([activity_log.session]).agg(min([activity_log.stamp]))\ndf2 = df.where(element = [activity_log.action], filter = 'conversion').where(element = [activity_log.path], filter = '/complete').select([activity_log.session]).groupby([activity_log.session]).agg(min([activity_log.stamp]))\ntmp_res1 = df1.union(df2)\n\ndf3 = df.where(element = [activity_log.search_type], filter = 'is not null').where(element = [activity_log.search_type], filter = '!= \"\"').where(element = [activity_log.stamp], filter = '< tmp_res1.first_target_stamp).groupby([activity_log.session, activity_log.path, activity_log.search_type]).agg(count())\ndf4 = df3.groupby([activity_log.session]).agg(min(df3.pre_event_count))\ntmp_res2 = df4.orderby(by = df4.min_pre_event_count).limit(1)\n\nres = df.where(element = [pre_events.pre_event_count], filter = tmp_res2.min_pre_event_count).orderby(by = [pre_events.session, pre_events.path, pre_events.search_type])\n```"}
{"idx": 126, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\n\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [Business_Hours].business_id, filter = 12)\ndf2 = df1.where(element = [Days].day_of_week, filter = 'Monday')\nres = df2.select([Business_Hours].opening_time)\n```"}
{"idx": 127, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\n\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [Business_Hours].business_id, filter = 12)\ndf2 = df1.where(element = [Days].day_of_week, filter = 'Monday')\nres = df2.select([Business_Hours].opening_time)\n```"}
{"idx": 128, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\n\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.where(element = [Business_Hours].business_id, filter = 12)\ndf2 = df1.where(element = [Days].day_of_week, filter = 'Monday')\nres = df2.select([Business_Hours].opening_time)\n```"}
{"idx": 129, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(races.year, results.driver_id).agg(sum(results.points) as total_points)\ndf2 = df1.orderby(by = total_points, desc).limit(1)\ntmp_res1 = df2.select(races.year, drivers_ext.full_name, total_points)\n\ndf3 = df.groupby(races.year, constructors.constructor_id).agg(sum(results.points) as total_points)\ndf4 = df3.orderby(by = total_points, desc).limit(1)\ntmp_res2 = df4.select(races.year, constructors.name, total_points)\n\nres = tmp_res1.join(tmp_res2).orderby(by = races.year)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.groupby([MASK], [MASK]).agg(sum([MASK]) as [MASK])\ndf2 = df1.orderby(by = [MASK], desc).limit(1)\ntmp_res1 = df2.select([MASK], [MASK], [MASK])\n\ndf3 = df.groupby([MASK], [MASK]).agg(sum([MASK]) as [MASK])\ndf4 = df3.orderby(by = [MASK], desc).limit(1)\ntmp_res2 = df4.select([MASK], [MASK], [MASK])\n\nres = tmp_res1.join(tmp_res2).orderby(by = [MASK])\n```"}
{"idx": 130, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(races.year).agg(max_driver_points = max(results.points), max_constructor_points = max(results.points))\ndf2 = df1.orderby(by = smallest_sum_max_driver_plus_max_constructor).asc().limit(3)\nres = df2.select(races.year, smallest_sum_max_driver_plus_max_constructor)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.groupby([MASK]).agg(max_driver_points = max([MASK]), max_constructor_points = max([MASK]))\ndf2 = df1.orderby(by = smallest_sum_max_driver_plus_max_constructor).asc().limit(3)\nres = df2.select([MASK], smallest_sum_max_driver_plus_max_constructor)\n```"}
{"idx": 131, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(races.year, results.constructor_id, results.driver_id).agg(sum(results.points) as driver_points)\ndf2 = df1.groupby(year, constructor_id).agg(max(driver_points) as best_driver_points)\ndf3 = df.groupby(races.year, results.constructor_id).agg(sum(results.points) as team_points)\ndf4 = df3.join(df2, on = [year, constructor_id])\ndf5 = df4.select(year, constructor_id, add(team_points, best_driver_points) as combined_points)\ndf6 = df5.groupby(year).rank(combined_points, desc).limit(3)\nres = df6.select(constructors.name, year, combined_points)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.groupby([MASK], [MASK], [MASK]).agg(sum([MASK]) as [MASK])\ndf2 = df1.groupby([MASK]).agg(max([MASK]) as [MASK])\ndf3 = df.groupby([MASK]).agg(sum([MASK]) as [MASK])\ndf4 = df3.join(df2, on = [MASK])\ndf5 = df4.select([MASK], add([MASK], [MASK]) as [MASK])\ndf6 = df5.groupby([MASK]).rank([MASK], desc).limit(3)\nres = df6.select([MASK], [MASK], [MASK])\n```"}
{"idx": 132, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(races.year, filter = 'BETWEEN 1950 AND 1959')\ndf2 = df.where(results.driver_id, exists = True)\ndf3 = df2.groupby(driver_season_races.year, driver_season_races.driver_id).having(element = count(distinct(driver_season_races.round)), filter = '>= 2')\ndf4 = df3.select(driver_season_races.year, driver_season_races.driver_id, min(driver_season_races.date) as first_date, max(driver_season_races.date) as last_date, count(distinct(driver_season_races.round)) as distinct_rounds)\ndf5 = df4.groupby(driver_season_races.year, driver_season_races.driver_id).select(driver_season_races.year, driver_season_races.driver_id, (select(driver_season_races.race_id).from(driver_season_races).where(driver_season_races.year = df4.year, driver_season_races.driver_id = df4.driver_id, driver_season_races.date = df4.first_date).orderby(by = driver_season_races.round, asc).limit(1)) as first_race_id, (select(driver_season_races.race_id).from(driver_season_races).where(driver_season_races.year = df4.year, driver_season_races.driver_id = df4.driver_id, driver_season_races.date = df4.last_date).orderby(by = driver_season_races.round, desc).limit(1)) as last_race_id, df4.distinct_rounds)\ndf6 = df5.select(first_last_races.year, first_last_races.driver_id, first_last_races.distinct_rounds, (select(results.constructor_id).from(results).where(results.race_id = first_last_races.first_race_id, results.driver_id = first_last_races.driver_id) as first_constructor_id, (select(results.constructor_id).from(results).where(results.race_id = first_last_races.last_race_id, results.driver_id = first_last_races.driver_id) as last_constructor_id)\ndf7 = df6.where(first_last_constructors.first_constructor_id = first_last_constructors.last_constructor_id)\nres = df7.select(first_last_constructors.year, drivers.driver_id, drivers.forename || ' ' || drivers.surname as driver_name, constructors.name as constructor_name, first_last_constructors.distinct_rounds).orderby(by = first_last_constructors.year, drivers.driver_name)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where([MASK], filter = 'BETWEEN 1950 AND 1959')\ndf2 = df.where([MASK], exists = True)\ndf3 = df2.groupby([MASK], [MASK]).having(element = count(distinct([MASK])), filter = '>= 2')\ndf4 = df3.select([MASK], [MASK], min([MASK]) as first_date, max([MASK]) as last_date, count(distinct([MASK])) as distinct_rounds)\ndf5 = df4.groupby([MASK], [MASK]).select([MASK], [MASK], (select([MASK]).from([MASK]).where([MASK] = df4.[MASK], [MASK] = df4.[MASK], [MASK] = df4.first_date).orderby(by = [MASK], asc).limit(1)) as first_race_id, (select([MASK]).from([MASK]).where([MASK] = df4.[MASK], [MASK] = df4.[MASK], [MASK] = df4.last_date).orderby(by = [MASK], desc).limit(1)) as last_race_id, df4.distinct_rounds)\ndf6 = df5.select(first_last_races.[MASK], first_last_races.[MASK], first_last_races.distinct_rounds, (select([MASK]).from([MASK]).where([MASK] = first_last_races.first_race_id, [MASK] = first_last_races.[MASK]) as first_constructor_id, (select([MASK]).from([MASK]).where([MASK] = first_last_races.last_race_id, filter = 'Monday')\nres = df2.select([MASK])\n```"}
{"idx": 133, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.groupby(races.year).agg(max(races.round) as max_round)\ndf2 = df.select(results.driver_id, races.year, races.round).distinct()\ndf3 = df2.orderby(by = races.round).window(partition by = [results.driver_id, races.year], order by = races.round).lead(races.round) as next_round\ndf4 = df3.where(element = next_round, filter = 'is not null').where(element = (next_round - races.round - 1), filter = 'between 1 and 2')\ndf5 = df4.select(races.year, results.driver_id, races.round as prev_round, next_round, (races.round + 1) as first_missed_round, (next_round - 1) as last_missed_round, (next_round - races.round - 1) as races_missed)\ndf6 = df5.where(element = races.year, filter = 'in', df1.max_round)\ndf7 = df6.select(races.year, results.driver_id, first_missed_round, last_missed_round, races_missed, (select results.constructor_id from results where races.race_id = results.race_id and races.year = df6.year and races.round = df6.prev_round and results.driver_id = df6.driver_id limit 1) as constructor_before, (select results.constructor_id from results where races.race_id = results.race_id and races.year = df6.year and races.round = df6.next_round and results.driver_id = df6.driver_id limit 1) as constructor_after)\nres = df7.where(element = constructor_before, filter = 'is not null').where(element = constructor_after, filter = 'is not null').where(element = constructor_before, filter = '<>', constructor_after).avg(first_missed_round, last_missed_round)\n```\n```SR\n[Your Answer]\n```", "response": "```SR\ndf1 = df.groupby([MASK]).agg(max([MASK]) as [MASK])\ndf2 = df.select([MASK], [MASK], [MASK]).distinct()\ndf3 = df2.orderby(by = [MASK]).window(partition by = ([MASK], [MASK]), order by = [MASK]).lead([MASK]) as next_round\ndf4 = df3.where(element = next_round, filter = 'is not null').where(element = (next_round - [MASK] - 1), filter = 'between 1 and 2')\ndf5 = df4.select([MASK], [MASK], [MASK] as prev_round, next_round, ([MASK] + 1) as first_missed_round, (next_round - 1) as last_missed_round, (next_round - [MASK] - 1) as [MASK])\ndf6 = df5.where(element = [MASK], filter = 'in', df1.max_round)\ndf7 = df6.select([MASK], [MASK], first_missed_round, last_missed_round, [MASK], (select [MASK] from [MASK] where [MASK] = [MASK] and [MASK] = df6.[MASK] and [MASK] = df6.[MASK] limit 1) as [MASK], (select [MASK] from [MASK] where [MASK] = [MASK] and [MASK] = df6.[MASK] and [MASK] = df6.[MASK] limit 1) as [MASK])\nres = df7.where(element = [MASK], filter = 'is not null').where(element = [MASK], filter = 'is not null').where(element = [MASK], filter = '<>', [MASK]).avg(first_missed_round, last_missed_round)\n```"}
{"idx": 134, "prompt": "SR is a piece of pandas-like code, which is a intermediate representation between the natural language and SQL. I will provide you a piece of SR that show the logic of the text-to-SQL process in the context of the schema, question and evidence.\nYour task is to mask the schema (related tables and columns) in the SR and only keep the logic template. DO NOT modify the logic in the original SR, just do the mask.\nHere are some examples to help you better understand the task:\n\nHere is an example for you to understand the task\n======================= Example ===========================================\n```Input SR\ndf1 = df.where(element = Business_Hours.business_id, filter = 12)\ndf2 = df1.where(element = Days.day_of_week, filter = 'Monday')\nres = df2.select(Business_Hours.opening_time)\n```\n``` SR\ndf1 = df.where(element = [MASK], filter = 12)\ndf2 = df1.where(element = [MASK], filter = 'Monday')\nres = df2.select([MASK])\n```\n============================================================================\n\nNow mask the schema in the following SR and fill your answer in the template,\n```Input SR\ndf1 = df.where(element = lap_positions.lap_type, filter = 'race').where(element = lap_positions.lap, filter = '> 1')\ndf2 = df1.select(lap_positions.race_id, lap_positions.driver_id, lap_positions.lap, lap_positions.position)\ndf3 = df2.join(element = df2, on = 'lap', join_type = 'previous').select(df2.race_id, df2.driver_id, df2.lap, df2.position as cur_pos, df3.position as prev_pos, df2.position - df3.position as delta)\ndf4 = df3.where(element = pit_stops.race_id, filter = 'is null').where(element = pit_stops.driver_id, filter = 'is null')\ndf5 = df4.where(element = retirements.race_id, filter = 'is null').where(element = retirements.driver_id, filter = 'is null')\ndf6 = df5.select(df5.race_id, df5.driver_id, df5.lap, df5.cur_pos, df5.prev_pos, df5.delta)\ndf7 = df6.groupby(df6.driver_id).agg({'delta': 'sum(case when > 0 then delta else 0 end)', 'delta': 'sum(case when < 0 then -delta else 0 end)'})\ndf8 = df7.select(df7.driver_id, df7['sum(case when > 0 then delta else 0 end)'] as overtakes_made, df7['sum(case when < 0 then -delta else 0 end)'] as overtaken_by)\nres = df8.orderby(by = drivers_ext.full_name).select(drivers_ext.full_name)\n```\n```SR\n[Your Answer]\n```", "response": "```sql\ndf1 = df.where(element = [MASK], filter = 'race').where(element = [MASK], filter = '> 1')\ndf2 = df1.select([MASK].race_id, [MASK].driver_id, [MASK].lap, [MASK].position)\ndf3 = df2.join(element = df2, on = [MASK], join_type = 'previous').select(df2.race_id, df2.driver_id, df2.lap, df2.position as cur_pos, df3.position as prev_pos, df2.position - df3.position as delta)\ndf4 = df3.where(element = [MASK], filter = 'is null').where(element = [MASK], filter = 'is null')\ndf5 = df4.where(element = [MASK], filter = 'is null').where(element = [MASK], filter = 'is null')\ndf6 = df5.select(df5.race_id, df5.driver_id, df5.lap, df5.cur_pos, df5.prev_pos, df5.delta)\ndf7 = df6.groupby(df6.driver_id).agg({'delta': 'sum(case when > 0 then delta else 0 end)', 'delta': 'sum(case when < 0 then -delta else 0 end)'})\ndf8 = df7.select(df7.driver_id, df7['sum(case when > 0 then delta else 0 end)'] as overtakes_made, df7['sum(case when < 0 then -delta else 0 end)'] as overtaken_by)\n```"}
