{
    "13": "WITH striker_match_runs AS (\n  SELECT\n    bbb.striker AS player_id,\n    bbb.match_id,\n    SUM(bs.runs_scored) AS total_runs\n  FROM ball_by_ball AS bbb\n  JOIN batsman_scored AS bs\n    ON bs.match_id = bbb.match_id\n   AND bs.over_id  = bbb.over_id\n   AND bs.ball_id  = bbb.ball_id\n   AND bs.innings_no = bbb.innings_no\n  GROUP BY\n    bbb.striker,\n    bbb.match_id\n),\nqualified_innings AS (\n  SELECT total_runs\n  FROM striker_match_runs\n  WHERE total_runs > 50\n)\nSELECT AVG(total_runs) AS avg_total_runs_over_50\nFROM qualified_innings;\t----- bird -----\tIPL_spider2",
    "14": "WITH player_match_runs AS (\n  SELECT\n    b.match_id,\n    b.striker AS player_id,\n    pm.team_id,\n    SUM(bs.runs_scored) AS runs\n  FROM ball_by_ball b\n  JOIN batsman_scored bs\n    ON bs.match_id = b.match_id\n   AND bs.over_id  = b.over_id\n   AND bs.ball_id  = b.ball_id\n   AND bs.innings_no = b.innings_no\n  JOIN player_match pm\n    ON pm.match_id = b.match_id\n   AND pm.player_id = b.striker\n  GROUP BY b.match_id, b.striker, pm.team_id\n)\nSELECT DISTINCT p.player_name\nFROM player_match_runs r\nJOIN match m\n  ON m.match_id = r.match_id\nJOIN player p\n  ON p.player_id = r.player_id\nWHERE r.runs >= 100\n  AND m.match_winner IS NOT NULL\n  AND r.team_id <> m.match_winner\nORDER BY p.player_name;\t----- bird -----\tIPL_spider2",
    "10": "WITH nxt_matches AS (\n  SELECT\n    m.id AS match_id,\n    m.winner_id,\n    m.loser_id,\n    CAST(substr(m.duration, 1, instr(m.duration, ':') - 1) AS INTEGER) * 60\n      + CAST(substr(m.duration, instr(m.duration, ':') + 1) AS INTEGER) AS duration_seconds\n  FROM Matches m\n  JOIN Belts b\n    ON b.id = CAST(m.title_id AS INTEGER)\n  WHERE b.name = 'NXT Championship'\n    AND COALESCE(m.title_change, 0) = 0\n    AND m.duration IS NOT NULL\n    AND instr(m.duration, ':') > 0\n),\nshortest AS (\n  SELECT *\n  FROM nxt_matches\n  ORDER BY duration_seconds ASC\n  LIMIT 1\n)\nSELECT\n  ww.name AS winner_name,\n  wl.name AS loser_name\nFROM shortest s\nJOIN Wrestlers ww ON ww.id = CAST(s.winner_id AS INTEGER)\nJOIN Wrestlers wl ON wl.id = CAST(s.loser_id AS INTEGER);\t----- bird -----\tWWE_spider2",
    "3": "WITH per_player AS (\n  SELECT\n    player_id,\n    debut,\n    final_game,\n    -- compute absolute differences in Y/M/D using date parts\n    abs(CAST(strftime('%Y', final_game) AS INTEGER) - CAST(strftime('%Y', debut) AS INTEGER)) AS dy,\n    abs(CAST(strftime('%m', final_game) AS INTEGER) - CAST(strftime('%m', debut) AS INTEGER)) AS dm,\n    abs(CAST(strftime('%d', final_game) AS INTEGER) - CAST(strftime('%d', debut) AS INTEGER)) AS dd\n  FROM player\n  WHERE debut IS NOT NULL\n    AND final_game IS NOT NULL\n    AND date(debut) IS NOT NULL\n    AND date(final_game) IS NOT NULL\n),\ncareer_span AS (\n  SELECT\n    player_id,\n    (\n      round(dy * 1.0, 2) +\n      round((dm * 1.0) / 12.0, 2) +\n      round((dd * 1.0) / 365.0, 2)\n    ) AS span_years\n  FROM per_player\n)\nSELECT round(avg(span_years) * 1.0, 2) AS avg_single_career_span_years\nFROM career_span;\t----- bird -----\tBaseball_spider2",
    "2": "WITH order_payments AS (\n  SELECT\n    order_id,\n    SUM(payment_value) AS order_payment\n  FROM olist_order_payments\n  GROUP BY order_id\n),\ncustomer_orders AS (\n  SELECT\n    c.customer_unique_id,\n    o.order_id,\n    DATE(o.order_purchase_timestamp) AS purchase_date,\n    op.order_payment\n  FROM olist_orders o\n  JOIN olist_customers c\n    ON c.customer_id = o.customer_id\n  JOIN order_payments op\n    ON op.order_id = o.order_id\n),\ncustomer_metrics AS (\n  SELECT\n    customer_unique_id,\n    COUNT(DISTINCT order_id) AS num_orders,\n    AVG(order_payment) AS avg_payment_per_order,\n    MIN(purchase_date) AS first_purchase_date,\n    MAX(purchase_date) AS last_purchase_date\n  FROM customer_orders\n  GROUP BY customer_unique_id\n),\nranked AS (\n  SELECT\n    customer_unique_id,\n    num_orders,\n    avg_payment_per_order,\n    CASE\n      WHEN (julianday(last_purchase_date) - julianday(first_purchase_date)) < 7 THEN 1.0\n      ELSE (julianday(last_purchase_date) - julianday(first_purchase_date)) / 7.0\n    END AS lifespan_weeks\n  FROM customer_metrics\n)\nSELECT\n  customer_unique_id,\n  num_orders,\n  avg_payment_per_order,\n  lifespan_weeks\nFROM ranked\nORDER BY avg_payment_per_order DESC\nLIMIT 3;\t----- bird -----\tBrazilian_E_Commerce_spider2",
    "8": "WITH yearly_cause_counts AS (\n  SELECT\n    ci.db_year AS year,\n    c.primary_collision_factor AS cause,\n    COUNT(*) AS cnt\n  FROM collisions c\n  JOIN case_ids ci\n    ON ci.case_id = c.case_id\n  WHERE c.primary_collision_factor IS NOT NULL\n    AND TRIM(c.primary_collision_factor) <> ''\n  GROUP BY ci.db_year, c.primary_collision_factor\n),\nranked AS (\n  SELECT\n    year,\n    cause,\n    cnt,\n    DENSE_RANK() OVER (PARTITION BY year ORDER BY cnt DESC) AS rnk\n  FROM yearly_cause_counts\n),\ntop2 AS (\n  SELECT year, cause, cnt\n  FROM ranked\n  WHERE rnk <= 2\n),\nyear_signatures AS (\n  SELECT\n    year,\n    GROUP_CONCAT(cause, ' | ') AS top2_causes_signature\n  FROM (\n    SELECT year, cause\n    FROM top2\n    ORDER BY year, cause\n  )\n  GROUP BY year\n),\nsignature_counts AS (\n  SELECT\n    top2_causes_signature,\n    COUNT(*) AS years_with_signature\n  FROM year_signatures\n  GROUP BY top2_causes_signature\n)\nSELECT\n  ys.year,\n  ys.top2_causes_signature\nFROM year_signatures ys\nJOIN signature_counts sc\n  ON sc.top2_causes_signature = ys.top2_causes_signature\nWHERE sc.years_with_signature = 1\nORDER BY ys.year;\t----- bird -----\tCalifornia_Traffic_Collision_spider2",
    "9": "WITH collisions_with_year AS (\n  SELECT\n    c.case_id,\n    ci.db_year,\n    c.pcf_violation_category\n  FROM collisions c\n  JOIN case_ids ci\n    ON ci.case_id = c.case_id\n  WHERE ci.db_year IN (2011, 2021)\n    AND c.pcf_violation_category IS NOT NULL\n    AND TRIM(c.pcf_violation_category) <> ''\n),\ntop_category_2021 AS (\n  SELECT pcf_violation_category\n  FROM collisions_with_year\n  WHERE db_year = 2021\n  GROUP BY pcf_violation_category\n  ORDER BY COUNT(*) DESC\n  LIMIT 1\n),\nshares AS (\n  SELECT\n    cwy.db_year,\n    100.0 * SUM(CASE WHEN cwy.pcf_violation_category = tc.pcf_violation_category THEN 1 ELSE 0 END)\n          / COUNT(*) AS share_pct\n  FROM collisions_with_year cwy\n  CROSS JOIN top_category_2021 tc\n  GROUP BY cwy.db_year\n)\nSELECT\n  (SELECT share_pct FROM shares WHERE db_year = 2011)\n  - (SELECT share_pct FROM shares WHERE db_year = 2021) AS decrease_percentage_points;\t----- bird -----\tCalifornia_Traffic_Collision_spider2",
    "4": "WITH player_totals AS (\n  SELECT\n    b.player_id,\n    SUM(COALESCE(b.g, 0))  AS games_played,\n    SUM(COALESCE(b.r, 0))  AS runs,\n    SUM(COALESCE(b.h, 0))  AS hits,\n    SUM(COALESCE(b.hr, 0)) AS home_runs\n  FROM batting b\n  GROUP BY b.player_id\n),\nmax_vals AS (\n  SELECT\n    MAX(games_played) AS max_games_played,\n    MAX(runs)         AS max_runs,\n    MAX(hits)         AS max_hits,\n    MAX(home_runs)    AS max_home_runs\n  FROM player_totals\n)\nSELECT\n  p.name_given,\n  'games_played' AS category,\n  pt.games_played AS value\nFROM player_totals pt\nJOIN max_vals mv\nJOIN player p ON p.player_id = pt.player_id\nWHERE pt.games_played = mv.max_games_played\n\nUNION ALL\n\nSELECT\n  p.name_given,\n  'runs' AS category,\n  pt.runs AS value\nFROM player_totals pt\nJOIN max_vals mv\nJOIN player p ON p.player_id = pt.player_id\nWHERE pt.runs = mv.max_runs\n\nUNION ALL\n\nSELECT\n  p.name_given,\n  'hits' AS category,\n  pt.hits AS value\nFROM player_totals pt\nJOIN max_vals mv\nJOIN player p ON p.player_id = pt.player_id\nWHERE pt.hits = mv.max_hits\n\nUNION ALL\n\nSELECT\n  p.name_given,\n  'home_runs' AS category,\n  pt.home_runs AS value\nFROM player_totals pt\nJOIN max_vals mv\nJOIN player p ON p.player_id = pt.player_id\nWHERE pt.home_runs = mv.max_home_runs\nORDER BY category, name_given;\t----- bird -----\tBaseball_spider2",
    "12": "WITH runs_conceded AS (\n  SELECT\n    bbb.bowler AS bowler_id,\n    SUM(COALESCE(bs.runs_scored, 0) + COALESCE(er.extra_runs, 0)) AS runs_conceded\n  FROM ball_by_ball bbb\n  LEFT JOIN batsman_scored bs\n    ON bs.match_id = bbb.match_id\n   AND bs.innings_no = bbb.innings_no\n   AND bs.over_id = bbb.over_id\n   AND bs.ball_id = bbb.ball_id\n  LEFT JOIN extra_runs er\n    ON er.match_id = bbb.match_id\n   AND er.innings_no = bbb.innings_no\n   AND er.over_id = bbb.over_id\n   AND er.ball_id = bbb.ball_id\n  GROUP BY bbb.bowler\n),\nwickets AS (\n  SELECT\n    bbb.bowler AS bowler_id,\n    COUNT(*) AS wickets\n  FROM wicket_taken wt\n  JOIN ball_by_ball bbb\n    ON bbb.match_id = wt.match_id\n   AND bbb.innings_no = wt.innings_no\n   AND bbb.over_id = wt.over_id\n   AND bbb.ball_id = wt.ball_id\n  WHERE wt.kind_out NOT IN ('run out', 'retired hurt', 'obstructing the field')\n  GROUP BY bbb.bowler\n)\nSELECT\n  p.player_id AS bowler_id,\n  p.player_name AS bowler_name,\n  ROUND(1.0 * rc.runs_conceded / w.wickets, 2) AS bowling_average,\n  rc.runs_conceded,\n  w.wickets\nFROM wickets w\nJOIN runs_conceded rc\n  ON rc.bowler_id = w.bowler_id\nJOIN player p\n  ON p.player_id = w.bowler_id\nWHERE w.wickets > 0\nORDER BY bowling_average ASC, w.wickets DESC, rc.runs_conceded ASC\nLIMIT 1;\t----- bird -----\tIPL_spider2",
    "15": "WITH season5_matches AS (\n  SELECT match_id\n  FROM match\n  WHERE season_id = 5\n),\nplayer_runs AS (\n  SELECT\n    b.striker AS player_id,\n    SUM(bs.runs_scored) AS total_runs\n  FROM ball_by_ball b\n  JOIN batsman_scored bs\n    ON bs.match_id = b.match_id\n   AND bs.over_id  = b.over_id\n   AND bs.ball_id  = b.ball_id\n   AND bs.innings_no = b.innings_no\n  JOIN season5_matches sm\n    ON sm.match_id = b.match_id\n  GROUP BY b.striker\n),\nplayer_matches AS (\n  SELECT\n    pm.player_id,\n    COUNT(DISTINCT pm.match_id) AS matches_played\n  FROM player_match pm\n  JOIN season5_matches sm\n    ON sm.match_id = pm.match_id\n  GROUP BY pm.player_id\n),\nplayer_dismissals AS (\n  SELECT\n    wt.player_out AS player_id,\n    COUNT(*) AS dismissals\n  FROM wicket_taken wt\n  JOIN season5_matches sm\n    ON sm.match_id = wt.match_id\n  GROUP BY wt.player_out\n)\nSELECT\n  p.player_name,\n  ROUND(1.0 * pr.total_runs / pm.matches_played, 2) AS avg_runs_per_match,\n  ROUND(\n    1.0 * pr.total_runs / NULLIF(COALESCE(pd.dismissals, 0), 0),\n    2\n  ) AS batting_average\nFROM player_runs pr\nJOIN player_matches pm\n  ON pm.player_id = pr.player_id\nJOIN player p\n  ON p.player_id = pr.player_id\nLEFT JOIN player_dismissals pd\n  ON pd.player_id = pr.player_id\nWHERE pm.matches_played > 0\nORDER BY avg_runs_per_match DESC, pr.total_runs DESC\nLIMIT 5;\t----- bird -----\tIPL_spider2",
    "7": "WITH motorcycle_parties AS (\n  SELECT\n    p.case_id,\n    -- classify helmet usage for the party based on either safety equipment field\n    CASE\n      WHEN UPPER(COALESCE(p.party_safety_equipment_1, '')) LIKE '%HELMET%'\n        OR UPPER(COALESCE(p.party_safety_equipment_2, '')) LIKE '%HELMET%'\n      THEN 'helmet'\n      ELSE 'no_helmet'\n    END AS helmet_group\n  FROM parties p\n  WHERE p.party_type IS NOT NULL\n    AND UPPER(p.party_type) LIKE '%MOTORCYCLE%'\n),\ncollisions_by_group AS (\n  -- total collisions that have at least one motorcycle party in each helmet group\n  SELECT\n    helmet_group,\n    COUNT(DISTINCT case_id) AS total_collisions\n  FROM motorcycle_parties\n  GROUP BY helmet_group\n),\nmotorcyclist_fatalities_by_group AS (\n  -- total motorcyclist fatalities in collisions that have at least one motorcycle party in each helmet group\n  SELECT\n    mp.helmet_group,\n    SUM(COALESCE(c.motorcyclist_killed_count, 0)) AS motorcyclist_fatalities\n  FROM (SELECT DISTINCT case_id, helmet_group FROM motorcycle_parties) mp\n  JOIN collisions c\n    ON c.case_id = mp.case_id\n  GROUP BY mp.helmet_group\n)\nSELECT\n  cbg.helmet_group,\n  cbg.total_collisions,\n  mfg.motorcyclist_fatalities,\n  ROUND(100.0 * mfg.motorcyclist_fatalities / NULLIF(cbg.total_collisions, 0), 2) AS fatality_rate_percent\nFROM collisions_by_group cbg\nJOIN motorcyclist_fatalities_by_group mfg\n  ON mfg.helmet_group = cbg.helmet_group\nORDER BY\n  CASE cbg.helmet_group WHEN 'helmet' THEN 1 ELSE 2 END;\t----- bird -----\tCalifornia_Traffic_Collision_spider2",
    "6": "WITH flight_distances AS (\n  SELECT\n    CASE WHEN ad.city < aa.city THEN ad.city ELSE aa.city END AS city1,\n    CASE WHEN ad.city < aa.city THEN aa.city ELSE ad.city END AS city2,\n    2.0 * 6371.0 * asin(\n      sqrt(\n        pow(sin(((aa.coordinates[1] - ad.coordinates[1]) * pi() / 180.0) / 2.0), 2) +\n        cos(ad.coordinates[1] * pi() / 180.0) * cos(aa.coordinates[1] * pi() / 180.0) *\n        pow(sin(((aa.coordinates[0] - ad.coordinates[0]) * pi() / 180.0) / 2.0), 2)\n      )\n    ) AS dist_km\n  FROM flights f\n  JOIN airports_data ad ON ad.airport_code = f.departure_airport\n  JOIN airports_data aa ON aa.airport_code = f.arrival_airport\n  WHERE ad.city IS NOT NULL\n    AND aa.city IS NOT NULL\n    AND ad.city <> aa.city\n),\navg_citypair_distance AS (\n  SELECT\n    city1,\n    city2,\n    AVG(dist_km) AS avg_dist_km\n  FROM flight_distances\n  GROUP BY city1, city2\n),\nbinned AS (\n  SELECT\n    CASE\n      WHEN avg_dist_km < 1000 THEN '0-999'\n      WHEN avg_dist_km < 2000 THEN '1000-1999'\n      WHEN avg_dist_km < 3000 THEN '2000-2999'\n      WHEN avg_dist_km < 4000 THEN '3000-3999'\n      WHEN avg_dist_km < 5000 THEN '4000-4999'\n      WHEN avg_dist_km < 6000 THEN '5000-5999'\n      ELSE '6000+'\n    END AS dist_range,\n    COUNT(*) AS pair_cnt\n  FROM avg_citypair_distance\n  GROUP BY dist_range\n)\nSELECT pair_cnt\nFROM binned\nORDER BY pair_cnt ASC\nLIMIT 1;\t----- bird -----\tAirlines_spider2",
    "18": "WITH delivered AS (\n  SELECT\n    CAST(strftime('%Y', order_purchase_timestamp) AS INTEGER) AS yr,\n    CAST(strftime('%m', order_purchase_timestamp) AS INTEGER) AS mon,\n    order_id\n  FROM olist_orders\n  WHERE order_status = 'delivered'\n    AND strftime('%Y', order_purchase_timestamp) IN ('2016','2017','2018')\n),\nmonths(mon) AS (\n  VALUES (1),(2),(3),(4),(5),(6),(7),(8),(9),(10),(11),(12)\n)\nSELECT\n  printf('%02d', m.mon) AS month,\n  COALESCE(SUM(CASE WHEN d.yr = 2016 THEN 1 ELSE 0 END), 0) AS orders_2016,\n  COALESCE(SUM(CASE WHEN d.yr = 2017 THEN 1 ELSE 0 END), 0) AS orders_2017,\n  COALESCE(SUM(CASE WHEN d.yr = 2018 THEN 1 ELSE 0 END), 0) AS orders_2018\nFROM months m\nLEFT JOIN delivered d\n  ON d.mon = m.mon\nGROUP BY m.mon\nORDER BY m.mon;\t----- bird -----\tBrazilian_E_Commerce_spider2",
    "5": "WITH flight_cities AS (\n  SELECT\n    dep.city AS from_city,\n    arr.city AS to_city,\n    CAST(trim(replace(replace(dep.coordinates, '(', ''), ')', ''), ' ') AS TEXT) AS dep_coord_txt,\n    CAST(trim(replace(replace(arr.coordinates, '(', ''), ')', ''), ' ') AS TEXT) AS arr_coord_txt\n  FROM flights f\n  JOIN airports_data dep ON dep.airport_code = f.departure_airport\n  JOIN airports_data arr ON arr.airport_code = f.arrival_airport\n  WHERE dep.city = 'Abakan' OR arr.city = 'Abakan'\n),\ncoords AS (\n  SELECT\n    from_city,\n    to_city,\n    -- coordinates stored as \"(lon,lat)\" -> extract lon/lat as REAL\n    CAST(substr(dep_coord_txt, 1, instr(dep_coord_txt, ',') - 1) AS REAL) AS lon1_deg,\n    CAST(substr(dep_coord_txt, instr(dep_coord_txt, ',') + 1) AS REAL) AS lat1_deg,\n    CAST(substr(arr_coord_txt, 1, instr(arr_coord_txt, ',') - 1) AS REAL) AS lon2_deg,\n    CAST(substr(arr_coord_txt, instr(arr_coord_txt, ',') + 1) AS REAL) AS lat2_deg\n  FROM flight_cities\n),\ndistances AS (\n  SELECT\n    CASE WHEN from_city < to_city THEN from_city ELSE to_city END AS city1,\n    CASE WHEN from_city < to_city THEN to_city ELSE from_city END AS city2,\n    2.0 * 6371.0 * asin(\n      sqrt(\n        pow(sin(((lat2_deg - lat1_deg) * pi() / 180.0) / 2.0), 2) +\n        cos(lat1_deg * pi() / 180.0) * cos(lat2_deg * pi() / 180.0) *\n        pow(sin(((lon2_deg - lon1_deg) * pi() / 180.0) / 2.0), 2)\n      )\n    ) AS distance_km\n  FROM coords\n),\nroute_avg AS (\n  SELECT\n    city1,\n    city2,\n    AVG(distance_km) AS avg_distance_km\n  FROM distances\n  GROUP BY city1, city2\n)\nSELECT MAX(avg_distance_km) AS longest_route_km\nFROM route_avg;\t----- bird -----\tAirlines_spider2",
    "21": "WITH city_totals AS (\n  SELECT\n    c.customer_city AS city,\n    SUM(op.payment_value) AS total_payments,\n    COUNT(DISTINCT o.order_id) AS delivered_order_count\n  FROM olist_orders o\n  JOIN olist_customers c\n    ON c.customer_id = o.customer_id\n  JOIN olist_order_payments op\n    ON op.order_id = o.order_id\n  WHERE o.order_status = 'delivered'\n  GROUP BY c.customer_city\n),\nbottom_five AS (\n  SELECT\n    city,\n    total_payments,\n    delivered_order_count\n  FROM city_totals\n  ORDER BY total_payments ASC\n  LIMIT 5\n)\nSELECT\n  AVG(total_payments) AS avg_total_payments_among_bottom_5_cities,\n  AVG(delivered_order_count) AS avg_delivered_order_count_among_bottom_5_cities\nFROM bottom_five;\t----- bird -----\tBrazilian_E_Commerce_spider2",
    "23": "WITH payments_by_category_method AS (\n  SELECT\n    p.product_category_name,\n    op.payment_type,\n    COUNT(*) AS payment_cnt\n  FROM olist_order_items oi\n  JOIN olist_products p\n    ON p.product_id = oi.product_id\n  JOIN olist_order_payments op\n    ON op.order_id = oi.order_id\n  GROUP BY\n    p.product_category_name,\n    op.payment_type\n),\nranked AS (\n  SELECT\n    product_category_name,\n    payment_type,\n    payment_cnt,\n    RANK() OVER (\n      PARTITION BY product_category_name\n      ORDER BY payment_cnt DESC\n    ) AS rnk\n  FROM payments_by_category_method\n)\nSELECT\n  AVG(payment_cnt) AS avg_total_payments_using_most_preferred_method_per_category\nFROM ranked\nWHERE rnk = 1;\t----- bird -----\tBrazilian_E_Commerce_spider2",
    "16": "WITH player_match_runs AS (\n  -- Runs scored by each player in each match (as striker)\n  SELECT\n    b.match_id,\n    b.striker AS player_id,\n    SUM(bs.runs_scored) AS runs_in_match\n  FROM ball_by_ball b\n  JOIN batsman_scored bs\n    ON bs.match_id = b.match_id\n   AND bs.over_id  = b.over_id\n   AND bs.ball_id  = b.ball_id\n   AND bs.innings_no = b.innings_no\n  GROUP BY b.match_id, b.striker\n),\nplayer_avg AS (\n  -- Each player's average runs per match across all matches they played\n  SELECT\n    pmr.player_id,\n    AVG(pmr.runs_in_match * 1.0) AS avg_runs_per_match\n  FROM player_match_runs pmr\n  GROUP BY pmr.player_id\n),\ncountry_avg AS (\n  -- Average of player averages per country\n  SELECT\n    p.country_name,\n    AVG(pa.avg_runs_per_match) AS country_batting_average\n  FROM player_avg pa\n  JOIN player p\n    ON p.player_id = pa.player_id\n  WHERE p.country_name IS NOT NULL\n    AND TRIM(p.country_name) <> ''\n  GROUP BY p.country_name\n)\nSELECT\n  country_name,\n  country_batting_average\nFROM country_avg\nORDER BY country_batting_average DESC\nLIMIT 5;\t----- bird -----\tIPL_spider2",
    "19": "WITH delivered AS (\n  SELECT\n    CAST(strftime('%Y', order_delivered_customer_date) AS INTEGER) AS yr,\n    CAST(strftime('%m', order_delivered_customer_date) AS INTEGER) AS mo,\n    COUNT(*) AS delivered_orders\n  FROM olist_orders\n  WHERE order_status = 'delivered'\n    AND order_delivered_customer_date IS NOT NULL\n    AND CAST(strftime('%Y', order_delivered_customer_date) AS INTEGER) IN (2016, 2017, 2018)\n  GROUP BY yr, mo\n),\nannual AS (\n  SELECT\n    yr,\n    SUM(delivered_orders) AS annual_delivered_orders\n  FROM delivered\n  GROUP BY yr\n),\nlowest_year AS (\n  SELECT yr\n  FROM annual\n  ORDER BY annual_delivered_orders ASC\n  LIMIT 1\n)\nSELECT\n  MAX(d.delivered_orders) AS highest_monthly_delivered_orders_volume\nFROM delivered d\nJOIN lowest_year ly ON ly.yr = d.yr;\t----- bird -----\tBrazilian_E_Commerce_spider2",
    "11": "WITH over_runs AS (\n  SELECT\n    b.match_id,\n    b.innings_no,\n    b.over_id,\n    b.bowler,\n    COALESCE(SUM(bs.runs_scored), 0) AS bat_runs,\n    COALESCE(SUM(er.extra_runs), 0) AS extra_runs,\n    COALESCE(SUM(bs.runs_scored), 0) + COALESCE(SUM(er.extra_runs), 0) AS runs_conceded\n  FROM ball_by_ball b\n  LEFT JOIN batsman_scored bs\n    ON bs.match_id = b.match_id\n   AND bs.innings_no = b.innings_no\n   AND bs.over_id = b.over_id\n   AND bs.ball_id = b.ball_id\n  LEFT JOIN extra_runs er\n    ON er.match_id = b.match_id\n   AND er.innings_no = b.innings_no\n   AND er.over_id = b.over_id\n   AND er.ball_id = b.ball_id\n  GROUP BY\n    b.match_id, b.innings_no, b.over_id, b.bowler\n),\nmatch_max_over AS (\n  SELECT\n    match_id,\n    MAX(runs_conceded) AS match_max_runs\n  FROM over_runs\n  GROUP BY match_id\n),\ncandidate_overs AS (\n  -- Only overs that are the maximum-runs-conceded over(s) within each match\n  SELECT\n    o.match_id,\n    o.innings_no,\n    o.over_id,\n    o.bowler,\n    o.runs_conceded\n  FROM over_runs o\n  JOIN match_max_over m\n    ON m.match_id = o.match_id\n   AND m.match_max_runs = o.runs_conceded\n),\nbowler_best AS (\n  -- For each bowler, their worst (max) such over across all matches\n  SELECT\n    bowler,\n    MAX(runs_conceded) AS bowler_max_runs\n  FROM candidate_overs\n  GROUP BY bowler\n),\nbowler_best_match AS (\n  -- Pick one match/over for that bowler_max_runs (tie-broken by earliest match_id/innings/over)\n  SELECT\n    co.bowler,\n    co.match_id,\n    co.innings_no,\n    co.over_id,\n    co.runs_conceded,\n    ROW_NUMBER() OVER (\n      PARTITION BY co.bowler\n      ORDER BY co.runs_conceded DESC, co.match_id, co.innings_no, co.over_id\n    ) AS rn\n  FROM candidate_overs co\n  JOIN bowler_best bb\n    ON bb.bowler = co.bowler\n   AND bb.bowler_max_runs = co.runs_conceded\n)\nSELECT\n  p.player_name AS bowler_name,\n  bbm.runs_conceded AS max_runs_in_over,\n  bbm.match_id,\n  bbm.innings_no,\n  bbm.over_id\nFROM bowler_best_match bbm\nJOIN player p\n  ON p.player_id = bbm.bowler\nWHERE bbm.rn = 1\nORDER BY\n  max_runs_in_over DESC,\n  bowler_name\nLIMIT 3;\t----- bird -----\tIPL_spider2",
    "20": "WITH delivered_orders AS (\n  SELECT\n    c.customer_unique_id,\n    c.customer_city,\n    c.customer_state,\n    o.order_id\n  FROM olist_orders o\n  JOIN olist_customers c\n    ON c.customer_id = o.customer_id\n  WHERE o.order_status = 'delivered'\n),\norder_payments AS (\n  SELECT\n    order_id,\n    SUM(payment_value) AS order_payment_value\n  FROM olist_order_payments\n  GROUP BY order_id\n),\ncustomer_agg AS (\n  SELECT\n    d.customer_unique_id,\n    d.customer_city AS city,\n    d.customer_state AS state,\n    COUNT(DISTINCT d.order_id) AS delivered_orders_count,\n    AVG(COALESCE(p.order_payment_value, 0)) AS avg_payment_value\n  FROM delivered_orders d\n  LEFT JOIN order_payments p\n    ON p.order_id = d.order_id\n  GROUP BY\n    d.customer_unique_id,\n    d.customer_city,\n    d.customer_state\n)\nSELECT\n  customer_unique_id,\n  delivered_orders_count,\n  avg_payment_value,\n  city,\n  state\nFROM customer_agg\nORDER BY delivered_orders_count DESC, avg_payment_value DESC\nLIMIT 3;\t----- bird -----\tBrazilian_E_Commerce_spider2",
    "26": "SELECT\n  a.first_name || ' ' || a.last_name AS actor_full_name\nFROM actor AS a\nJOIN film_actor AS fa\n  ON fa.actor_id = a.actor_id\nJOIN film AS f\n  ON f.film_id = fa.film_id\nJOIN language AS l\n  ON l.language_id = f.language_id\nJOIN film_category AS fc\n  ON fc.film_id = f.film_id\nJOIN category AS c\n  ON c.category_id = fc.category_id\nWHERE l.name = 'English'\n  AND c.name = 'Children'\n  AND f.rating IN ('G', 'PG')\n  AND f.length <= 120\n  AND CAST(f.release_year AS INTEGER) BETWEEN 2000 AND 2010\nGROUP BY a.actor_id, a.first_name, a.last_name\nORDER BY COUNT(DISTINCT f.film_id) DESC\nLIMIT 1;\t----- bird -----\tPagila_spider2",
    "0": "WITH daily_sales AS (\n  SELECT\n    date(o.order_purchase_timestamp) AS d,\n    SUM(oi.price) AS sales\n  FROM olist_orders o\n  JOIN olist_order_items oi ON oi.order_id = o.order_id\n  JOIN olist_products p ON p.product_id = oi.product_id\n  JOIN product_category_name_translation t\n    ON t.product_category_name = p.product_category_name\n  WHERE t.product_category_name_english = 'toys'\n    AND date(o.order_purchase_timestamp) BETWEEN date('2017-01-01') AND date('2018-08-29')\n  GROUP BY date(o.order_purchase_timestamp)\n),\nbounds AS (\n  SELECT MIN(d) AS min_d, MAX(d) AS max_d FROM daily_sales\n),\ncalendar(d) AS (\n  SELECT min_d FROM bounds\n  UNION ALL\n  SELECT date(d, '+1 day')\n  FROM calendar, bounds\n  WHERE d < max_d\n),\nseries AS (\n  -- fill missing days with 0 sales to get a true daily series\n  SELECT\n    c.d,\n    COALESCE(ds.sales, 0.0) AS sales\n  FROM calendar c\n  LEFT JOIN daily_sales ds ON ds.d = c.d\n),\nreg_prep AS (\n  SELECT\n    d,\n    sales,\n    (julianday(d) - julianday('2017-01-01')) AS x\n  FROM series\n),\nreg AS (\n  SELECT\n    COUNT(*) AS n,\n    SUM(x) AS sum_x,\n    SUM(sales) AS sum_y,\n    SUM(x * x) AS sum_x2,\n    SUM(x * sales) AS sum_xy\n  FROM reg_prep\n),\ncoef AS (\n  SELECT\n    -- slope b and intercept a for y = a + b*x\n    (n * sum_xy - sum_x * sum_y) * 1.0 / NULLIF((n * sum_x2 - sum_x * sum_x), 0) AS b,\n    (sum_y - ((n * sum_xy - sum_x * sum_y) * 1.0 / NULLIF((n * sum_x2 - sum_x * sum_x), 0)) * sum_x) * 1.0 / n AS a\n  FROM reg\n),\npred_dates AS (\n  SELECT date('2018-12-03') AS d\n  UNION ALL SELECT date('2018-12-04')\n  UNION ALL SELECT date('2018-12-05')\n  UNION ALL SELECT date('2018-12-06')\n  UNION ALL SELECT date('2018-12-07')\n  UNION ALL SELECT date('2018-12-08')\n  UNION ALL SELECT date('2018-12-09')\n  UNION ALL SELECT date('2018-12-10')\n),\npred AS (\n  SELECT\n    pd.d,\n    (julianday(pd.d) - julianday('2017-01-01')) AS x,\n    (c.a + c.b * (julianday(pd.d) - julianday('2017-01-01'))) AS yhat\n  FROM pred_dates pd\n  CROSS JOIN coef c\n),\nma5 AS (\n  SELECT\n    d,\n    AVG(yhat) OVER (ORDER BY d ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING) AS ma5\n  FROM pred\n)\nSELECT\n  SUM(ma5) AS sum_of_5day_symmetric_moving_averages\nFROM ma5\nWHERE d BETWEEN date('2018-12-05') AND date('2018-12-08');\t----- bird -----\tBrazilian_E_Commerce_spider2",
    "24": "WITH category_payment_counts AS (\n  SELECT\n    COALESCE(t.product_category_name_english, p.product_category_name) AS category,\n    pay.payment_type,\n    COUNT(*) AS payment_count\n  FROM olist_order_items oi\n  JOIN olist_products p\n    ON p.product_id = oi.product_id\n  LEFT JOIN product_category_name_translation t\n    ON t.product_category_name = p.product_category_name\n  JOIN olist_order_payments pay\n    ON pay.order_id = oi.order_id\n  GROUP BY\n    COALESCE(t.product_category_name_english, p.product_category_name),\n    pay.payment_type\n),\ncategory_top_payment AS (\n  SELECT\n    category,\n    payment_type,\n    payment_count,\n    ROW_NUMBER() OVER (\n      PARTITION BY category\n      ORDER BY payment_count DESC, payment_type\n    ) AS rn\n  FROM category_payment_counts\n),\ncategory_mode_payment AS (\n  SELECT\n    category,\n    payment_type AS most_common_payment_type,\n    payment_count AS payments_using_most_common_type\n  FROM category_top_payment\n  WHERE rn = 1\n)\nSELECT\n  category,\n  most_common_payment_type,\n  payments_using_most_common_type\nFROM category_mode_payment\nORDER BY payments_using_most_common_type DESC, category\nLIMIT 3;\t----- bird -----\tBrazilian_E_Commerce_spider2",
    "29": "SELECT\n  ROUND(\n    100.0 * SUM(CASE WHEN health = 'Good' THEN 1 ELSE 0 END) / COUNT(*),\n    2\n  ) AS pct_good_health_bronx\nFROM trees\nWHERE boroname = 'Bronx'\n  AND health IS NOT NULL;\t----- bird -----\tmodern_data_spider2",
    "22": "WITH delivered_items AS (\n  SELECT\n    oi.seller_id,\n    oi.order_id,\n    o.customer_id,\n    (oi.price - oi.freight_value) AS profit\n  FROM olist_order_items oi\n  JOIN olist_orders o\n    ON o.order_id = oi.order_id\n  WHERE o.order_status = 'delivered'\n),\ndelivered_items_with_unique AS (\n  SELECT\n    di.seller_id,\n    di.order_id,\n    c.customer_unique_id,\n    di.profit\n  FROM delivered_items di\n  JOIN olist_customers c\n    ON c.customer_id = di.customer_id\n),\nseller_metrics AS (\n  SELECT\n    seller_id,\n    COUNT(DISTINCT customer_unique_id) AS distinct_customer_unique_ids,\n    SUM(profit) AS total_profit,\n    COUNT(DISTINCT order_id) AS distinct_orders\n  FROM delivered_items_with_unique\n  GROUP BY seller_id\n),\nseller_5star AS (\n  SELECT\n    oi.seller_id,\n    COUNT(DISTINCT oi.order_id) AS five_star_orders\n  FROM olist_order_items oi\n  JOIN olist_orders o\n    ON o.order_id = oi.order_id\n  JOIN olist_order_reviews r\n    ON r.order_id = oi.order_id\n  WHERE o.order_status = 'delivered'\n    AND r.review_score = 5\n  GROUP BY oi.seller_id\n)\nSELECT\n  'Highest number of distinct customer unique IDs (delivered orders)' AS achievement,\n  seller_id,\n  distinct_customer_unique_ids AS value\nFROM seller_metrics\nORDER BY distinct_customer_unique_ids DESC, seller_id\nLIMIT 1\n\nUNION ALL\n\nSELECT\n  'Highest profit = SUM(price - freight_value) (delivered orders)' AS achievement,\n  seller_id,\n  total_profit AS value\nFROM seller_metrics\nORDER BY total_profit DESC, seller_id\nLIMIT 1\n\nUNION ALL\n\nSELECT\n  'Highest number of distinct orders (delivered orders)' AS achievement,\n  seller_id,\n  distinct_orders AS value\nFROM seller_metrics\nORDER BY distinct_orders DESC, seller_id\nLIMIT 1\n\nUNION ALL\n\nSELECT\n  'Most 5-star rated orders (delivered orders)' AS achievement,\n  seller_id,\n  five_star_orders AS value\nFROM seller_5star\nORDER BY five_star_orders DESC, seller_id\nLIMIT 1;\t----- bird -----\tBrazilian_E_Commerce_spider2",
    "28": "WITH trees_zip_filled AS (\n  SELECT\n    t.*,\n    COALESCE(\n      NULLIF(t.zipcode, 0),\n      CAST(SUBSTR(t.address, -5) AS INTEGER)\n    ) AS zipcode_filled\n  FROM trees t\n),\ntrees_income AS (\n  SELECT\n    tzf.boroname,\n    it.Estimate_Median_income,\n    it.Estimate_Mean_income\n  FROM trees_zip_filled tzf\n  JOIN income_trees it\n    ON it.zipcode = tzf.zipcode_filled\n  WHERE tzf.boroname IS NOT NULL\n    AND TRIM(tzf.boroname) <> ''\n    AND it.Estimate_Median_income > 0\n    AND it.Estimate_Mean_income > 0\n)\nSELECT\n  boroname,\n  COUNT(*) AS tree_count,\n  AVG(Estimate_Mean_income) AS avg_mean_income\nFROM trees_income\nGROUP BY boroname\nORDER BY tree_count DESC\nLIMIT 3;\t----- bird -----\tmodern_data_spider2",
    "17": "WITH per_ball_runs AS (\n  SELECT\n    b.match_id,\n    b.innings_no,\n    b.over_id,\n    b.ball_id,\n    b.bowler,\n    COALESCE(bs.runs_scored, 0) AS bat_runs,\n    COALESCE(er.extra_runs, 0)  AS ex_runs\n  FROM ball_by_ball b\n  LEFT JOIN batsman_scored bs\n    ON bs.match_id = b.match_id\n   AND bs.innings_no = b.innings_no\n   AND bs.over_id = b.over_id\n   AND bs.ball_id = b.ball_id\n  LEFT JOIN extra_runs er\n    ON er.match_id = b.match_id\n   AND er.innings_no = b.innings_no\n   AND er.over_id = b.over_id\n   AND er.ball_id = b.ball_id\n),\nover_totals AS (\n  SELECT\n    match_id,\n    innings_no,\n    over_id,\n    bowler,\n    SUM(bat_runs + ex_runs) AS over_total_runs\n  FROM per_ball_runs\n  GROUP BY match_id, innings_no, over_id, bowler\n),\nranked_overs AS (\n  SELECT\n    ot.*,\n    ROW_NUMBER() OVER (\n      PARTITION BY ot.match_id\n      ORDER BY ot.over_total_runs DESC, ot.innings_no ASC, ot.over_id ASC\n    ) AS rn\n  FROM over_totals ot\n),\nmatch_best_over AS (\n  SELECT\n    match_id,\n    innings_no,\n    over_id,\n    bowler,\n    over_total_runs\n  FROM ranked_overs\n  WHERE rn = 1\n)\nSELECT\n  mbo.match_id,\n  mbo.innings_no,\n  mbo.over_id,\n  mbo.bowler AS bowler_id,\n  p.player_name AS bowler_name,\n  mbo.over_total_runs AS highest_over_total_runs,\n  AVG(mbo.over_total_runs) OVER () AS avg_highest_over_total_runs_across_matches\nFROM match_best_over mbo\nLEFT JOIN player p\n  ON p.player_id = mbo.bowler\nORDER BY mbo.match_id;\t----- bird -----\tIPL_spider2",
    "27": "WITH city_filter AS (\n  SELECT city_id\n  FROM city\n  WHERE city LIKE 'A%' OR city LIKE '%-%'\n),\nrentals_in_cities AS (\n  SELECT\n    r.rental_id,\n    i.film_id,\n    -- rental hours; if return_date is NULL, treat as 0 hours\n    MAX(\n      0,\n      (julianday(COALESCE(r.return_date, r.rental_date)) - julianday(r.rental_date)) * 24.0\n    ) AS rental_hours\n  FROM rental r\n  JOIN inventory i ON i.inventory_id = r.inventory_id\n  JOIN customer cu ON cu.customer_id = r.customer_id\n  JOIN address a ON a.address_id = cu.address_id\n  JOIN city_filter cf ON cf.city_id = a.city_id\n  GROUP BY r.rental_id, i.film_id\n),\ncategory_hours AS (\n  SELECT\n    c.category_id,\n    c.name AS category_name,\n    SUM(ric.rental_hours) AS total_rental_hours\n  FROM rentals_in_cities ric\n  JOIN film_category fc ON fc.film_id = ric.film_id\n  JOIN category c ON c.category_id = fc.category_id\n  GROUP BY c.category_id, c.name\n)\nSELECT\n  category_name,\n  total_rental_hours\nFROM category_hours\nORDER BY total_rental_hours DESC\nLIMIT 1;\t----- bird -----\tPagila_spider2",
    "30": "WITH top_industry AS (\n  SELECT ci.industry\n  FROM companies_industries ci\n  GROUP BY ci.industry\n  ORDER BY COUNT(DISTINCT ci.company_id) DESC\n  LIMIT 1\n),\nyearly_new_unicorns AS (\n  SELECT\n    CAST(strftime('%Y', cd.date_joined) AS INTEGER) AS join_year,\n    COUNT(DISTINCT cd.company_id) AS new_unicorns\n  FROM companies_dates cd\n  JOIN companies_industries ci\n    ON ci.company_id = cd.company_id\n  WHERE ci.industry = (SELECT industry FROM top_industry)\n    AND CAST(strftime('%Y', cd.date_joined) AS INTEGER) BETWEEN 2019 AND 2021\n  GROUP BY CAST(strftime('%Y', cd.date_joined) AS INTEGER)\n)\nSELECT\n  ROUND(AVG(new_unicorns), 2) AS avg_new_unicorns_per_year_2019_2021,\n  (SELECT industry FROM top_industry) AS top_industry\nFROM yearly_new_unicorns;\t----- bird -----\tmodern_data_spider2",
    "33": "WITH country_customer_counts AS (\n  SELECT\n    Country,\n    COUNT(*) AS customer_count\n  FROM customers\n  GROUP BY Country\n  HAVING COUNT(*) > 4\n),\ncountry_sales AS (\n  SELECT\n    i.BillingCountry AS Country,\n    SUM(i.Total) AS total_sales\n  FROM invoices i\n  JOIN country_customer_counts ccc\n    ON ccc.Country = i.BillingCountry\n  GROUP BY i.BillingCountry\n),\nordered AS (\n  SELECT\n    total_sales,\n    ROW_NUMBER() OVER (ORDER BY total_sales) AS rn,\n    COUNT(*) OVER () AS cnt\n  FROM country_sales\n)\nSELECT\n  AVG(total_sales) AS median_total_sales\nFROM ordered\nWHERE rn IN ( (cnt + 1) / 2, (cnt + 2) / 2 );\t----- bird -----\tchinook_spider2",
    "25": "WITH ordered AS (\n  SELECT\n    geolocation_state,\n    geolocation_city,\n    geolocation_zip_code_prefix,\n    geolocation_lat,\n    geolocation_lng,\n    LAG(geolocation_state) OVER (\n      ORDER BY geolocation_state, geolocation_city, geolocation_zip_code_prefix, geolocation_lat, geolocation_lng\n    ) AS prev_state,\n    LAG(geolocation_city) OVER (\n      ORDER BY geolocation_state, geolocation_city, geolocation_zip_code_prefix, geolocation_lat, geolocation_lng\n    ) AS prev_city,\n    LAG(geolocation_zip_code_prefix) OVER (\n      ORDER BY geolocation_state, geolocation_city, geolocation_zip_code_prefix, geolocation_lat, geolocation_lng\n    ) AS prev_zip,\n    LAG(geolocation_lat) OVER (\n      ORDER BY geolocation_state, geolocation_city, geolocation_zip_code_prefix, geolocation_lat, geolocation_lng\n    ) AS prev_lat,\n    LAG(geolocation_lng) OVER (\n      ORDER BY geolocation_state, geolocation_city, geolocation_zip_code_prefix, geolocation_lat, geolocation_lng\n    ) AS prev_lng\n  FROM olist_geolocation\n),\ndistances AS (\n  SELECT\n    prev_state,\n    prev_city,\n    prev_zip,\n    prev_lat,\n    prev_lng,\n    geolocation_state AS curr_state,\n    geolocation_city  AS curr_city,\n    geolocation_zip_code_prefix AS curr_zip,\n    geolocation_lat   AS curr_lat,\n    geolocation_lng   AS curr_lng,\n    6371.0 * acos(\n      cos(radians(prev_lat)) * cos(radians(curr_lat)) * cos(radians(curr_lng) - radians(prev_lng)) +\n      sin(radians(prev_lat)) * sin(radians(curr_lat))\n    ) AS distance_km\n  FROM ordered\n  WHERE prev_lat IS NOT NULL\n)\nSELECT\n  prev_state, prev_city, prev_zip, prev_lat, prev_lng,\n  curr_state, curr_city, curr_zip, curr_lat, curr_lng,\n  distance_km\nFROM distances\nORDER BY distance_km DESC\nLIMIT 1;\t----- bird -----\tBrazilian_E_Commerce_spider2",
    "31": "WITH artist_sales AS (\n  SELECT\n    ar.ArtistId,\n    ar.Name AS ArtistName,\n    SUM(ii.UnitPrice * ii.Quantity) AS TotalSales\n  FROM artists ar\n  JOIN albums al   ON al.ArtistId = ar.ArtistId\n  JOIN tracks t    ON t.AlbumId = al.AlbumId\n  JOIN invoice_items ii ON ii.TrackId = t.TrackId\n  GROUP BY ar.ArtistId, ar.Name\n),\nbest_selling_artist AS (\n  SELECT ArtistId\n  FROM artist_sales\n  ORDER BY TotalSales DESC\n  LIMIT 1\n),\ncustomer_spend AS (\n  SELECT\n    c.CustomerId,\n    c.FirstName,\n    SUM(ii.UnitPrice * ii.Quantity) AS AmountSpent\n  FROM customers c\n  JOIN invoices i       ON i.CustomerId = c.CustomerId\n  JOIN invoice_items ii ON ii.InvoiceId = i.InvoiceId\n  JOIN tracks t         ON t.TrackId = ii.TrackId\n  JOIN albums al        ON al.AlbumId = t.AlbumId\n  WHERE al.ArtistId = (SELECT ArtistId FROM best_selling_artist)\n  GROUP BY c.CustomerId, c.FirstName\n)\nSELECT\n  FirstName,\n  ROUND(AmountSpent, 2) AS AmountSpent\nFROM customer_spend\nWHERE AmountSpent < 1\nORDER BY AmountSpent ASC, FirstName;\t----- bird -----\tchinook_spider2",
    "34": "WITH monthly_totals AS (\n  SELECT\n    p.customer_id,\n    strftime('%Y-%m', p.payment_date) AS ym,\n    SUM(p.amount) AS monthly_amount\n  FROM payment p\n  GROUP BY p.customer_id, strftime('%Y-%m', p.payment_date)\n),\nmonthly_changes AS (\n  SELECT\n    customer_id,\n    ym,\n    monthly_amount,\n    monthly_amount - LAG(monthly_amount) OVER (\n      PARTITION BY customer_id\n      ORDER BY ym\n    ) AS monthly_change\n  FROM monthly_totals\n),\navg_change AS (\n  SELECT\n    customer_id,\n    AVG(ABS(monthly_change)) AS avg_monthly_change\n  FROM monthly_changes\n  WHERE monthly_change IS NOT NULL\n  GROUP BY customer_id\n)\nSELECT\n  c.first_name || ' ' || c.last_name AS customer_full_name\nFROM avg_change ac\nJOIN customer c ON c.customer_id = ac.customer_id\nORDER BY ac.avg_monthly_change DESC\nLIMIT 1;\t----- bird -----\tsqlite-sakila_spider2",
    "1": "\t----- bird -----\tBrazilian_E_Commerce_spider2",
    "36": "WITH sales_2021 AS (\n  SELECT\n    s.product_code,\n    p.division,\n    SUM(s.sold_quantity) AS total_qty_2021\n  FROM hardware_fact_sales_monthly AS s\n  JOIN hardware_dim_product AS p\n    ON p.product_code = s.product_code\n  WHERE s.date >= '2021-01-01'\n    AND s.date <  '2022-01-01'\n  GROUP BY s.product_code, p.division\n),\nranked AS (\n  SELECT\n    division,\n    product_code,\n    total_qty_2021,\n    DENSE_RANK() OVER (\n      PARTITION BY division\n      ORDER BY total_qty_2021 DESC\n    ) AS rnk\n  FROM sales_2021\n)\nSELECT\n  division,\n  AVG(total_qty_2021) AS avg_qty_sold_top3_products_2021\nFROM ranked\nWHERE rnk <= 3\nGROUP BY division\nORDER BY division;\t----- bird -----\teducation_business_spider2",
    "35": "WITH seg_year AS (\n  SELECT\n    p.segment,\n    s.fiscal_year,\n    COUNT(DISTINCT s.product_code) AS unique_products\n  FROM hardware_fact_sales_monthly s\n  JOIN hardware_dim_product p\n    ON p.product_code = s.product_code\n  WHERE s.fiscal_year IN (2020, 2021)\n  GROUP BY p.segment, s.fiscal_year\n),\nseg_pivot AS (\n  SELECT\n    segment,\n    SUM(CASE WHEN fiscal_year = 2020 THEN unique_products ELSE 0 END) AS unique_products_2020,\n    SUM(CASE WHEN fiscal_year = 2021 THEN unique_products ELSE 0 END) AS unique_products_2021\n  FROM seg_year\n  GROUP BY segment\n)\nSELECT\n  segment,\n  unique_products_2020,\n  unique_products_2021,\n  CASE\n    WHEN unique_products_2020 = 0 THEN NULL\n    ELSE 1.0 * (unique_products_2021 - unique_products_2020) / unique_products_2020\n  END AS pct_increase_unique_products_2020_to_2021\nFROM seg_pivot\nORDER BY\n  pct_increase_unique_products_2020_to_2021 DESC,\n  unique_products_2020 DESC,\n  segment;\t----- bird -----\teducation_business_spider2",
    "42": "WITH dec_sales AS (\n  SELECT\n    s.cust_id,\n    SUM(s.amount_sold - (s.quantity_sold * c.unit_cost)) AS profit\n  FROM sales s\n  JOIN customers cu\n    ON cu.cust_id = s.cust_id\n  JOIN countries co\n    ON co.country_id = cu.country_id\n  JOIN costs c\n    ON c.prod_id = s.prod_id\n   AND c.time_id = s.time_id\n   AND c.promo_id = s.promo_id\n   AND c.channel_id = s.channel_id\n  WHERE co.country_name = 'Italy'\n    AND s.time_id >= '2021-12-01'\n    AND s.time_id <  '2022-01-01'\n  GROUP BY s.cust_id\n),\ntiered AS (\n  SELECT\n    cust_id,\n    profit,\n    NTILE(10) OVER (ORDER BY profit) AS profit_tier\n  FROM dec_sales\n)\nSELECT\n  profit_tier,\n  MIN(profit) AS lowest_profit,\n  MAX(profit) AS highest_profit\nFROM tiered\nGROUP BY profit_tier\nORDER BY profit_tier;\t----- bird -----\tcomplex_oracle_spider2",
    "32": "WITH artist_sales AS (\n  SELECT\n    ar.ArtistId,\n    ar.Name AS ArtistName,\n    SUM(ii.UnitPrice * ii.Quantity) AS Sales\n  FROM artists ar\n  JOIN albums al   ON al.ArtistId = ar.ArtistId\n  JOIN tracks t    ON t.AlbumId = al.AlbumId\n  JOIN invoice_items ii ON ii.TrackId = t.TrackId\n  GROUP BY ar.ArtistId, ar.Name\n),\ntop_artist AS (\n  SELECT ArtistId, ArtistName\n  FROM artist_sales\n  ORDER BY Sales DESC, ArtistName ASC\n  LIMIT 1\n),\nbottom_artist AS (\n  SELECT ArtistId, ArtistName\n  FROM artist_sales\n  ORDER BY Sales ASC, ArtistName ASC\n  LIMIT 1\n),\ncustomer_artist_spend AS (\n  -- Spend per customer on the top-selling artist\n  SELECT\n    i.CustomerId,\n    'TOP' AS which,\n    SUM(ii.UnitPrice * ii.Quantity) AS spend\n  FROM invoices i\n  JOIN invoice_items ii ON ii.InvoiceId = i.InvoiceId\n  JOIN tracks t         ON t.TrackId = ii.TrackId\n  JOIN albums al        ON al.AlbumId = t.AlbumId\n  JOIN top_artist ta    ON ta.ArtistId = al.ArtistId\n  GROUP BY i.CustomerId\n\n  UNION ALL\n\n  -- Spend per customer on the lowest-selling artist\n  SELECT\n    i.CustomerId,\n    'BOTTOM' AS which,\n    SUM(ii.UnitPrice * ii.Quantity) AS spend\n  FROM invoices i\n  JOIN invoice_items ii ON ii.InvoiceId = i.InvoiceId\n  JOIN tracks t         ON t.TrackId = ii.TrackId\n  JOIN albums al        ON al.AlbumId = t.AlbumId\n  JOIN bottom_artist ba ON ba.ArtistId = al.ArtistId\n  GROUP BY i.CustomerId\n),\navg_spend AS (\n  SELECT which, AVG(spend) AS avg_spend\n  FROM customer_artist_spend\n  GROUP BY which\n)\nSELECT\n  ABS(\n    COALESCE((SELECT avg_spend FROM avg_spend WHERE which = 'TOP'), 0.0) -\n    COALESCE((SELECT avg_spend FROM avg_spend WHERE which = 'BOTTOM'), 0.0)\n  ) AS abs_diff_avg_spend\n;\t----- bird -----\tchinook_spider2",
    "41": "WITH cust_profit AS (\n  SELECT\n    s.cust_id,\n    SUM(s.quantity_sold * (c.unit_price - c.unit_cost)) AS total_profit\n  FROM sales s\n  JOIN customers cu\n    ON cu.cust_id = s.cust_id\n  JOIN countries co\n    ON co.country_id = cu.country_id\n  JOIN costs c\n    ON c.prod_id = s.prod_id\n   AND c.time_id = s.time_id\n   AND c.promo_id = s.promo_id\n   AND c.channel_id = s.channel_id\n  WHERE co.country_name = 'Italy'\n    AND s.time_id >= '2021-12-01'\n    AND s.time_id <  '2022-01-01'\n  GROUP BY s.cust_id\n),\nbounds AS (\n  SELECT\n    MIN(total_profit) AS min_profit,\n    MAX(total_profit) AS max_profit\n  FROM cust_profit\n),\nbucketed AS (\n  SELECT\n    cp.cust_id,\n    cp.total_profit,\n    b.min_profit,\n    b.max_profit,\n    CASE\n      WHEN b.max_profit = b.min_profit THEN 1\n      ELSE\n        MIN(\n          10,\n          CAST(\n            ((cp.total_profit - b.min_profit) / ((b.max_profit - b.min_profit) / 10.0)) AS INTEGER\n          ) + 1\n        )\n    END AS bucket\n  FROM cust_profit cp\n  CROSS JOIN bounds b\n)\nSELECT\n  bucket,\n  COUNT(*) AS num_customers,\n  MIN(total_profit) AS bucket_min_total_profit,\n  MAX(total_profit) AS bucket_max_total_profit\nFROM bucketed\nGROUP BY bucket\nORDER BY bucket;\t----- bird -----\tcomplex_oracle_spider2",
    "44": "WITH june_2022 AS (\n  SELECT\n    country_code_2,\n    date(insert_date) AS d\n  FROM cities\n  WHERE insert_date IS NOT NULL\n    AND date(insert_date) >= date('2022-06-01')\n    AND date(insert_date) <  date('2022-07-01')\n  GROUP BY country_code_2, date(insert_date)\n),\nseq AS (\n  SELECT\n    country_code_2,\n    d,\n    julianday(d) - ROW_NUMBER() OVER (PARTITION BY country_code_2 ORDER BY d) AS grp\n  FROM june_2022\n),\nstreaks AS (\n  SELECT\n    country_code_2,\n    COUNT(*) AS streak_len\n  FROM seq\n  GROUP BY country_code_2, grp\n),\nmax_streak AS (\n  SELECT MAX(streak_len) AS max_len\n  FROM streaks\n)\nSELECT s.country_code_2\nFROM streaks s\nJOIN max_streak m\n  ON s.streak_len = m.max_len\nGROUP BY s.country_code_2\nORDER BY s.country_code_2;\t----- bird -----\tcity_legislation_spider2",
    "49": "WITH delivered_orders AS (\n  SELECT co.order_id, co.pizza_id\n  FROM pizza_clean_customer_orders co\n  JOIN pizza_clean_runner_orders ro\n    ON ro.order_id = co.order_id\n  WHERE ro.cancellation IS NULL\n     OR TRIM(ro.cancellation) = ''\n),\nextras_per_order AS (\n  SELECT order_id, SUM(COALESCE(extras_count, 0)) AS extra_cnt\n  FROM pizza_get_extras\n  GROUP BY order_id\n),\npriced_orders AS (\n  SELECT\n    d.order_id,\n    pn.pizza_name,\n    CASE\n      WHEN pn.pizza_name = 'Meatlovers' THEN 12\n      WHEN pn.pizza_name = 'Vegetarian' THEN 10\n      ELSE 0\n    END AS base_price,\n    COALESCE(e.extra_cnt, 0) AS extra_cnt\n  FROM delivered_orders d\n  JOIN pizza_names pn\n    ON pn.pizza_id = d.pizza_id\n  LEFT JOIN extras_per_order e\n    ON e.order_id = d.order_id\n  WHERE pn.pizza_name IN ('Meatlovers', 'Vegetarian')\n)\nSELECT\n  SUM(base_price + extra_cnt * 1) AS total_income\nFROM priced_orders;\t----- bird -----\tmodern_data_spider2",
    "48": "WITH delivered_pizzas AS (\n  SELECT co.order_id, co.pizza_id\n  FROM pizza_clean_customer_orders AS co\n  JOIN pizza_clean_runner_orders  AS ro\n    ON ro.order_id = co.order_id\n  WHERE ro.cancellation IS NULL\n     OR TRIM(ro.cancellation) = ''\n),\nrecipe_toppings AS (\n  -- Expand each pizza's comma-separated topping list into one row per topping_id\n  WITH RECURSIVE split(pizza_id, rest, token) AS (\n    SELECT\n      pr.pizza_id,\n      pr.toppings || ',',\n      ''\n    FROM pizza_recipes AS pr\n\n    UNION ALL\n\n    SELECT\n      pizza_id,\n      SUBSTR(rest, INSTR(rest, ',') + 1),\n      TRIM(SUBSTR(rest, 1, INSTR(rest, ',') - 1))\n    FROM split\n    WHERE rest <> ''\n  )\n  SELECT\n    pizza_id,\n    CAST(token AS INTEGER) AS topping_id\n  FROM split\n  WHERE token <> ''\n)\nSELECT\n  pt.topping_name AS ingredient,\n  COUNT(*) AS quantity_used\nFROM delivered_pizzas AS dp\nJOIN recipe_toppings AS rt\n  ON rt.pizza_id = dp.pizza_id\nJOIN pizza_toppings AS pt\n  ON pt.topping_id = rt.topping_id\nGROUP BY pt.topping_name\nORDER BY quantity_used DESC, ingredient;\t----- bird -----\tmodern_data_spider2",
    "39": "WITH monthly_prod_sales AS (\n  SELECT\n    s.prod_id,\n    t.calendar_year AS yr,\n    t.calendar_month_number AS mo,\n    SUM(s.amount_sold) AS sales_amt\n  FROM sales s\n  JOIN times t       ON t.time_id = s.time_id\n  JOIN customers cu  ON cu.cust_id = s.cust_id\n  JOIN countries co  ON co.country_id = cu.country_id\n  JOIN promotions p  ON p.promo_id = s.promo_id\n  JOIN channels ch   ON ch.channel_id = s.channel_id\n  WHERE co.country_name = 'France'\n    AND t.calendar_year IN (2019, 2020)\n    AND p.promo_total_id = 1\n    AND ch.channel_total_id = 1\n  GROUP BY s.prod_id, t.calendar_year, t.calendar_month_number\n),\nproj_2021_by_prod_month AS (\n  SELECT\n    s20.prod_id,\n    s20.mo,\n    CASE\n      WHEN COALESCE(s19.sales_amt, 0) = 0 THEN s20.sales_amt\n      ELSE\n        (\n          ((s20.sales_amt - s19.sales_amt) * 1.0 / s19.sales_amt) * s20.sales_amt\n        ) + s20.sales_amt\n    END AS projected_2021_amt\n  FROM (SELECT * FROM monthly_prod_sales WHERE yr = 2020) s20\n  LEFT JOIN (SELECT * FROM monthly_prod_sales WHERE yr = 2019) s19\n    ON s19.prod_id = s20.prod_id\n   AND s19.mo = s20.mo\n),\nproj_2021_usd_by_prod_month AS (\n  SELECT\n    p.prod_id,\n    p.mo,\n    p.projected_2021_amt * COALESCE(cur.to_us, 1.0) AS projected_2021_usd\n  FROM proj_2021_by_prod_month p\n  LEFT JOIN currency cur\n    ON cur.country = 'France'\n   AND cur.year = 2021\n   AND cur.month = p.mo\n)\nSELECT\n  mo AS calendar_month_number,\n  ROUND(AVG(projected_2021_usd), 2) AS avg_projected_monthly_sales_usd\nFROM proj_2021_usd_by_prod_month\nGROUP BY mo\nORDER BY mo;\t----- bird -----\tcomplex_oracle_spider2",
    "43": "WITH cn_july_2021 AS (\n  SELECT\n    date(insert_date) AS d,\n    city_name\n  FROM cities\n  WHERE lower(country_code_2) = 'cn'\n    AND date(insert_date) >= '2021-07-01'\n    AND date(insert_date) <  '2021-08-01'\n),\none_row_per_date AS (\n  -- exactly one record per date (pick a deterministic city name per date)\n  SELECT\n    d,\n    MIN(city_name) AS city_name\n  FROM cn_july_2021\n  GROUP BY d\n),\nsequenced AS (\n  SELECT\n    d,\n    city_name,\n    julianday(d) - ROW_NUMBER() OVER (ORDER BY d) AS grp\n  FROM one_row_per_date\n),\nstreaks AS (\n  SELECT\n    grp,\n    MIN(d) AS start_date,\n    MAX(d) AS end_date,\n    COUNT(*) AS streak_len\n  FROM sequenced\n  GROUP BY grp\n),\nextremes AS (\n  SELECT\n    MIN(streak_len) AS min_len,\n    MAX(streak_len) AS max_len\n  FROM streaks\n),\npicked_streaks AS (\n  -- if multiple streaks tie for shortest/longest, pick the earliest one\n  SELECT 'shortest' AS streak_type, s.grp, s.start_date, s.end_date, s.streak_len\n  FROM streaks s\n  JOIN extremes e ON s.streak_len = e.min_len\n  ORDER BY s.start_date\n  LIMIT 1\n\n  UNION ALL\n\n  SELECT 'longest' AS streak_type, s.grp, s.start_date, s.end_date, s.streak_len\n  FROM streaks s\n  JOIN extremes e ON s.streak_len = e.max_len\n  ORDER BY s.start_date\n  LIMIT 1\n)\nSELECT\n  p.streak_type,\n  q.d AS date,\n  upper(substr(q.city_name, 1, 1)) || lower(substr(q.city_name, 2)) AS city_name\nFROM picked_streaks p\nJOIN sequenced q\n  ON q.grp = p.grp\nORDER BY\n  CASE p.streak_type WHEN 'shortest' THEN 1 ELSE 2 END,\n  q.d;\t----- bird -----\tcity_legislation_spider2",
    "46": "WITH monthly_counts AS (\n  SELECT\n    CAST(strftime('%Y', insert_date) AS INTEGER) AS year,\n    CAST(strftime('%m', insert_date) AS INTEGER) AS month_num,\n    strftime('%m', insert_date) AS month,\n    COUNT(*) AS month_total\n  FROM cities\n  WHERE insert_date IS NOT NULL\n    AND CAST(strftime('%Y', insert_date) AS INTEGER) BETWEEN 2021 AND 2023\n    AND CAST(strftime('%m', insert_date) AS INTEGER) IN (4, 5, 6)\n  GROUP BY\n    CAST(strftime('%Y', insert_date) AS INTEGER),\n    CAST(strftime('%m', insert_date) AS INTEGER),\n    strftime('%m', insert_date)\n),\nwith_running AS (\n  SELECT\n    year,\n    month_num,\n    month,\n    month_total,\n    SUM(month_total) OVER (\n      PARTITION BY month_num\n      ORDER BY year\n      ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n    ) AS running_total\n  FROM monthly_counts\n),\nwith_growth AS (\n  SELECT\n    year,\n    month_num,\n    month,\n    month_total,\n    running_total,\n    LAG(month_total) OVER (PARTITION BY month_num ORDER BY year) AS prev_month_total,\n    LAG(running_total) OVER (PARTITION BY month_num ORDER BY year) AS prev_running_total\n  FROM with_running\n)\nSELECT\n  year,\n  CASE month_num\n    WHEN 4 THEN 'April'\n    WHEN 5 THEN 'May'\n    WHEN 6 THEN 'June'\n  END AS month,\n  month_total AS cities_added_in_month,\n  running_total AS cumulative_running_total_for_month,\n  ROUND(\n    100.0 * (month_total - prev_month_total) / NULLIF(prev_month_total, 0),\n    2\n  ) AS yoy_growth_month_total_pct,\n  ROUND(\n    100.0 * (running_total - prev_running_total) / NULLIF(prev_running_total, 0),\n    2\n  ) AS yoy_growth_running_total_pct\nFROM with_growth\nWHERE year IN (2022, 2023)\nORDER BY month_num, year;\t----- bird -----\tcity_legislation_spider2",
    "45": "WITH jan_2022 AS (\n  SELECT\n    cc.country_name,\n    c.city_name,\n    c.capital,\n    date(c.insert_date) AS ins_date\n  FROM cities c\n  JOIN cities_countries cc\n    ON cc.country_code_2 = c.country_code_2\n  WHERE date(c.insert_date) >= '2022-01-01'\n    AND date(c.insert_date) <  '2022-02-01'\n),\ntarget_country AS (\n  SELECT country_name\n  FROM jan_2022\n  GROUP BY country_name\n  HAVING COUNT(DISTINCT ins_date) = 9\n),\ntc_rows AS (\n  SELECT j.*\n  FROM jan_2022 j\n  JOIN target_country t\n    ON t.country_name = j.country_name\n),\ndays AS (\n  SELECT DISTINCT\n    country_name,\n    ins_date\n  FROM tc_rows\n),\nislands AS (\n  SELECT\n    country_name,\n    ins_date,\n    julianday(ins_date) - ROW_NUMBER() OVER (PARTITION BY country_name ORDER BY ins_date) AS grp\n  FROM days\n),\nruns AS (\n  SELECT\n    country_name,\n    MIN(ins_date) AS run_start,\n    MAX(ins_date) AS run_end,\n    COUNT(*) AS consecutive_days\n  FROM islands\n  GROUP BY country_name, grp\n),\nbest_run AS (\n  SELECT\n    country_name,\n    run_start,\n    run_end,\n    consecutive_days\n  FROM (\n    SELECT\n      r.*,\n      ROW_NUMBER() OVER (\n        PARTITION BY country_name\n        ORDER BY consecutive_days DESC, run_start\n      ) AS rn\n    FROM runs r\n  )\n  WHERE rn = 1\n),\nperiod_entries AS (\n  SELECT\n    tr.country_name,\n    br.run_start,\n    br.run_end,\n    br.consecutive_days,\n    tr.city_name,\n    tr.capital\n  FROM tc_rows tr\n  JOIN best_run br\n    ON br.country_name = tr.country_name\n   AND tr.ins_date BETWEEN br.run_start AND br.run_end\n)\nSELECT\n  country_name,\n  run_start,\n  run_end,\n  consecutive_days,\n  SUM(CASE WHEN capital = 1 THEN 1 ELSE 0 END) AS capital_entries,\n  COUNT(*) AS total_entries,\n  1.0 * SUM(CASE WHEN capital = 1 THEN 1 ELSE 0 END) / COUNT(*) AS capital_entry_proportion\nFROM period_entries\nGROUP BY country_name, run_start, run_end, consecutive_days;\t----- bird -----\tcity_legislation_spider2",
    "37": "WITH base_sales AS (\n  SELECT\n    c.cust_city AS city,\n    s.prod_id,\n    t.calendar_year AS yr,\n    t.calendar_quarter_number AS qtr,\n    SUM(s.amount_sold) AS sales_amt\n  FROM sales s\n  JOIN customers c ON c.cust_id = s.cust_id\n  JOIN countries co ON co.country_id = c.country_id\n  JOIN times t ON t.time_id = s.time_id\n  WHERE co.country_name = 'United States'\n    AND s.promo_id IS NULL                 -- exclude promotions\n    AND t.calendar_quarter_number = 4\n    AND t.calendar_year IN (2019, 2020)\n  GROUP BY c.cust_city, s.prod_id, t.calendar_year, t.calendar_quarter_number\n),\ncity_totals AS (\n  SELECT\n    city,\n    SUM(CASE WHEN yr = 2019 THEN sales_amt ELSE 0 END) AS sales_2019_q4,\n    SUM(CASE WHEN yr = 2020 THEN sales_amt ELSE 0 END) AS sales_2020_q4\n  FROM base_sales\n  GROUP BY city\n),\neligible_cities AS (\n  SELECT city\n  FROM city_totals\n  WHERE sales_2019_q4 > 0\n    AND sales_2020_q4 >= 1.2 * sales_2019_q4\n),\nprod_totals_in_eligible AS (\n  SELECT\n    bs.prod_id,\n    SUM(bs.sales_amt) AS sales_both_q4\n  FROM base_sales bs\n  JOIN eligible_cities ec ON ec.city = bs.city\n  GROUP BY bs.prod_id\n),\nranked_products AS (\n  SELECT\n    prod_id,\n    sales_both_q4,\n    PERCENT_RANK() OVER (ORDER BY sales_both_q4 DESC) AS pr\n  FROM prod_totals_in_eligible\n),\ntop_products AS (\n  SELECT prod_id\n  FROM ranked_products\n  WHERE pr <= 0.20\n),\ntop_prod_year_sales AS (\n  SELECT\n    bs.prod_id,\n    bs.yr,\n    SUM(bs.sales_amt) AS prod_sales\n  FROM base_sales bs\n  JOIN eligible_cities ec ON ec.city = bs.city\n  JOIN top_products tp ON tp.prod_id = bs.prod_id\n  GROUP BY bs.prod_id, bs.yr\n),\nyear_totals AS (\n  SELECT\n    bs.yr,\n    SUM(bs.sales_amt) AS total_sales\n  FROM base_sales bs\n  JOIN eligible_cities ec ON ec.city = bs.city\n  GROUP BY bs.yr\n),\nshares AS (\n  SELECT\n    tpys.prod_id,\n    SUM(CASE WHEN tpys.yr = 2019 THEN 1.0 * tpys.prod_sales / yt19.total_sales END) AS share_2019_q4,\n    SUM(CASE WHEN tpys.yr = 2020 THEN 1.0 * tpys.prod_sales / yt20.total_sales END) AS share_2020_q4\n  FROM top_prod_year_sales tpys\n  LEFT JOIN year_totals yt19 ON yt19.yr = 2019\n  LEFT JOIN year_totals yt20 ON yt20.yr = 2020\n  GROUP BY tpys.prod_id\n)\nSELECT\n  p.prod_id,\n  p.prod_name,\n  COALESCE(s.share_2019_q4, 0.0) AS share_q4_2019,\n  COALESCE(s.share_2020_q4, 0.0) AS share_q4_2020,\n  COALESCE(s.share_2020_q4, 0.0) - COALESCE(s.share_2019_q4, 0.0) AS share_change\nFROM shares s\nJOIN products p ON p.prod_id = s.prod_id\nORDER BY share_change DESC, p.prod_id;\t----- bird -----\tcomplex_oracle_spider2",
    "38": "WITH us_sales AS (\n  SELECT\n    s.prod_id,\n    c.cust_city AS city,\n    t.calendar_quarter_id,\n    SUM(s.amount_sold) AS sales_amt\n  FROM sales s\n  JOIN customers c ON c.cust_id = s.cust_id\n  JOIN countries co ON co.country_id = c.country_id\n  JOIN times t ON t.time_id = s.time_id\n  WHERE co.country_name = 'United States'\n    AND s.promo_id = 999\n    AND t.calendar_quarter_id IN (1772, 1776)  -- Q4 2019, Q4 2020\n  GROUP BY s.prod_id, c.cust_city, t.calendar_quarter_id\n),\ncity_totals AS (\n  SELECT\n    city,\n    SUM(CASE WHEN calendar_quarter_id = 1772 THEN sales_amt ELSE 0 END) AS q4_2019_sales,\n    SUM(CASE WHEN calendar_quarter_id = 1776 THEN sales_amt ELSE 0 END) AS q4_2020_sales\n  FROM us_sales\n  GROUP BY city\n),\neligible_cities AS (\n  SELECT city\n  FROM city_totals\n  WHERE q4_2019_sales > 0\n    AND (q4_2020_sales - q4_2019_sales) * 1.0 / q4_2019_sales >= 0.20\n),\nprod_quarter_sales AS (\n  SELECT\n    u.prod_id,\n    u.calendar_quarter_id,\n    SUM(u.sales_amt) AS prod_sales\n  FROM us_sales u\n  JOIN eligible_cities ec ON ec.city = u.city\n  GROUP BY u.prod_id, u.calendar_quarter_id\n),\nquarter_totals AS (\n  SELECT\n    calendar_quarter_id,\n    SUM(prod_sales) AS total_sales\n  FROM prod_quarter_sales\n  GROUP BY calendar_quarter_id\n),\nprod_total_both AS (\n  SELECT\n    prod_id,\n    SUM(prod_sales) AS total_sales_both\n  FROM prod_quarter_sales\n  GROUP BY prod_id\n),\nranked AS (\n  SELECT\n    prod_id,\n    total_sales_both,\n    NTILE(5) OVER (ORDER BY total_sales_both DESC) AS sales_quintile\n  FROM prod_total_both\n),\nshares AS (\n  SELECT\n    pqs.prod_id,\n    MAX(CASE WHEN pqs.calendar_quarter_id = 1772 THEN pqs.prod_sales * 1.0 / qt19.total_sales END) AS share_2019,\n    MAX(CASE WHEN pqs.calendar_quarter_id = 1776 THEN pqs.prod_sales * 1.0 / qt20.total_sales END) AS share_2020\n  FROM prod_quarter_sales pqs\n  JOIN quarter_totals qt19 ON qt19.calendar_quarter_id = 1772\n  JOIN quarter_totals qt20 ON qt20.calendar_quarter_id = 1776\n  GROUP BY pqs.prod_id\n),\nfinal AS (\n  SELECT\n    r.prod_id,\n    pr.prod_name,\n    COALESCE(s.share_2019, 0.0) AS share_2019,\n    COALESCE(s.share_2020, 0.0) AS share_2020,\n    (COALESCE(s.share_2020, 0.0) - COALESCE(s.share_2019, 0.0)) * 100.0 AS pct_point_change\n  FROM ranked r\n  JOIN products pr ON pr.prod_id = r.prod_id\n  JOIN shares s ON s.prod_id = r.prod_id\n  WHERE r.sales_quintile = 1  -- top 20% by total sales across both quarters\n)\nSELECT\n  prod_id,\n  prod_name,\n  share_2019,\n  share_2020,\n  pct_point_change\nFROM final\nORDER BY ABS(pct_point_change) ASC, prod_id\nLIMIT 1;\t----- bird -----\tcomplex_oracle_spider2",
    "52": "WITH monthly_net AS (\n  SELECT\n    customer_id,\n    date(txn_date, 'start of month') AS month_start,\n    SUM(\n      CASE\n        WHEN lower(txn_type) = 'deposit' THEN txn_amount\n        WHEN lower(txn_type) = 'withdrawal' THEN -txn_amount\n        ELSE 0\n      END\n    ) AS net_amount\n  FROM customer_transactions\n  GROUP BY customer_id, date(txn_date, 'start of month')\n),\nmonthly_balance AS (\n  SELECT\n    customer_id,\n    month_start,\n    net_amount,\n    SUM(net_amount) OVER (\n      PARTITION BY customer_id\n      ORDER BY month_start\n      ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n    ) AS closing_balance\n  FROM monthly_net\n),\nlatest_month AS (\n  SELECT\n    customer_id,\n    month_start,\n    closing_balance,\n    LAG(closing_balance) OVER (\n      PARTITION BY customer_id\n      ORDER BY month_start\n    ) AS prev_closing_balance,\n    ROW_NUMBER() OVER (\n      PARTITION BY customer_id\n      ORDER BY month_start DESC\n    ) AS rn\n  FROM monthly_balance\n),\nlatest_growth AS (\n  SELECT\n    customer_id,\n    CASE\n      WHEN COALESCE(prev_closing_balance, 0) = 0\n        THEN closing_balance * 100.0\n      ELSE ((closing_balance - prev_closing_balance) * 100.0) / prev_closing_balance\n    END AS growth_rate\n  FROM latest_month\n  WHERE rn = 1\n)\nSELECT\n  100.0 * AVG(CASE WHEN growth_rate > 5.0 THEN 1.0 ELSE 0.0 END) AS pct_customers_growth_gt_5\nFROM latest_growth;\t----- bird -----\tbank_sales_trading_spider2",
    "50": "WITH RECURSIVE\n-- 1) Monthly net change per customer (deposits positive, withdrawals/purchases negative)\nmonthly_net AS (\n  SELECT\n    ct.customer_id,\n    date(ct.txn_date, 'start of month') AS month_start,\n    SUM(\n      CASE\n        WHEN lower(ct.txn_type) IN ('deposit', 'credit') THEN ct.txn_amount\n        WHEN lower(ct.txn_type) IN ('withdrawal', 'debit', 'purchase') THEN -ct.txn_amount\n        ELSE ct.txn_amount\n      END\n    ) AS net_change\n  FROM customer_transactions ct\n  GROUP BY ct.customer_id, date(ct.txn_date, 'start of month')\n),\n\n-- 2) Month range per customer based on their transaction history\ncust_month_bounds AS (\n  SELECT\n    customer_id,\n    MIN(month_start) AS min_month,\n    MAX(month_start) AS max_month\n  FROM monthly_net\n  GROUP BY customer_id\n),\n\n-- 3) Generate a complete month series per customer (fills months with no activity)\nmonth_series AS (\n  SELECT\n    customer_id,\n    min_month AS month_start,\n    max_month\n  FROM cust_month_bounds\n  UNION ALL\n  SELECT\n    customer_id,\n    date(month_start, '+1 month') AS month_start,\n    max_month\n  FROM month_series\n  WHERE month_start < max_month\n),\n\n-- 4) Join month series to monthly net changes (0 when no activity)\nmonthly_filled AS (\n  SELECT\n    ms.customer_id,\n    ms.month_start,\n    COALESCE(mn.net_change, 0) AS monthly_change\n  FROM month_series ms\n  LEFT JOIN monthly_net mn\n    ON mn.customer_id = ms.customer_id\n   AND mn.month_start  = ms.month_start\n)\n\n-- 5) Compute closing balance (cumulative) and show month-end date\nSELECT\n  customer_id,\n  date(month_start, '+1 month', '-1 day') AS month_end,\n  monthly_change AS monthly_change_amount,\n  SUM(monthly_change) OVER (\n    PARTITION BY customer_id\n    ORDER BY month_start\n    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n  ) AS closing_balance\nFROM monthly_filled\nORDER BY customer_id, month_start;\t----- bird -----\tbank_sales_trading_spider2",
    "40": "WITH fr_sales AS (\n  SELECT\n    t.calendar_year AS yr,\n    t.calendar_month_number AS mo,\n    SUM(s.amount_sold) AS sales_local\n  FROM sales s\n  JOIN times t       ON t.time_id = s.time_id\n  JOIN customers cu  ON cu.cust_id = s.cust_id\n  JOIN countries co  ON co.country_id = cu.country_id\n  JOIN promotions p  ON p.promo_id = s.promo_id\n  JOIN channels ch   ON ch.channel_id = s.channel_id\n  WHERE co.country_name = 'France'\n    AND t.calendar_year IN (2019, 2020)\n    AND p.promo_total_id = 1\n    AND ch.channel_total_id = 1\n  GROUP BY t.calendar_year, t.calendar_month_number\n),\nproj_2021 AS (\n  SELECT\n    mo,\n    CASE\n      WHEN s19.sales_local IS NULL OR s19.sales_local = 0 OR s20.sales_local IS NULL\n        THEN NULL\n      ELSE\n        ( ((s20.sales_local - s19.sales_local) * 1.0 / s19.sales_local) * s20.sales_local ) + s20.sales_local\n    END AS projected_local_2021\n  FROM (SELECT DISTINCT mo FROM fr_sales) m\n  LEFT JOIN fr_sales s19 ON s19.yr = 2019 AND s19.mo = m.mo\n  LEFT JOIN fr_sales s20 ON s20.yr = 2020 AND s20.mo = m.mo\n),\nproj_2021_usd AS (\n  SELECT\n    p.mo,\n    ROUND(p.projected_local_2021 * COALESCE(cur.to_us, 1.0), 2) AS projected_usd\n  FROM proj_2021 p\n  LEFT JOIN currency cur\n    ON cur.country = 'France'\n   AND cur.year = 2021\n   AND cur.month = p.mo\n  WHERE p.projected_local_2021 IS NOT NULL\n),\nmonthly_avg AS (\n  -- average monthly projected sales in USD for France in 2021\n  SELECT\n    mo,\n    AVG(projected_usd) AS avg_monthly_projected_usd\n  FROM proj_2021_usd\n  GROUP BY mo\n),\nordered AS (\n  SELECT\n    avg_monthly_projected_usd,\n    ROW_NUMBER() OVER (ORDER BY avg_monthly_projected_usd) AS rn,\n    COUNT(*) OVER () AS cnt\n  FROM monthly_avg\n)\nSELECT\n  AVG(avg_monthly_projected_usd) AS median_avg_monthly_projected_sales_usd_2021\nFROM ordered\nWHERE rn IN ( (cnt + 1) / 2, (cnt + 2) / 2 );\t----- bird -----\tcomplex_oracle_spider2",
    "60": "WITH emp_orders AS (\n  SELECT\n    o.employeeid,\n    COUNT(*) AS total_orders,\n    SUM(\n      CASE\n        WHEN o.shippeddate IS NOT NULL\n         AND o.requireddate IS NOT NULL\n         AND date(o.shippeddate) >= date(o.requireddate)\n        THEN 1 ELSE 0\n      END\n    ) AS late_orders\n  FROM orders o\n  GROUP BY o.employeeid\n),\nqualified AS (\n  SELECT\n    employeeid,\n    late_orders,\n    total_orders,\n    (late_orders * 1.0) / total_orders AS late_pct\n  FROM emp_orders\n  WHERE total_orders > 50\n)\nSELECT\n  employeeid,\n  late_orders,\n  ROUND(late_pct * 100.0, 2) AS late_order_percentage\nFROM qualified\nORDER BY late_pct DESC, late_orders DESC, employeeid\nLIMIT 3;\t----- bird -----\tnorthwind_spider2",
    "59": "WITH customer_spend_1998 AS (\n  SELECT\n    o.customerid,\n    SUM(od.unitprice * od.quantity) AS total_spent\n  FROM orders o\n  JOIN order_details od\n    ON od.orderid = o.orderid\n  WHERE o.orderdate >= '1998-01-01'\n    AND o.orderdate <  '1999-01-01'\n  GROUP BY o.customerid\n),\ncustomer_grouped AS (\n  SELECT\n    cs.customerid,\n    cs.total_spent,\n    cgt.groupname\n  FROM customer_spend_1998 cs\n  JOIN customergroupthreshold cgt\n    ON cs.total_spent >= cgt.rangebottom\n   AND cs.total_spent <  cgt.rangetop\n),\ntotals AS (\n  SELECT COUNT(*) AS total_customers\n  FROM customer_spend_1998\n)\nSELECT\n  cg.groupname,\n  COUNT(*) AS customers_in_group,\n  ROUND(100.0 * COUNT(*) / t.total_customers, 2) AS pct_of_customers_1998\nFROM customer_grouped cg\nCROSS JOIN totals t\nGROUP BY cg.groupname\nORDER BY customers_in_group DESC, cg.groupname;\t----- bird -----\tnorthwind_spider2",
    "62": "WITH years AS (\n  SELECT DISTINCT CAST(year AS INTEGER) AS y\n  FROM Movie\n  WHERE year IS NOT NULL\n    AND TRIM(year) <> ''\n),\nperiod_counts AS (\n  SELECT\n    y.y AS start_year,\n    (\n      SELECT COUNT(*)\n      FROM Movie m\n      WHERE m.year IS NOT NULL\n        AND TRIM(m.year) <> ''\n        AND CAST(m.year AS INTEGER) BETWEEN y.y AND (y.y + 9)\n    ) AS film_count\n  FROM years y\n)\nSELECT start_year, film_count\nFROM period_counts\nORDER BY film_count DESC, start_year ASC\nLIMIT 1;\t----- bird -----\tDb-IMDB_spider2",
    "58": "WITH max_comp AS (\n  SELECT\n    im.interest_id,\n    im.month_year,\n    im.composition,\n    ROW_NUMBER() OVER (\n      PARTITION BY im.interest_id\n      ORDER BY im.composition DESC, im._year DESC, im._month DESC\n    ) AS rn\n  FROM interest_metrics im\n  WHERE im.composition IS NOT NULL\n),\nper_interest AS (\n  SELECT\n    mc.interest_id,\n    mc.month_year,\n    mc.composition\n  FROM max_comp mc\n  WHERE mc.rn = 1\n),\nranked AS (\n  SELECT\n    pi.*,\n    DENSE_RANK() OVER (ORDER BY pi.composition DESC) AS r_top,\n    DENSE_RANK() OVER (ORDER BY pi.composition ASC)  AS r_bottom\n  FROM per_interest pi\n)\nSELECT\n  ranked.month_year AS \"time(MM-YYYY)\",\n  imap.interest_name,\n  ranked.composition\nFROM ranked\nJOIN interest_map imap\n  ON imap.id = CAST(ranked.interest_id AS INTEGER)\nWHERE ranked.r_top <= 10 OR ranked.r_bottom <= 10\nORDER BY\n  CASE WHEN ranked.r_top <= 10 THEN 0 ELSE 1 END,\n  CASE WHEN ranked.r_top <= 10 THEN ranked.r_top ELSE ranked.r_bottom END,\n  ranked.composition DESC;\t----- bird -----\tbank_sales_trading_spider2",
    "53": "WITH txns AS (\n  SELECT\n    member_id,\n    date(txn_date) AS txn_date,\n    CASE\n      WHEN lower(txn_type) = 'buy'  THEN  quantity\n      WHEN lower(txn_type) = 'sell' THEN -quantity\n      ELSE 0\n    END AS qty_delta\n  FROM bitcoin_transactions\n),\nmonths AS (\n  -- month starts based on transaction dates\n  SELECT DISTINCT date(txn_date, 'start of month') AS month_start\n  FROM txns\n),\nmember_month AS (\n  -- all member x month combinations so balances carry forward even with no activity\n  SELECT m.member_id, mo.month_start\n  FROM (SELECT DISTINCT member_id FROM txns) m\n  CROSS JOIN months mo\n),\nmember_balance_asof AS (\n  -- balance as of the 1st of each month (i.e., all txns strictly before month_start)\n  SELECT\n    mm.month_start,\n    mm.member_id,\n    COALESCE(SUM(t.qty_delta), 0) AS balance_asof_month_start\n  FROM member_month mm\n  LEFT JOIN txns t\n    ON t.member_id = mm.member_id\n   AND t.txn_date < mm.month_start\n  GROUP BY mm.month_start, mm.member_id\n),\ntotal_prev_month_balance AS (\n  -- for each month_start, take the previous month's total balance (negatives floored to 0 per user)\n  SELECT\n    month_start,\n    SUM(CASE WHEN balance_asof_month_start < 0 THEN 0 ELSE balance_asof_month_start END) AS total_balance_prev_month\n  FROM member_balance_asof\n  GROUP BY month_start\n),\nranked AS (\n  SELECT\n    month_start,\n    total_balance_prev_month,\n    ROW_NUMBER() OVER (ORDER BY month_start) AS rn\n  FROM total_prev_month_balance\n)\nSELECT\n  month_start AS month,\n  total_balance_prev_month\nFROM ranked\nWHERE rn > 1          -- exclude the first month (baseline only)\nORDER BY month_start;\t----- bird -----\tbank_sales_trading_spider2",
    "51": "WITH RECURSIVE months AS (\n  -- all months in 2020\n  SELECT date('2020-01-01') AS month_start\n  UNION ALL\n  SELECT date(month_start, '+1 month')\n  FROM months\n  WHERE month_start < date('2020-12-01')\n),\ncustomers AS (\n  SELECT DISTINCT customer_id\n  FROM customer_transactions\n),\ncustomer_months AS (\n  -- ensure every customer has a row for every month (missing months => 0 net change)\n  SELECT c.customer_id, m.month_start\n  FROM customers c\n  CROSS JOIN months m\n),\nmonth_net AS (\n  -- net change within each month: deposits positive, withdrawals negative\n  SELECT\n    cm.customer_id,\n    cm.month_start,\n    COALESCE(SUM(\n      CASE\n        WHEN lower(ct.txn_type) = 'deposit' THEN ct.txn_amount\n        WHEN lower(ct.txn_type) = 'withdrawal' THEN -ct.txn_amount\n        ELSE 0\n      END\n    ), 0) AS month_end_balance\n  FROM customer_months cm\n  LEFT JOIN customer_transactions ct\n    ON ct.customer_id = cm.customer_id\n   AND date(ct.txn_date) >= cm.month_start\n   AND date(ct.txn_date) < date(cm.month_start, '+1 month')\n  GROUP BY cm.customer_id, cm.month_start\n),\nmonth_stats AS (\n  SELECT\n    month_start,\n    SUM(CASE WHEN month_end_balance > 0 THEN 1 ELSE 0 END) AS positive_customer_count,\n    AVG(month_end_balance) AS avg_month_end_balance\n  FROM month_net\n  GROUP BY month_start\n),\nranked AS (\n  SELECT\n    month_start,\n    positive_customer_count,\n    avg_month_end_balance,\n    RANK() OVER (ORDER BY positive_customer_count DESC, month_start) AS r_high,\n    RANK() OVER (ORDER BY positive_customer_count ASC,  month_start) AS r_low\n  FROM month_stats\n),\npicked AS (\n  SELECT 'highest' AS which, month_start, positive_customer_count, avg_month_end_balance\n  FROM ranked\n  WHERE r_high = 1\n  UNION ALL\n  SELECT 'lowest' AS which, month_start, positive_customer_count, avg_month_end_balance\n  FROM ranked\n  WHERE r_low = 1\n)\nSELECT\n  MAX(CASE WHEN which = 'highest' THEN month_start END) AS highest_month,\n  MAX(CASE WHEN which = 'highest' THEN positive_customer_count END) AS highest_positive_customer_count,\n  MAX(CASE WHEN which = 'highest' THEN avg_month_end_balance END) AS highest_avg_month_end_balance,\n  MAX(CASE WHEN which = 'lowest' THEN month_start END) AS lowest_month,\n  MAX(CASE WHEN which = 'lowest' THEN positive_customer_count END) AS lowest_positive_customer_count,\n  MAX(CASE WHEN which = 'lowest' THEN avg_month_end_balance END) AS lowest_avg_month_end_balance,\n  (MAX(CASE WHEN which = 'highest' THEN avg_month_end_balance END)\n   - MAX(CASE WHEN which = 'lowest'  THEN avg_month_end_balance END)) AS avg_balance_difference\nFROM picked;\t----- bird -----\tbank_sales_trading_spider2",
    "55": "WITH\n-- Normalize transactions to signed amounts\ntxns AS (\n  SELECT\n    customer_id,\n    date(txn_date) AS txn_date,\n    CASE\n      WHEN lower(txn_type) = 'deposit'  THEN txn_amount\n      WHEN lower(txn_type) = 'purchase' THEN -txn_amount\n      WHEN lower(txn_type) = 'withdrawal' THEN -txn_amount\n      ELSE 0\n    END AS signed_amount\n  FROM customer_transactions\n),\n-- Daily net change per customer\ndaily_change AS (\n  SELECT\n    customer_id,\n    txn_date,\n    SUM(signed_amount) AS net_change\n  FROM txns\n  GROUP BY customer_id, txn_date\n),\n-- Per-customer date bounds\nbounds AS (\n  SELECT\n    customer_id,\n    MIN(txn_date) AS min_date,\n    MAX(txn_date) AS max_date\n  FROM daily_change\n  GROUP BY customer_id\n),\n-- Generate all dates between min and max per customer\ncalendar AS (\n  SELECT customer_id, min_date AS d, max_date\n  FROM bounds\n  UNION ALL\n  SELECT customer_id, date(d, '+1 day') AS d, max_date\n  FROM calendar\n  WHERE d < max_date\n),\n-- Join in daily changes (0 on no-transaction days)\ncal_with_change AS (\n  SELECT\n    c.customer_id,\n    c.d AS txn_date,\n    COALESCE(dc.net_change, 0) AS net_change\n  FROM calendar c\n  LEFT JOIN daily_change dc\n    ON dc.customer_id = c.customer_id\n   AND dc.txn_date = c.d\n),\n-- Running balance; clamp negatives to 0\ndaily_balance AS (\n  SELECT\n    customer_id,\n    txn_date,\n    MAX(\n      0,\n      SUM(net_change) OVER (\n        PARTITION BY customer_id\n        ORDER BY txn_date\n        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n      )\n    ) AS balance\n  FROM cal_with_change\n),\n-- Max daily balance per customer per month\nmonthly_customer_max AS (\n  SELECT\n    strftime('%Y-%m', txn_date) AS month,\n    customer_id,\n    MAX(balance) AS max_daily_balance\n  FROM daily_balance\n  GROUP BY month, customer_id\n)\n-- Monthly total = sum of customer monthly maxima\nSELECT\n  month,\n  SUM(max_daily_balance) AS monthly_total_max_balance\nFROM monthly_customer_max\nGROUP BY month\nORDER BY month\n;\t----- bird -----\tbank_sales_trading_spider2",
    "56": "WITH filtered_events AS (\n  SELECT\n    e.visit_id,\n    e.page_id,\n    ph.product_id,\n    ph.page_name AS product_name,\n    ei.event_name\n  FROM shopping_cart_events e\n  JOIN shopping_cart_page_hierarchy ph\n    ON ph.page_id = e.page_id\n  JOIN shopping_cart_event_identifier ei\n    ON ei.event_type = e.event_type\n  WHERE e.page_id NOT IN (1, 2, 12, 13)\n    AND ph.product_id IS NOT NULL\n),\nper_product AS (\n  SELECT\n    product_id,\n    product_name,\n    SUM(CASE WHEN event_name = 'Page View' THEN 1 ELSE 0 END) AS views,\n    SUM(CASE WHEN event_name = 'Add to Cart' THEN 1 ELSE 0 END) AS adds_to_cart,\n    SUM(CASE WHEN event_name = 'Purchase' THEN 1 ELSE 0 END) AS purchases\n  FROM filtered_events\n  GROUP BY product_id, product_name\n),\ncart_abandon AS (\n  -- A product is \"left in cart without being purchased\" for a visit if it was added\n  -- but not purchased in that same visit.\n  SELECT\n    product_id,\n    product_name,\n    COUNT(*) AS left_in_cart_without_purchase\n  FROM (\n    SELECT\n      product_id,\n      product_name,\n      visit_id,\n      MAX(CASE WHEN event_name = 'Add to Cart' THEN 1 ELSE 0 END) AS has_add,\n      MAX(CASE WHEN event_name = 'Purchase' THEN 1 ELSE 0 END) AS has_purchase\n    FROM filtered_events\n    GROUP BY product_id, product_name, visit_id\n  )\n  WHERE has_add = 1 AND has_purchase = 0\n  GROUP BY product_id, product_name\n)\nSELECT\n  p.product_id,\n  p.product_name,\n  p.views,\n  p.adds_to_cart,\n  COALESCE(c.left_in_cart_without_purchase, 0) AS left_in_cart_without_being_purchased,\n  p.purchases AS actual_purchases\nFROM per_product p\nLEFT JOIN cart_abandon c\n  ON c.product_id = p.product_id\nORDER BY p.product_id;\t----- bird -----\tbank_sales_trading_spider2",
    "61": "WITH movies_by_year AS (\n  SELECT\n    MID,\n    CAST(SUBSTR(year, -4) AS INTEGER) AS yr\n  FROM Movie\n  WHERE year IS NOT NULL\n    AND LENGTH(year) >= 4\n    AND SUBSTR(year, -4) GLOB '[0-9][0-9][0-9][0-9]'\n),\nmovie_cast_gender AS (\n  SELECT\n    mby.yr,\n    mby.MID,\n    SUM(CASE WHEN p.Gender = 'Female' THEN 1 ELSE 0 END) AS female_cnt,\n    SUM(CASE WHEN p.Gender IN ('Male', 'None') OR p.Gender IS NULL THEN 1 ELSE 0 END) AS non_female_cnt,\n    COUNT(p.PID) AS cast_cnt\n  FROM movies_by_year AS mby\n  LEFT JOIN M_Cast AS mc\n    ON mc.MID = mby.MID\n  LEFT JOIN Person AS p\n    ON p.PID = mc.PID\n  GROUP BY mby.yr, mby.MID\n),\nyear_stats AS (\n  SELECT\n    yr,\n    COUNT(*) AS total_movies,\n    SUM(\n      CASE\n        WHEN cast_cnt > 0 AND non_female_cnt = 0 AND female_cnt > 0 THEN 1\n        ELSE 0\n      END\n    ) AS exclusively_female_movies\n  FROM movie_cast_gender\n  GROUP BY yr\n)\nSELECT\n  yr AS year,\n  total_movies,\n  ROUND(100.0 * exclusively_female_movies / NULLIF(total_movies, 0), 2) AS pct_exclusively_female\nFROM year_stats\nORDER BY year;\t----- bird -----\tDb-IMDB_spider2",
    "63": "WITH actor_years AS (\n  SELECT\n    mc.PID,\n    CAST(m.year AS INTEGER) AS yr\n  FROM M_Cast mc\n  JOIN Movie m ON m.MID = mc.MID\n  WHERE m.year IS NOT NULL\n    AND TRIM(m.year) <> ''\n    AND CAST(m.year AS INTEGER) IS NOT NULL\n  GROUP BY mc.PID, CAST(m.year AS INTEGER)\n),\nactor_bounds AS (\n  SELECT\n    PID,\n    MIN(yr) AS first_year,\n    MAX(yr) AS last_year\n  FROM actor_years\n  GROUP BY PID\n),\nactor_gaps AS (\n  SELECT\n    ay.PID,\n    ay.yr,\n    LEAD(ay.yr) OVER (PARTITION BY ay.PID ORDER BY ay.yr) AS next_yr\n  FROM actor_years ay\n),\nbad_actors AS (\n  -- A \"bad\" actor has any gap of 4+ years between consecutive credited years\n  SELECT DISTINCT PID\n  FROM actor_gaps\n  WHERE next_yr IS NOT NULL\n    AND (next_yr - yr) >= 4\n)\nSELECT COUNT(*) AS actors_with_no_4_year_gap\nFROM actor_bounds ab\nLEFT JOIN bad_actors b ON b.PID = ab.PID\nWHERE b.PID IS NULL;\t----- bird -----\tDb-IMDB_spider2",
    "47": "WITH base_orders AS (\n  SELECT\n    row_number() OVER (ORDER BY co.order_id, co.order_time, co.customer_id, co.pizza_id) AS row_id,\n    co.order_id,\n    co.customer_id,\n    co.order_time,\n    CASE WHEN pn.pizza_name = 'Meatlovers' THEN 1 ELSE 2 END AS pizza_id,\n    pn.pizza_name\n  FROM pizza_clean_customer_orders co\n  JOIN pizza_names pn\n    ON pn.pizza_id = co.pizza_id\n),\nrecipe_toppings AS (\n  SELECT\n    bo.row_id,\n    bo.order_id,\n    bo.customer_id,\n    bo.order_time,\n    bo.pizza_id,\n    bo.pizza_name,\n    CAST(trim(j.value) AS INTEGER) AS topping_id\n  FROM base_orders bo\n  JOIN pizza_recipes pr\n    ON pr.pizza_id = bo.pizza_id\n  JOIN json_each(\n    '[\"' || replace(pr.toppings, ',', '\",\"') || '\"]'\n  ) AS j\n),\nexcluded AS (\n  SELECT\n    bo.row_id,\n    CAST(trim(j.value) AS INTEGER) AS topping_id\n  FROM base_orders bo\n  LEFT JOIN pizza_get_exclusions ge\n    ON ge.order_id = bo.order_id\n  JOIN json_each(\n    CASE\n      WHEN ge.exclusions IS NULL THEN '[]'\n      ELSE '[\"' || replace(CAST(ge.exclusions AS TEXT), ',', '\",\"') || '\"]'\n    END\n  ) AS j\n),\nextras AS (\n  SELECT\n    bo.row_id,\n    CAST(trim(j.value) AS INTEGER) AS topping_id\n  FROM base_orders bo\n  LEFT JOIN pizza_get_extras gx\n    ON gx.order_id = bo.order_id\n  JOIN json_each(\n    CASE\n      WHEN gx.extras IS NULL THEN '[]'\n      ELSE '[\"' || replace(CAST(gx.extras AS TEXT), ',', '\",\"') || '\"]'\n    END\n  ) AS j\n),\nfinal_toppings AS (\n  -- start with recipe toppings, remove exclusions\n  SELECT rt.row_id, rt.order_id, rt.customer_id, rt.order_time, rt.pizza_name, rt.topping_id\n  FROM recipe_toppings rt\n  LEFT JOIN excluded e\n    ON e.row_id = rt.row_id\n   AND e.topping_id = rt.topping_id\n  WHERE e.topping_id IS NULL\n\n  UNION ALL\n\n  -- add extras\n  SELECT bo.row_id, bo.order_id, bo.customer_id, bo.order_time, bo.pizza_name, ex.topping_id\n  FROM base_orders bo\n  JOIN extras ex\n    ON ex.row_id = bo.row_id\n),\ntopping_counts AS (\n  SELECT\n    ft.row_id,\n    ft.order_id,\n    ft.customer_id,\n    ft.order_time,\n    ft.pizza_name,\n    pt.topping_name,\n    COUNT(*) AS cnt\n  FROM final_toppings ft\n  JOIN pizza_toppings pt\n    ON pt.topping_id = ft.topping_id\n  GROUP BY\n    ft.row_id, ft.order_id, ft.customer_id, ft.order_time, ft.pizza_name, pt.topping_name\n)\nSELECT\n  row_id,\n  order_id,\n  customer_id,\n  pizza_name,\n  pizza_name || ': ' ||\n  group_concat(\n    CASE WHEN cnt > 1 THEN '2x' || topping_name ELSE topping_name END,\n    ', '\n  ) AS ingredients\nFROM (\n  SELECT *\n  FROM topping_counts\n  ORDER BY\n    row_id,\n    CASE WHEN cnt > 1 THEN 0 ELSE 1 END,\n    topping_name\n)\nGROUP BY row_id, order_id, customer_id, pizza_name, order_time\nORDER BY row_id ASC;\t----- bird -----\tmodern_data_spider2",
    "54": "WITH daily_net AS (\n  SELECT\n    customer_id,\n    date(txn_date) AS txn_date,\n    SUM(\n      CASE\n        WHEN lower(txn_type) = 'deposit' THEN txn_amount\n        ELSE -txn_amount\n      END\n    ) AS net_amount\n  FROM customer_transactions\n  GROUP BY customer_id, date(txn_date)\n),\ndate_bounds AS (\n  SELECT\n    customer_id,\n    MIN(txn_date) AS min_date,\n    MAX(txn_date) AS max_date\n  FROM daily_net\n  GROUP BY customer_id\n),\ncalendar AS (\n  -- build a complete daily calendar per customer from first to last transaction date\n  SELECT customer_id, min_date AS txn_date, max_date\n  FROM date_bounds\n  UNION ALL\n  SELECT customer_id, date(txn_date, '+1 day') AS txn_date, max_date\n  FROM calendar\n  WHERE txn_date < max_date\n),\ndaily_series AS (\n  -- fill missing days with 0 net movement\n  SELECT\n    c.customer_id,\n    c.txn_date,\n    COALESCE(dn.net_amount, 0) AS net_amount\n  FROM calendar c\n  LEFT JOIN daily_net dn\n    ON dn.customer_id = c.customer_id\n   AND dn.txn_date = c.txn_date\n),\ndaily_balance AS (\n  SELECT\n    customer_id,\n    txn_date,\n    SUM(net_amount) OVER (\n      PARTITION BY customer_id\n      ORDER BY txn_date\n      ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n    ) AS running_balance\n  FROM daily_series\n),\nrolling_30 AS (\n  SELECT\n    customer_id,\n    txn_date,\n    running_balance,\n    COUNT(*) OVER (\n      PARTITION BY customer_id\n      ORDER BY txn_date\n      ROWS BETWEEN 29 PRECEDING AND CURRENT ROW\n    ) AS days_in_window,\n    AVG(running_balance) OVER (\n      PARTITION BY customer_id\n      ORDER BY txn_date\n      ROWS BETWEEN 29 PRECEDING AND CURRENT ROW\n    ) AS avg_30_raw\n  FROM daily_balance\n),\ndaily_30_avg AS (\n  SELECT\n    customer_id,\n    txn_date,\n    strftime('%Y-%m-01', txn_date) AS month_start,\n    CASE\n      WHEN days_in_window = 30 THEN MAX(avg_30_raw, 0)\n      ELSE NULL\n    END AS avg_30\n  FROM rolling_30\n),\ncustomer_month_max AS (\n  SELECT\n    customer_id,\n    month_start,\n    MAX(avg_30) AS max_30_day_avg\n  FROM daily_30_avg\n  WHERE avg_30 IS NOT NULL\n  GROUP BY customer_id, month_start\n),\nbaseline AS (\n  SELECT\n    customer_id,\n    MIN(month_start) AS baseline_month\n  FROM customer_month_max\n  GROUP BY customer_id\n)\nSELECT\n  cmm.month_start AS month,\n  SUM(cmm.max_30_day_avg) AS total_summed_max_30_day_avg_balance\nFROM customer_month_max cmm\nJOIN baseline b\n  ON b.customer_id = cmm.customer_id\nWHERE cmm.month_start > b.baseline_month\nGROUP BY cmm.month_start\nORDER BY cmm.month_start;\t----- bird -----\tbank_sales_trading_spider2",
    "57": "WITH base AS (\n  SELECT\n    date(printf('%04d-%02d-01', CAST(im._year AS INT), CAST(im._month AS INT))) AS month_start,\n    CAST(im.interest_id AS INT) AS interest_id,\n    im.composition,\n    im.index_value,\n    (im.composition * 1.0) / NULLIF(im.index_value, 0) AS avg_composition\n  FROM interest_metrics im\n  WHERE date(printf('%04d-%02d-01', CAST(im._year AS INT), CAST(im._month AS INT)))\n        BETWEEN date('2018-09-01') AND date('2019-08-01')\n),\nranked AS (\n  SELECT\n    b.month_start,\n    b.interest_id,\n    b.avg_composition,\n    ROW_NUMBER() OVER (\n      PARTITION BY b.month_start\n      ORDER BY b.avg_composition DESC\n    ) AS rn\n  FROM base b\n),\nmonthly_max AS (\n  SELECT\n    r.month_start,\n    r.interest_id,\n    r.avg_composition AS max_index_composition\n  FROM ranked r\n  WHERE r.rn = 1\n),\nfinal AS (\n  SELECT\n    mm.month_start AS month_date,\n    imap.interest_name,\n    mm.max_index_composition,\n\n    AVG(mm.max_index_composition) OVER (\n      ORDER BY mm.month_start\n      ROWS BETWEEN 2 PRECEDING AND CURRENT ROW\n    ) AS rolling_3_month_avg,\n\n    LAG(imap.interest_name, 1) OVER (ORDER BY mm.month_start) AS top_interest_1_month_ago,\n    LAG(mm.max_index_composition, 1) OVER (ORDER BY mm.month_start) AS top_interest_1_month_ago_max_index_composition,\n\n    LAG(imap.interest_name, 2) OVER (ORDER BY mm.month_start) AS top_interest_2_months_ago,\n    LAG(mm.max_index_composition, 2) OVER (ORDER BY mm.month_start) AS top_interest_2_months_ago_max_index_composition\n  FROM monthly_max mm\n  JOIN interest_map imap\n    ON imap.id = mm.interest_id\n)\nSELECT\n  month_date,\n  interest_name,\n  max_index_composition,\n  rolling_3_month_avg,\n  top_interest_1_month_ago,\n  top_interest_1_month_ago_max_index_composition,\n  top_interest_2_months_ago,\n  top_interest_2_months_ago_max_index_composition\nFROM final\nORDER BY month_date;\t----- bird -----\tbank_sales_trading_spider2",
    "69": "SELECT\n  ms.StyleID,\n  ms.StyleName,\n  SUM(CASE WHEN mp.PreferenceSeq = 1 THEN 1 ELSE 0 END) AS Pref1_Count,\n  SUM(CASE WHEN mp.PreferenceSeq = 2 THEN 1 ELSE 0 END) AS Pref2_Count,\n  SUM(CASE WHEN mp.PreferenceSeq = 3 THEN 1 ELSE 0 END) AS Pref3_Count\nFROM Musical_Styles AS ms\nLEFT JOIN Musical_Preferences AS mp\n  ON mp.StyleID = ms.StyleID\n AND mp.PreferenceSeq IN (1, 2, 3)\nGROUP BY\n  ms.StyleID,\n  ms.StyleName\nORDER BY\n  ms.StyleName;\t----- bird -----\tEntertainmentAgency_spider2",
    "64": "WITH actor_director_counts AS (\n  SELECT\n    mc.PID AS actor_pid,\n    md.PID AS director_pid,\n    COUNT(DISTINCT mc.MID) AS films_together\n  FROM M_Cast mc\n  JOIN M_Director md\n    ON md.MID = mc.MID\n  GROUP BY mc.PID, md.PID\n),\nyash AS (\n  SELECT PID\n  FROM Person\n  WHERE Name = 'Yash Chopra'\n),\nranked AS (\n  SELECT\n    adc.actor_pid,\n    adc.director_pid,\n    adc.films_together,\n    MAX(adc.films_together) OVER (PARTITION BY adc.actor_pid) AS max_films_for_actor\n  FROM actor_director_counts adc\n),\nyash_best AS (\n  SELECT\n    r.actor_pid,\n    r.films_together AS yash_films,\n    r.max_films_for_actor,\n    SUM(CASE WHEN r.films_together = r.max_films_for_actor THEN 1 ELSE 0 END)\n      OVER (PARTITION BY r.actor_pid) AS num_directors_tied_for_max\n  FROM ranked r\n  JOIN yash y\n    ON y.PID = r.director_pid\n)\nSELECT COUNT(DISTINCT actor_pid) AS num_actors\nFROM yash_best\nWHERE yash_films = max_films_for_actor\n  AND num_directors_tied_for_max = 1;\t----- bird -----\tDb-IMDB_spider2",
    "70": "WITH style_scores AS (\n  SELECT\n    ms.StyleID,\n    ms.StyleName,\n    SUM(\n      CASE mp.PreferenceSeq\n        WHEN 1 THEN 3\n        WHEN 2 THEN 2\n        WHEN 3 THEN 1\n        ELSE 0\n      END\n    ) AS total_weighted_score\n  FROM Musical_Preferences AS mp\n  JOIN Musical_Styles AS ms\n    ON ms.StyleID = mp.StyleID\n  WHERE mp.PreferenceSeq IN (1, 2, 3)\n  GROUP BY ms.StyleID, ms.StyleName\n),\navg_score AS (\n  SELECT AVG(total_weighted_score) AS avg_total_weighted_score\n  FROM style_scores\n)\nSELECT\n  ss.StyleID,\n  ss.StyleName,\n  ss.total_weighted_score,\n  a.avg_total_weighted_score,\n  ABS(ss.total_weighted_score - a.avg_total_weighted_score) AS abs_diff_from_avg\nFROM style_scores AS ss\nCROSS JOIN avg_score AS a\nORDER BY ss.total_weighted_score DESC, ss.StyleName;\t----- bird -----\tEntertainmentAgency_spider2",
    "65": "WITH\n-- Shahrukh Khan's PID (handle common name variants)\nsrk AS (\n  SELECT PID\n  FROM Person\n  WHERE Name IN ('Shahrukh Khan', 'Shah Rukh Khan', 'Shahrukh Kahn', 'Shah Rukh Kahn')\n),\n-- Movies that Shahrukh Khan acted in\nsrk_movies AS (\n  SELECT DISTINCT mc.MID\n  FROM M_Cast mc\n  JOIN srk ON srk.PID = mc.PID\n),\n-- Actors who acted directly with Shahrukh Khan (Shahrukh number = 1)\nsrk_coactors AS (\n  SELECT DISTINCT mc.PID\n  FROM M_Cast mc\n  JOIN srk_movies sm ON sm.MID = mc.MID\n  WHERE mc.PID NOT IN (SELECT PID FROM srk)\n),\n-- Movies featuring any of Shahrukh's co-actors\ncoactor_movies AS (\n  SELECT DISTINCT mc.MID\n  FROM M_Cast mc\n  JOIN srk_coactors sc ON sc.PID = mc.PID\n),\n-- Actors who acted in a movie with a Shahrukh co-actor (candidates for number = 2)\ntwo_hop_candidates AS (\n  SELECT DISTINCT mc.PID\n  FROM M_Cast mc\n  JOIN coactor_movies cm ON cm.MID = mc.MID\n)\nSELECT COUNT(DISTINCT thc.PID) AS shahrukh_number_2_actors\nFROM two_hop_candidates thc\nWHERE thc.PID NOT IN (SELECT PID FROM srk)          -- not Shahrukh himself\n  AND thc.PID NOT IN (SELECT PID FROM srk_coactors) -- not directly connected to him\n;\t----- bird -----\tDb-IMDB_spider2",
    "66": "WITH region_rep_sales AS (\n  SELECT\n    r.id   AS region_id,\n    r.name AS region_name,\n    s.id   AS sales_rep_id,\n    s.name AS sales_rep_name,\n    SUM(o.total_amt_usd) AS rep_total_sales_amt\n  FROM web_region r\n  JOIN web_sales_reps s\n    ON s.region_id = r.id\n  JOIN web_accounts a\n    ON a.sales_rep_id = s.id\n  JOIN web_orders o\n    ON o.account_id = a.id\n  GROUP BY\n    r.id, r.name, s.id, s.name\n),\nregion_totals AS (\n  SELECT\n    r.id   AS region_id,\n    r.name AS region_name,\n    COUNT(o.id) AS num_orders,\n    SUM(o.total_amt_usd) AS total_sales_amt\n  FROM web_region r\n  JOIN web_sales_reps s\n    ON s.region_id = r.id\n  JOIN web_accounts a\n    ON a.sales_rep_id = s.id\n  JOIN web_orders o\n    ON o.account_id = a.id\n  GROUP BY\n    r.id, r.name\n),\nregion_max AS (\n  SELECT\n    region_id,\n    MAX(rep_total_sales_amt) AS max_rep_sales_amt\n  FROM region_rep_sales\n  GROUP BY region_id\n)\nSELECT\n  rt.region_name,\n  rt.num_orders,\n  rt.total_sales_amt,\n  rrs.sales_rep_name AS top_sales_rep_name,\n  rrs.rep_total_sales_amt AS top_sales_rep_sales_amt\nFROM region_totals rt\nJOIN region_max rm\n  ON rm.region_id = rt.region_id\nJOIN region_rep_sales rrs\n  ON rrs.region_id = rt.region_id\n AND rrs.rep_total_sales_amt = rm.max_rep_sales_amt\nORDER BY\n  rt.region_name,\n  top_sales_rep_name;\t----- bird -----\teducation_business_spider2",
    "74": "WITH top_genres AS (\n  SELECT\n    g.genre,\n    COUNT(DISTINCT g.movie_id) AS movie_count\n  FROM genre g\n  JOIN ratings r\n    ON r.movie_id = g.movie_id\n  WHERE r.avg_rating > 8\n  GROUP BY g.genre\n  ORDER BY movie_count DESC, g.genre\n  LIMIT 3\n),\ndirector_counts AS (\n  SELECT\n    n.id   AS director_id,\n    n.name AS director_name,\n    COUNT(DISTINCT dm.movie_id) AS movie_count\n  FROM director_mapping dm\n  JOIN ratings r\n    ON r.movie_id = dm.movie_id\n  JOIN genre g\n    ON g.movie_id = dm.movie_id\n  JOIN top_genres tg\n    ON tg.genre = g.genre\n  JOIN names n\n    ON n.id = dm.name_id\n  WHERE r.avg_rating > 8\n  GROUP BY n.id, n.name\n),\nranked AS (\n  SELECT\n    director_name,\n    movie_count,\n    DENSE_RANK() OVER (ORDER BY movie_count DESC, director_name) AS rnk\n  FROM director_counts\n)\nSELECT\n  director_name,\n  movie_count\nFROM ranked\nWHERE rnk <= 4\nORDER BY movie_count DESC, director_name;\t----- bird -----\timdb_movies_spider2",
    "67": "WITH all_scores AS (\n  SELECT MatchID, GameNumber, BowlerID, HandiCapScore, WonGame\n  FROM Bowler_Scores\n  UNION ALL\n  SELECT MatchID, GameNumber, BowlerID, HandiCapScore, WonGame\n  FROM Bowler_Scores_Archive\n),\nall_matches AS (\n  SELECT MatchID, TourneyID\n  FROM Tourney_Matches\n  UNION ALL\n  SELECT MatchID, TourneyID\n  FROM Tourney_Matches_Archive\n),\nall_tourneys AS (\n  SELECT TourneyID, TourneyDate, TourneyLocation\n  FROM Tournaments\n  UNION ALL\n  SELECT TourneyID, TourneyDate, TourneyLocation\n  FROM Tournaments_Archive\n),\nqualifying_wins AS (\n  SELECT\n    s.BowlerID,\n    s.MatchID,\n    s.GameNumber,\n    s.HandiCapScore,\n    t.TourneyDate,\n    t.TourneyLocation\n  FROM all_scores s\n  JOIN all_matches m\n    ON m.MatchID = s.MatchID\n  JOIN all_tourneys t\n    ON t.TourneyID = m.TourneyID\n  WHERE s.WonGame = 1\n    AND s.HandiCapScore <= 190\n    AND t.TourneyLocation IN ('Thunderbird Lanes', 'Totem Lanes', 'Bolero Lanes')\n),\nbowlers_with_all_3_venues AS (\n  SELECT BowlerID\n  FROM qualifying_wins\n  GROUP BY BowlerID\n  HAVING COUNT(DISTINCT TourneyLocation) = 3\n)\nSELECT\n  b.BowlerID,\n  b.BowlerFirstName,\n  b.BowlerLastName,\n  q.MatchID,\n  q.GameNumber,\n  q.HandiCapScore,\n  q.TourneyDate,\n  q.TourneyLocation\nFROM qualifying_wins q\nJOIN bowlers_with_all_3_venues v\n  ON v.BowlerID = q.BowlerID\nJOIN Bowlers b\n  ON b.BowlerID = q.BowlerID\nORDER BY\n  b.BowlerLastName,\n  b.BowlerFirstName,\n  q.TourneyDate,\n  q.MatchID,\n  q.GameNumber;\t----- bird -----\tBowlingLeague_spider2",
    "72": "WITH sales_by_year AS (\n  SELECT\n    soh.salespersonid AS BusinessEntityID,\n    CAST(strftime('%Y', soh.orderdate) AS INTEGER) AS SalesYear,\n    SUM(soh.subtotal) AS TotalSales\n  FROM salesorderheader AS soh\n  WHERE soh.salespersonid IS NOT NULL\n  GROUP BY\n    soh.salespersonid,\n    CAST(strftime('%Y', soh.orderdate) AS INTEGER)\n),\nquota_by_year AS (\n  SELECT\n    sqh.BusinessEntityID,\n    CAST(strftime('%Y', sqh.QuotaDate) AS INTEGER) AS SalesYear,\n    SUM(sqh.SalesQuota) AS TotalQuota\n  FROM SalesPersonQuotaHistory AS sqh\n  GROUP BY\n    sqh.BusinessEntityID,\n    CAST(strftime('%Y', sqh.QuotaDate) AS INTEGER)\n),\nyears AS (\n  SELECT BusinessEntityID, SalesYear FROM sales_by_year\n  UNION\n  SELECT BusinessEntityID, SalesYear FROM quota_by_year\n)\nSELECT\n  y.BusinessEntityID,\n  y.SalesYear,\n  COALESCE(s.TotalSales, 0.0) AS TotalSales,\n  COALESCE(q.TotalQuota, 0.0) AS TotalQuota,\n  COALESCE(s.TotalSales, 0.0) - COALESCE(q.TotalQuota, 0.0) AS SalesMinusQuota\nFROM years AS y\nLEFT JOIN sales_by_year AS s\n  ON s.BusinessEntityID = y.BusinessEntityID\n AND s.SalesYear = y.SalesYear\nLEFT JOIN quota_by_year AS q\n  ON q.BusinessEntityID = y.BusinessEntityID\n AND q.SalesYear = y.SalesYear\nORDER BY\n  y.BusinessEntityID,\n  y.SalesYear;\t----- bird -----\tAdventureWorks_spider2",
    "77": "WITH rank_avg AS (\n  SELECT\n    FacRank,\n    AVG(FacSalary) AS avg_salary\n  FROM university_faculty\n  WHERE FacRank IS NOT NULL\n    AND FacSalary IS NOT NULL\n  GROUP BY FacRank\n),\nrank_diff AS (\n  SELECT\n    f.FacRank,\n    f.FacFirstName,\n    f.FacLastName,\n    f.FacSalary,\n    ABS(f.FacSalary - ra.avg_salary) AS diff_to_avg\n  FROM university_faculty f\n  JOIN rank_avg ra\n    ON ra.FacRank = f.FacRank\n),\nrank_min AS (\n  SELECT\n    FacRank,\n    MIN(diff_to_avg) AS min_diff\n  FROM rank_diff\n  GROUP BY FacRank\n)\nSELECT\n  d.FacRank,\n  d.FacFirstName,\n  d.FacLastName,\n  d.FacSalary\nFROM rank_diff d\nJOIN rank_min m\n  ON m.FacRank = d.FacRank\n AND m.min_diff = d.diff_to_avg\nORDER BY d.FacRank, d.FacLastName, d.FacFirstName;\t----- bird -----\teducation_business_spider2",
    "68": "WITH EnglishCompletions AS (\n  SELECT\n    s.StudentID,\n    s.StudLastName,\n    ss.Grade\n  FROM Student_Schedules ss\n  JOIN Students s  ON s.StudentID = ss.StudentID\n  JOIN Classes c   ON c.ClassID = ss.ClassID\n  JOIN Subjects sub ON sub.SubjectID = c.SubjectID\n  WHERE ss.ClassStatus = 2\n    AND sub.SubjectName LIKE '%English%'\n),\nTotals AS (\n  SELECT COUNT(*) AS total_completed\n  FROM EnglishCompletions\n),\nRanked AS (\n  SELECT\n    ec.StudentID,\n    ec.StudLastName,\n    ec.Grade,\n    (SELECT COUNT(*)\n     FROM EnglishCompletions ec2\n     WHERE ec2.Grade >= ec.Grade) AS ge_rank,\n    t.total_completed\n  FROM EnglishCompletions ec\n  CROSS JOIN Totals t\n)\nSELECT\n  StudLastName,\n  CASE\n    WHEN (1.0 * ge_rank / total_completed) <= 0.20 THEN 'First'\n    WHEN (1.0 * ge_rank / total_completed) <= 0.40 THEN 'Second'\n    WHEN (1.0 * ge_rank / total_completed) <= 0.60 THEN 'Third'\n    WHEN (1.0 * ge_rank / total_completed) <= 0.80 THEN 'Fourth'\n    ELSE 'Fifth'\n  END AS Quintile\nFROM Ranked\nORDER BY\n  CASE\n    WHEN (1.0 * ge_rank / total_completed) <= 0.20 THEN 1\n    WHEN (1.0 * ge_rank / total_completed) <= 0.40 THEN 2\n    WHEN (1.0 * ge_rank / total_completed) <= 0.60 THEN 3\n    WHEN (1.0 * ge_rank / total_completed) <= 0.80 THEN 4\n    ELSE 5\n  END,\n  Grade DESC,\n  StudLastName;\t----- bird -----\tschool_scheduling_spider2",
    "78": "WITH filtered_jobs AS (\n  SELECT j.job_id, j.salary_year_avg\n  FROM job_postings_fact AS j\n  WHERE j.job_title_short = 'Data Analyst'\n    AND j.salary_year_avg IS NOT NULL\n    AND j.job_work_from_home = 1\n),\nskill_counts AS (\n  SELECT sj.skill_id, COUNT(*) AS demand_count\n  FROM skills_job_dim AS sj\n  JOIN filtered_jobs AS fj\n    ON fj.job_id = sj.job_id\n  GROUP BY sj.skill_id\n),\ntop_skills AS (\n  SELECT skill_id\n  FROM skill_counts\n  ORDER BY demand_count DESC, skill_id\n  LIMIT 3\n),\njobs_with_top_skills AS (\n  SELECT DISTINCT fj.job_id, fj.salary_year_avg\n  FROM filtered_jobs AS fj\n  JOIN skills_job_dim AS sj\n    ON sj.job_id = fj.job_id\n  JOIN top_skills AS ts\n    ON ts.skill_id = sj.skill_id\n)\nSELECT AVG(salary_year_avg) AS avg_salary_year_top3_skills_remote_data_analyst\nFROM jobs_with_top_skills;\t----- bird -----\tcity_legislation_spider2",
    "73": "WITH director_movies AS (\n  SELECT\n    dm.name_id AS director_id,\n    dm.movie_id,\n    m.date_published,\n    m.duration,\n    r.avg_rating,\n    r.total_votes\n  FROM director_mapping dm\n  JOIN movies m\n    ON m.id = dm.movie_id\n  LEFT JOIN ratings r\n    ON r.movie_id = dm.movie_id\n),\ndirector_gaps AS (\n  SELECT\n    director_id,\n    movie_id,\n    date_published,\n    duration,\n    avg_rating,\n    total_votes,\n    CAST(\n      (julianday(date_published) - julianday(LAG(date_published) OVER (\n        PARTITION BY director_id\n        ORDER BY date_published\n      ))) AS REAL\n    ) AS gap_days\n  FROM director_movies\n)\nSELECT\n  dg.director_id AS id,\n  n.name,\n  COUNT(*) AS number_of_movies,\n  ROUND(AVG(gap_days)) AS avg_inter_movie_duration,\n  ROUND(AVG(dg.avg_rating), 2) AS avg_rating,\n  SUM(COALESCE(dg.total_votes, 0)) AS total_votes,\n  MIN(dg.avg_rating) AS min_rating,\n  MAX(dg.avg_rating) AS max_rating,\n  SUM(COALESCE(dg.duration, 0)) AS total_movie_duration\nFROM director_gaps dg\nJOIN names n\n  ON n.id = dg.director_id\nGROUP BY\n  dg.director_id,\n  n.name\nORDER BY\n  number_of_movies DESC,\n  total_movie_duration DESC\nLIMIT 9;\t----- bird -----\timdb_movies_spider2",
    "71": "WITH\n-- Rank each entertainer's styles by strength (top 3)\nent_styles AS (\n  SELECT\n    es.EntertainerID,\n    es.StyleID,\n    ROW_NUMBER() OVER (\n      PARTITION BY es.EntertainerID\n      ORDER BY es.StyleStrength DESC, es.StyleID\n    ) AS rn\n  FROM Entertainer_Styles es\n),\nent_top AS (\n  SELECT\n    EntertainerID,\n    MAX(CASE WHEN rn = 1 THEN StyleID END) AS ent_style1,\n    MAX(CASE WHEN rn = 2 THEN StyleID END) AS ent_style2\n  FROM ent_styles\n  WHERE rn <= 3\n  GROUP BY EntertainerID\n),\n\n-- Rank each customer's preferences by sequence (top 3)\ncust_prefs AS (\n  SELECT\n    mp.CustomerID,\n    mp.StyleID,\n    ROW_NUMBER() OVER (\n      PARTITION BY mp.CustomerID\n      ORDER BY mp.PreferenceSeq, mp.StyleID\n    ) AS rn\n  FROM Musical_Preferences mp\n),\ncust_top AS (\n  SELECT\n    CustomerID,\n    MAX(CASE WHEN rn = 1 THEN StyleID END) AS cust_style1,\n    MAX(CASE WHEN rn = 2 THEN StyleID END) AS cust_style2\n  FROM cust_prefs\n  WHERE rn <= 3\n  GROUP BY CustomerID\n)\n\nSELECT DISTINCT\n  e.EntStageName,\n  c.CustLastName\nFROM ent_top et\nJOIN Entertainers e ON e.EntertainerID = et.EntertainerID\nJOIN cust_top ct\nJOIN Customers c ON c.CustomerID = ct.CustomerID\nWHERE\n  et.ent_style1 IS NOT NULL AND et.ent_style2 IS NOT NULL\n  AND ct.cust_style1 IS NOT NULL AND ct.cust_style2 IS NOT NULL\n  AND (\n    (ct.cust_style1 = et.ent_style1 AND ct.cust_style2 = et.ent_style2)\n    OR\n    (ct.cust_style1 = et.ent_style2 AND ct.cust_style2 = et.ent_style1)\n  );\t----- bird -----\tEntertainmentAgency_spider2",
    "76": "WITH parsed AS (\n  SELECT\n    ticker,\n    market_date,\n    -- Convert volume text to a numeric value:\n    -- '-' -> 0\n    -- '12.3K' -> 12300\n    -- '4.5M'  -> 4500000\n    CASE\n      WHEN volume IS NULL OR TRIM(volume) = '-' THEN 0.0\n      WHEN UPPER(TRIM(volume)) LIKE '%K' THEN CAST(REPLACE(UPPER(TRIM(volume)), 'K', '') AS REAL) * 1000.0\n      WHEN UPPER(TRIM(volume)) LIKE '%M' THEN CAST(REPLACE(UPPER(TRIM(volume)), 'M', '') AS REAL) * 1000000.0\n      ELSE CAST(TRIM(volume) AS REAL)\n    END AS volume_num\n  FROM bitcoin_prices\n),\nfiltered AS (\n  SELECT *\n  FROM parsed\n  WHERE market_date BETWEEN '2021-08-01' AND '2021-08-10'\n),\nwith_prev AS (\n  SELECT\n    f.ticker,\n    f.market_date,\n    f.volume_num,\n    (\n      SELECT p.volume_num\n      FROM parsed p\n      WHERE p.ticker = f.ticker\n        AND p.market_date < f.market_date\n        AND p.volume_num <> 0\n      ORDER BY p.market_date DESC\n      LIMIT 1\n    ) AS prev_nonzero_volume\n  FROM filtered f\n)\nSELECT\n  ticker,\n  market_date,\n  volume_num AS volume,\n  prev_nonzero_volume AS prev_volume,\n  CASE\n    WHEN prev_nonzero_volume IS NULL OR prev_nonzero_volume = 0 THEN NULL\n    ELSE ROUND((volume_num - prev_nonzero_volume) * 100.0 / prev_nonzero_volume, 6)\n  END AS daily_volume_pct_change\nFROM with_prev\nORDER BY ticker, market_date;\t----- bird -----\tbank_sales_trading_spider2",
    "81": "WITH female_legislators AS (\n  SELECT l.id_bioguide\n  FROM legislators AS l\n  WHERE l.gender = 'F'\n),\nfirst_state AS (\n  -- State each female legislator first represented (earliest term_start)\n  SELECT lt.id_bioguide,\n         lt.state\n  FROM legislators_terms AS lt\n  JOIN female_legislators AS fl\n    ON fl.id_bioguide = lt.id_bioguide\n  WHERE lt.term_start = (\n    SELECT MIN(lt2.term_start)\n    FROM legislators_terms AS lt2\n    WHERE lt2.id_bioguide = lt.id_bioguide\n  )\n),\nhas_dec31_term AS (\n  -- Female legislators who had at least one term that included Dec 31 of some year\n  SELECT DISTINCT lt.id_bioguide\n  FROM legislators_terms AS lt\n  JOIN female_legislators AS fl\n    ON fl.id_bioguide = lt.id_bioguide\n  WHERE date(lt.term_start) <= date(strftime('%Y', lt.term_end) || '-12-31')\n    AND date(lt.term_end)   >= date(strftime('%Y', lt.term_start) || '-12-31')\n)\nSELECT fs.state AS state_abbreviation,\n       COUNT(*) AS female_legislator_count\nFROM first_state AS fs\nJOIN has_dec31_term AS d\n  ON d.id_bioguide = fs.id_bioguide\nGROUP BY fs.state\nORDER BY female_legislator_count DESC, fs.state\nLIMIT 1;\t----- bird -----\tcity_legislation_spider2",
    "75": "WITH buy_txns AS (\n  SELECT\n    m.region,\n    CAST(strftime('%Y', t.txn_date) AS INTEGER) AS yr,\n    SUM(t.quantity) AS total_qty_bought,\n    SUM(t.quantity * p.price) AS total_usd_spent\n  FROM bitcoin_transactions t\n  JOIN bitcoin_members m\n    ON m.member_id = t.member_id\n  JOIN bitcoin_prices p\n    ON p.ticker = t.ticker\n   AND p.market_date = t.txn_date\n  WHERE t.txn_type = 'BUY'\n  GROUP BY m.region, CAST(strftime('%Y', t.txn_date) AS INTEGER)\n),\nannual_avg AS (\n  SELECT\n    region,\n    yr,\n    total_usd_spent,\n    total_qty_bought,\n    (total_usd_spent * 1.0) / NULLIF(total_qty_bought, 0) AS avg_purchase_price\n  FROM buy_txns\n),\nexclude_first_year AS (\n  SELECT a.*\n  FROM annual_avg a\n  JOIN (\n    SELECT region, MIN(yr) AS first_yr\n    FROM annual_avg\n    GROUP BY region\n  ) f\n    ON f.region = a.region\n   AND a.yr > f.first_yr\n),\nfinal AS (\n  SELECT\n    region,\n    yr AS year,\n    avg_purchase_price,\n    RANK() OVER (\n      PARTITION BY yr\n      ORDER BY avg_purchase_price DESC\n    ) AS region_rank_in_year,\n    LAG(avg_purchase_price) OVER (\n      PARTITION BY region\n      ORDER BY yr\n    ) AS prev_year_avg_purchase_price\n  FROM exclude_first_year\n)\nSELECT\n  region,\n  year,\n  avg_purchase_price,\n  region_rank_in_year,\n  CASE\n    WHEN prev_year_avg_purchase_price IS NULL OR prev_year_avg_purchase_price = 0 THEN NULL\n    ELSE 100.0 * (avg_purchase_price - prev_year_avg_purchase_price) / prev_year_avg_purchase_price\n  END AS pct_change_vs_prev_year\nFROM final\nORDER BY year, region_rank_in_year, region;\t----- bird -----\tbank_sales_trading_spider2",
    "80": "WITH male_la AS (\n  SELECT l.id_bioguide\n  FROM legislators l\n  WHERE l.gender = 'M'\n),\nla_terms AS (\n  SELECT\n    t.id_bioguide,\n    t.term_start,\n    t.term_end\n  FROM legislators_terms t\n  JOIN male_la ml\n    ON ml.id_bioguide = t.id_bioguide\n  WHERE t.state = 'LA'\n),\nfirst_term AS (\n  SELECT\n    id_bioguide,\n    MIN(term_start) AS first_term_start\n  FROM la_terms\n  GROUP BY id_bioguide\n),\nactive_on_dec31 AS (\n  -- For each year, count legislators who have any LA term covering Dec 31 of that year\n  SELECT\n    CAST(strftime('%Y', d.date) AS INTEGER) AS yr,\n    t.id_bioguide\n  FROM legislation_date_dim d\n  JOIN la_terms t\n    ON d.date BETWEEN t.term_start AND t.term_end\n  WHERE strftime('%m-%d', d.date) = '12-31'\n),\nelapsed AS (\n  SELECT\n    a.yr,\n    a.id_bioguide,\n    (a.yr - CAST(strftime('%Y', f.first_term_start) AS INTEGER)) AS years_since_first_term\n  FROM active_on_dec31 a\n  JOIN first_term f\n    ON f.id_bioguide = a.id_bioguide\n)\nSELECT\n  years_since_first_term,\n  COUNT(DISTINCT id_bioguide) AS distinct_legislators_active_on_dec31\nFROM elapsed\nWHERE years_since_first_term > 30\n  AND years_since_first_term < 50\nGROUP BY years_since_first_term\nORDER BY years_since_first_term;\t----- bird -----\tcity_legislation_spider2",
    "83": "WITH customer_payments AS (\n  SELECT\n    p.customer_id,\n    p.amount,\n    datetime(p.payment_date) AS payment_ts\n  FROM payment p\n),\nfirst_purchase AS (\n  SELECT\n    customer_id,\n    MIN(payment_ts) AS first_ts\n  FROM customer_payments\n  GROUP BY customer_id\n),\ncustomer_ltv AS (\n  SELECT\n    cp.customer_id,\n    fp.first_ts,\n    SUM(cp.amount) AS ltv_total,\n    SUM(\n      CASE\n        WHEN cp.payment_ts >= fp.first_ts\n         AND cp.payment_ts < datetime(fp.first_ts, '+7 days')\n        THEN cp.amount ELSE 0\n      END\n    ) AS ltv_7d,\n    SUM(\n      CASE\n        WHEN cp.payment_ts >= fp.first_ts\n         AND cp.payment_ts < datetime(fp.first_ts, '+30 days')\n        THEN cp.amount ELSE 0\n      END\n    ) AS ltv_30d\n  FROM customer_payments cp\n  JOIN first_purchase fp\n    ON fp.customer_id = cp.customer_id\n  GROUP BY cp.customer_id, fp.first_ts\n),\neligible AS (\n  SELECT *\n  FROM customer_ltv\n  WHERE ltv_total > 0\n)\nSELECT\n  AVG(ltv_total) AS avg_ltv_total,\n  AVG(100.0 * ltv_7d  / ltv_total) AS avg_pct_ltv_in_first_7_days,\n  AVG(100.0 * ltv_30d / ltv_total) AS avg_pct_ltv_in_first_30_days\nFROM eligible;\t----- bird -----\tsqlite-sakila_spider2",
    "85": "WITH actor_rentals AS (\n  SELECT\n    fa.actor_id,\n    COUNT(*) AS rental_cnt\n  FROM rental r\n  JOIN inventory i    ON i.inventory_id = r.inventory_id\n  JOIN film_actor fa  ON fa.film_id = i.film_id\n  GROUP BY fa.actor_id\n),\ntop5_actors AS (\n  SELECT actor_id\n  FROM actor_rentals\n  ORDER BY rental_cnt DESC\n  LIMIT 5\n),\ncustomers_who_rented_top5 AS (\n  SELECT DISTINCT r.customer_id\n  FROM rental r\n  JOIN inventory i    ON i.inventory_id = r.inventory_id\n  JOIN film_actor fa  ON fa.film_id = i.film_id\n  WHERE fa.actor_id IN (SELECT actor_id FROM top5_actors)\n)\nSELECT\n  ROUND(\n    100.0 * (SELECT COUNT(*) FROM customers_who_rented_top5)\n    / NULLIF((SELECT COUNT(*) FROM customer), 0),\n    2\n  ) AS pct_customers_rented_top5_actors;\t----- bird -----\tsqlite-sakila_spider2",
    "90": "WITH state_stats AS (\n  SELECT\n    state,\n    COUNT(*) AS alien_count,\n    AVG(age) AS avg_age,\n    SUM(CASE WHEN aggressive = 0 THEN 1 ELSE 0 END) * 1.0 / COUNT(*) AS pct_friendly,\n    SUM(CASE WHEN aggressive = 1 THEN 1 ELSE 0 END) * 1.0 / COUNT(*) AS pct_hostile\n  FROM alien_data\n  WHERE state IS NOT NULL AND TRIM(state) <> ''\n  GROUP BY state\n),\ntop10 AS (\n  SELECT *\n  FROM state_stats\n  ORDER BY alien_count DESC\n  LIMIT 10\n)\nSELECT\n  COUNT(*) AS num_states\nFROM top10\nWHERE avg_age > 200\n  AND pct_friendly > pct_hostile;\t----- bird -----\tcity_legislation_spider2",
    "88": "WITH rentals_by_store_month AS (\n  SELECT\n    s.store_id,\n    CAST(strftime('%Y', r.rental_date) AS INTEGER) AS year,\n    CAST(strftime('%m', r.rental_date) AS INTEGER) AS month,\n    COUNT(*) AS total_rentals\n  FROM rental r\n  JOIN staff s\n    ON s.staff_id = r.staff_id\n  GROUP BY\n    s.store_id,\n    CAST(strftime('%Y', r.rental_date) AS INTEGER),\n    CAST(strftime('%m', r.rental_date) AS INTEGER)\n),\nranked AS (\n  SELECT\n    store_id,\n    year,\n    month,\n    total_rentals,\n    DENSE_RANK() OVER (\n      PARTITION BY store_id\n      ORDER BY total_rentals DESC\n    ) AS rnk\n  FROM rentals_by_store_month\n)\nSELECT\n  store_id,\n  year,\n  month,\n  total_rentals\nFROM ranked\nWHERE rnk = 1\nORDER BY store_id, year, month;\t----- bird -----\tsqlite-sakila_spider2",
    "87": "WITH top_customers AS (\n  SELECT\n    p.customer_id,\n    SUM(p.amount) AS total_paid\n  FROM payment p\n  GROUP BY p.customer_id\n  ORDER BY total_paid DESC\n  LIMIT 10\n),\nmonthly_payments AS (\n  SELECT\n    p.customer_id,\n    date(p.payment_date, 'start of month') AS month_start,\n    SUM(p.amount) AS month_amount\n  FROM payment p\n  JOIN top_customers tc\n    ON tc.customer_id = p.customer_id\n  GROUP BY p.customer_id, date(p.payment_date, 'start of month')\n),\nmom AS (\n  SELECT\n    mp.customer_id,\n    mp.month_start,\n    mp.month_amount,\n    LAG(mp.month_amount) OVER (\n      PARTITION BY mp.customer_id\n      ORDER BY mp.month_start\n    ) AS prev_month_amount\n  FROM monthly_payments mp\n),\ndiffs AS (\n  SELECT\n    m.customer_id,\n    m.month_start,\n    (m.month_amount - m.prev_month_amount) AS mom_diff\n  FROM mom m\n  WHERE m.prev_month_amount IS NOT NULL\n)\nSELECT\n  d.customer_id,\n  c.first_name,\n  c.last_name,\n  strftime('%Y-%m', d.month_start) AS month,\n  ROUND(d.mom_diff, 2) AS month_over_month_difference\nFROM diffs d\nJOIN customer c\n  ON c.customer_id = d.customer_id\nORDER BY ABS(d.mom_diff) DESC\nLIMIT 1;\t----- bird -----\tsqlite-sakila_spider2",
    "91": "WITH store_order_counts AS (\n  SELECT\n    s.store_id,\n    s.store_name,\n    COUNT(*) AS total_orders\n  FROM orders o\n  JOIN stores s ON s.store_id = o.store_id\n  GROUP BY s.store_id, s.store_name\n),\ntop_store AS (\n  SELECT *\n  FROM store_order_counts\n  ORDER BY total_orders DESC, store_id\n  LIMIT 1\n)\nSELECT\n  ts.store_id,\n  ts.store_name,\n  ts.total_orders,\n  SUM(\n    CASE\n      WHEN d.delivery_id IS NOT NULL AND d.delivery_status = 'DELIVERED' THEN 1\n      ELSE 0\n    END\n  ) AS delivered_orders,\n  1.0 * SUM(\n    CASE\n      WHEN d.delivery_id IS NOT NULL AND d.delivery_status = 'DELIVERED' THEN 1\n      ELSE 0\n    END\n  ) / ts.total_orders AS delivered_to_total_ratio\nFROM top_store ts\nJOIN orders o\n  ON o.store_id = ts.store_id\nLEFT JOIN deliveries d\n  ON d.delivery_order_id = o.delivery_order_id\nGROUP BY ts.store_id, ts.store_name, ts.total_orders;\t----- bird -----\tdelivery_center_spider2",
    "84": "WITH film_revenue AS (\n  SELECT\n    i.film_id,\n    SUM(p.amount) AS total_revenue\n  FROM payment p\n  JOIN rental r    ON r.rental_id = p.rental_id\n  JOIN inventory i ON i.inventory_id = r.inventory_id\n  GROUP BY i.film_id\n),\nfilm_actor_counts AS (\n  SELECT\n    fa.film_id,\n    COUNT(*) AS actor_count\n  FROM film_actor fa\n  GROUP BY fa.film_id\n),\nactor_film_revenue AS (\n  SELECT\n    fa.actor_id,\n    fa.film_id,\n    f.title,\n    COALESCE(fr.total_revenue, 0.0) AS film_total_revenue,\n    COALESCE(fr.total_revenue, 0.0) * 1.0 / NULLIF(fac.actor_count, 0) AS actor_share_revenue\n  FROM film_actor fa\n  JOIN film f ON f.film_id = fa.film_id\n  LEFT JOIN film_revenue fr ON fr.film_id = fa.film_id\n  JOIN film_actor_counts fac ON fac.film_id = fa.film_id\n),\nranked AS (\n  SELECT\n    afr.*,\n    ROW_NUMBER() OVER (\n      PARTITION BY afr.actor_id\n      ORDER BY afr.actor_share_revenue DESC, afr.film_total_revenue DESC, afr.title\n    ) AS rn\n  FROM actor_film_revenue afr\n)\nSELECT\n  a.actor_id,\n  a.first_name,\n  a.last_name,\n  r.film_id,\n  r.title,\n  r.film_total_revenue,\n  r.actor_share_revenue,\n  AVG(r.actor_share_revenue) OVER (PARTITION BY r.actor_id) AS avg_revenue_per_actor_in_top3_films\nFROM ranked r\nJOIN actor a ON a.actor_id = r.actor_id\nWHERE r.rn <= 3\nORDER BY\n  a.last_name,\n  a.first_name,\n  r.actor_share_revenue DESC,\n  r.title;\t----- bird -----\tsqlite-sakila_spider2",
    "86": "WITH first_payment AS (\n  SELECT\n    p.customer_id,\n    p.payment_date,\n    p.rental_id,\n    ROW_NUMBER() OVER (\n      PARTITION BY p.customer_id\n      ORDER BY p.payment_date, p.payment_id\n    ) AS rn\n  FROM payment p\n),\nfirst_rental AS (\n  SELECT\n    fp.customer_id,\n    fp.payment_date AS first_payment_date,\n    r.inventory_id\n  FROM first_payment fp\n  JOIN rental r\n    ON r.rental_id = fp.rental_id\n  WHERE fp.rn = 1\n),\nfirst_film AS (\n  SELECT\n    fr.customer_id,\n    f.rating\n  FROM first_rental fr\n  JOIN inventory i\n    ON i.inventory_id = fr.inventory_id\n  JOIN film f\n    ON f.film_id = i.film_id\n),\ncustomer_totals AS (\n  SELECT\n    c.customer_id,\n    COALESCE(SUM(p.amount), 0.0) AS total_spent,\n    COUNT(DISTINCT r.rental_id) AS total_rentals\n  FROM customer c\n  LEFT JOIN payment p\n    ON p.customer_id = c.customer_id\n  LEFT JOIN rental r\n    ON r.customer_id = c.customer_id\n  GROUP BY c.customer_id\n)\nSELECT\n  ff.rating AS rating_category,\n  AVG(ct.total_spent) AS avg_total_amount_spent_per_customer,\n  AVG(ct.total_rentals - 1) AS avg_subsequent_rentals_per_customer\nFROM first_film ff\nJOIN customer_totals ct\n  ON ct.customer_id = ff.customer_id\nGROUP BY ff.rating\nORDER BY ff.rating;\t----- bird -----\tsqlite-sakila_spider2",
    "93": "WITH driver_daily AS (\n  SELECT\n    d.driver_id,\n    o.order_created_year AS yr,\n    o.order_created_month AS mo,\n    o.order_created_day AS dy,\n    COUNT(*) AS deliveries_in_day\n  FROM deliveries d\n  JOIN orders o\n    ON o.delivery_order_id = d.delivery_order_id\n  WHERE d.delivery_status = 'DELIVERED'\n  GROUP BY d.driver_id, yr, mo, dy\n),\ndriver_avg AS (\n  SELECT\n    driver_id,\n    AVG(deliveries_in_day) AS avg_daily_deliveries\n  FROM driver_daily\n  GROUP BY driver_id\n)\nSELECT\n  driver_id,\n  avg_daily_deliveries\nFROM driver_avg\nORDER BY avg_daily_deliveries DESC\nLIMIT 5;\t----- bird -----\tdelivery_center_spider2",
    "89": "WITH candidates AS (\n  SELECT\n    words AS word\n  FROM word_list\n  WHERE length(words) BETWEEN 4 AND 5\n    AND substr(words, 1, 1) = 'r'\n),\nsigged AS (\n  SELECT\n    word,\n    length(word) AS len,\n    (\n      SELECT group_concat(ch, '')\n      FROM (\n        WITH RECURSIVE chars(pos, ch) AS (\n          SELECT 1, substr(word, 1, 1)\n          UNION ALL\n          SELECT pos + 1, substr(word, pos + 1, 1)\n          FROM chars\n          WHERE pos < length(word)\n        )\n        SELECT ch\n        FROM chars\n        ORDER BY ch\n      )\n    ) AS signature\n  FROM candidates\n),\nanagram_counts AS (\n  SELECT\n    signature,\n    len,\n    COUNT(*) AS anagram_count\n  FROM sigged\n  GROUP BY signature, len\n  HAVING COUNT(*) >= 2\n)\nSELECT\n  s.word,\n  ac.anagram_count\nFROM sigged s\nJOIN anagram_counts ac\n  ON ac.signature = s.signature\n AND ac.len = s.len\nORDER BY s.word\nLIMIT 10;\t----- bird -----\tmodern_data_spider2",
    "79": "WITH cohort AS (\n  -- Legislators whose FIRST-EVER term started in the window\n  SELECT\n    lt.id_bioguide,\n    MIN(date(lt.term_start)) AS first_start\n  FROM legislators_terms lt\n  GROUP BY lt.id_bioguide\n  HAVING first_start BETWEEN date('1917-01-01') AND date('1999-12-31')\n),\ncohort_size AS (\n  SELECT COUNT(*) AS n_cohort\n  FROM cohort\n),\nperiods AS (\n  -- First 20 years following initial term start: year 1..20\n  WITH RECURSIVE p(n) AS (\n    SELECT 1\n    UNION ALL\n    SELECT n + 1 FROM p WHERE n < 20\n  )\n  SELECT n AS year_number FROM p\n),\nretained AS (\n  -- For each cohort member and each year_number, check if they are in office on Dec 31 of that year\n  SELECT\n    p.year_number,\n    c.id_bioguide,\n    date(c.first_start, printf('+%d years', p.year_number), '-1 day') AS as_of_date,\n    EXISTS (\n      SELECT 1\n      FROM legislators_terms lt\n      WHERE lt.id_bioguide = c.id_bioguide\n        AND date(lt.term_start) <= date(c.first_start, printf('+%d years', p.year_number), '-1 day')\n        AND date(COALESCE(lt.term_end, '9999-12-31')) >= date(c.first_start, printf('+%d years', p.year_number), '-1 day')\n    ) AS is_retained\n  FROM cohort c\n  CROSS JOIN periods p\n)\nSELECT\n  p.year_number AS year_since_first_term_start,\n  date('1917-01-01', printf('+%d years', p.year_number), '-1 day') AS period_end_month_day, -- always Dec 31 conceptually\n  SUM(CASE WHEN r.is_retained THEN 1 ELSE 0 END) AS retained_legislators,\n  cs.n_cohort AS cohort_size,\n  ROUND(1.0 * SUM(CASE WHEN r.is_retained THEN 1 ELSE 0 END) / cs.n_cohort, 6) AS retention_rate\nFROM periods p\nCROSS JOIN cohort_size cs\nLEFT JOIN retained r\n  ON r.year_number = p.year_number\nGROUP BY p.year_number, cs.n_cohort\nORDER BY p.year_number;\t----- bird -----\tcity_legislation_spider2",
    "82": "WITH first_term AS (\n  SELECT\n    l.id_bioguide,\n    l.gender,\n    lt.state,\n    MIN(date(lt.term_start)) AS first_start\n  FROM legislators l\n  JOIN legislators_terms lt\n    ON lt.id_bioguide = l.id_bioguide\n  WHERE l.gender IN ('M','F')\n    AND lt.state IS NOT NULL\n    AND lt.term_start IS NOT NULL\n  GROUP BY l.id_bioguide, l.gender, lt.state\n),\ntimepoints AS (\n  SELECT 0 AS yrs UNION ALL\n  SELECT 2 UNION ALL\n  SELECT 4 UNION ALL\n  SELECT 6 UNION ALL\n  SELECT 8 UNION ALL\n  SELECT 10\n),\ncohort AS (\n  -- one row per legislator per timepoint with the \"as-of\" date = Dec 31 of (first_start year + yrs)\n  SELECT\n    ft.id_bioguide,\n    ft.gender,\n    ft.state,\n    tp.yrs,\n    date(\n      printf('%04d-12-31', CAST(strftime('%Y', ft.first_start) AS INTEGER) + tp.yrs)\n    ) AS asof_date\n  FROM first_term ft\n  CROSS JOIN timepoints tp\n),\nretention AS (\n  -- retained if serving on asof_date (any term covering that date)\n  SELECT\n    c.state,\n    c.gender,\n    c.yrs,\n    COUNT(*) AS cohort_size,\n    SUM(\n      CASE WHEN EXISTS (\n        SELECT 1\n        FROM legislators_terms lt\n        WHERE lt.id_bioguide = c.id_bioguide\n          AND date(lt.term_start) <= c.asof_date\n          AND date(COALESCE(lt.term_end, '9999-12-31')) >= c.asof_date\n      ) THEN 1 ELSE 0 END\n    ) AS retained_cnt\n  FROM cohort c\n  GROUP BY c.state, c.gender, c.yrs\n),\nstates_passing AS (\n  SELECT\n    state\n  FROM retention\n  GROUP BY state\n  HAVING\n    -- must have both genders present at all 6 timepoints\n    COUNT(DISTINCT CASE WHEN gender IN ('M','F') THEN gender || ':' || yrs END) = 12\n    -- and for every gender/timepoint, retained_cnt > 0 (=> retention rate > 0)\n    AND MIN(retained_cnt) > 0\n)\nSELECT state\nFROM states_passing\nORDER BY state;\t----- bird -----\tcity_legislation_spider2",
    "94": "WITH team_season_goals AS (\n  -- Total goals scored by each team in each season (home + away)\n  SELECT\n    season,\n    team_api_id,\n    SUM(goals) AS season_goals\n  FROM (\n    SELECT\n      m.season,\n      m.home_team_api_id AS team_api_id,\n      m.home_team_goal    AS goals\n    FROM Match m\n    UNION ALL\n    SELECT\n      m.season,\n      m.away_team_api_id AS team_api_id,\n      m.away_team_goal    AS goals\n    FROM Match m\n  )\n  GROUP BY season, team_api_id\n),\nteam_best_season AS (\n  -- Highest (best) season goal total for each team across all seasons\n  SELECT\n    team_api_id,\n    MAX(season_goals) AS best_season_goals\n  FROM team_season_goals\n  GROUP BY team_api_id\n),\nordered AS (\n  SELECT\n    best_season_goals,\n    ROW_NUMBER() OVER (ORDER BY best_season_goals) AS rn,\n    COUNT(*) OVER () AS cnt\n  FROM team_best_season\n)\nSELECT\n  AVG(best_season_goals) AS median_best_season_goals\nFROM ordered\nWHERE rn IN ( (cnt + 1) / 2, (cnt + 2) / 2 );\t----- bird -----\tEU_soccer_spider2",
    "96": "WITH results AS (\n  -- Home wins\n  SELECT\n    m.league_id,\n    m.home_team_api_id AS team_api_id,\n    1 AS wins\n  FROM Match AS m\n  WHERE m.home_team_goal > m.away_team_goal\n\n  UNION ALL\n\n  -- Away wins\n  SELECT\n    m.league_id,\n    m.away_team_api_id AS team_api_id,\n    1 AS wins\n  FROM Match AS m\n  WHERE m.away_team_goal > m.home_team_goal\n),\nteam_wins AS (\n  SELECT\n    r.league_id,\n    l.name AS league_name,\n    r.team_api_id,\n    t.team_long_name AS team_name,\n    SUM(r.wins) AS total_wins\n  FROM results r\n  JOIN League l ON l.id = r.league_id\n  JOIN Team t ON t.team_api_id = r.team_api_id\n  GROUP BY r.league_id, l.name, r.team_api_id, t.team_long_name\n)\nSELECT\n  league_name,\n  team_name,\n  total_wins\nFROM team_wins\nORDER BY total_wins DESC, league_name, team_name\nLIMIT 10;\t----- bird -----\tEU_soccer_spider2",
    "92": "WITH finished_by_hub_month AS (\n  SELECT\n    h.hub_id,\n    h.hub_name,\n    o.order_created_year AS yr,\n    o.order_created_month AS mo,\n    COUNT(*) AS finished_orders\n  FROM orders o\n  JOIN stores s ON s.store_id = o.store_id\n  JOIN hubs h ON h.hub_id = s.hub_id\n  WHERE o.order_status = 'FINISHED'\n    AND o.order_created_month IN (2, 3)\n  GROUP BY h.hub_id, h.hub_name, o.order_created_year, o.order_created_month\n),\nfeb_mar AS (\n  SELECT\n    hub_id,\n    hub_name,\n    yr,\n    SUM(CASE WHEN mo = 2 THEN finished_orders ELSE 0 END) AS feb_finished,\n    SUM(CASE WHEN mo = 3 THEN finished_orders ELSE 0 END) AS mar_finished\n  FROM finished_by_hub_month\n  GROUP BY hub_id, hub_name, yr\n)\nSELECT\n  hub_id,\n  hub_name,\n  yr AS order_year,\n  feb_finished,\n  mar_finished,\n  ROUND(100.0 * (mar_finished - feb_finished) / NULLIF(feb_finished, 0), 2) AS pct_increase\nFROM feb_mar\nWHERE feb_finished > 0\n  AND mar_finished > feb_finished * 1.20\nORDER BY pct_increase DESC, mar_finished DESC;\t----- bird -----\tdelivery_center_spider2",
    "106": "WITH categorized AS (\n  SELECT\n    CASE\n      WHEN m.L1_model = 'Stack' THEN 'Stack'\n      ELSE 'Traditional'\n    END AS model_category\n  FROM model AS m\n  WHERE m.L1_model IS NOT NULL\n),\ncounts AS (\n  SELECT\n    model_category,\n    COUNT(*) AS total_count\n  FROM categorized\n  GROUP BY model_category\n)\nSELECT\n  model_category AS L1_model_category,\n  total_count\nFROM counts\nORDER BY total_count DESC\nLIMIT 1;\t----- bird -----\tstacking_spider2",
    "104": "WITH stack_scores AS (\n  SELECT\n    name,\n    version,\n    step,\n    test_score AS stack_test_score\n  FROM model_score\n  WHERE model = 'Stack'\n    AND step IN (1, 2, 3)\n),\nnonstack_max AS (\n  SELECT\n    name,\n    version,\n    step,\n    MAX(test_score) AS max_nonstack_test_score\n  FROM model_score\n  WHERE model <> 'Stack'\n    AND step IN (1, 2, 3)\n  GROUP BY name, version, step\n),\nqualified AS (\n  SELECT\n    s.name,\n    s.version,\n    s.step\n  FROM stack_scores s\n  JOIN nonstack_max n\n    ON n.name = s.name\n   AND n.version = s.version\n   AND n.step = s.step\n  WHERE n.max_nonstack_test_score < s.stack_test_score\n),\nsolution_counts AS (\n  SELECT\n    name,\n    COUNT(*) AS solution_occurrences\n  FROM solution\n  GROUP BY name\n),\nqualified_counts AS (\n  SELECT\n    name,\n    COUNT(*) AS qualified_occurrences\n  FROM qualified\n  GROUP BY name\n)\nSELECT\n  qc.name\nFROM qualified_counts qc\nJOIN solution_counts sc\n  ON sc.name = qc.name\nWHERE qc.qualified_occurrences > sc.solution_occurrences\nORDER BY qc.name;\t----- bird -----\tstacking_spider2",
    "95": "WITH all_teams AS (\n  -- all teams that ever appeared in a league (home or away)\n  SELECT DISTINCT m.league_id, m.home_team_api_id AS team_api_id\n  FROM Match m\n  UNION\n  SELECT DISTINCT m.league_id, m.away_team_api_id AS team_api_id\n  FROM Match m\n),\nwins AS (\n  -- count wins per (league, team) across all seasons\n  SELECT\n    m.league_id,\n    m.home_team_api_id AS team_api_id,\n    SUM(CASE WHEN m.home_team_goal > m.away_team_goal THEN 1 ELSE 0 END) AS win_cnt\n  FROM Match m\n  GROUP BY m.league_id, m.home_team_api_id\n\n  UNION ALL\n\n  SELECT\n    m.league_id,\n    m.away_team_api_id AS team_api_id,\n    SUM(CASE WHEN m.away_team_goal > m.home_team_goal THEN 1 ELSE 0 END) AS win_cnt\n  FROM Match m\n  GROUP BY m.league_id, m.away_team_api_id\n),\nwins_by_team AS (\n  SELECT\n    league_id,\n    team_api_id,\n    SUM(win_cnt) AS total_wins\n  FROM wins\n  GROUP BY league_id, team_api_id\n),\nleague_team_wins AS (\n  -- include teams with zero wins\n  SELECT\n    at.league_id,\n    at.team_api_id,\n    COALESCE(wbt.total_wins, 0) AS total_wins\n  FROM all_teams at\n  LEFT JOIN wins_by_team wbt\n    ON wbt.league_id = at.league_id\n   AND wbt.team_api_id = at.team_api_id\n),\nranked AS (\n  SELECT\n    ltw.league_id,\n    ltw.team_api_id,\n    ltw.total_wins,\n    ROW_NUMBER() OVER (\n      PARTITION BY ltw.league_id\n      ORDER BY ltw.total_wins ASC, ltw.team_api_id ASC\n    ) AS rn\n  FROM league_team_wins ltw\n)\nSELECT\n  l.name AS league_name,\n  t.team_long_name AS team_name,\n  r.total_wins\nFROM ranked r\nJOIN League l\n  ON l.id = r.league_id\nJOIN Team t\n  ON t.team_api_id = r.team_api_id\nWHERE r.rn = 1\nORDER BY l.name;\t----- bird -----\tEU_soccer_spider2",
    "100": "WITH stats AS (\n  SELECT\n    MIN(t.Milliseconds) AS min_ms,\n    AVG(t.Milliseconds) AS avg_ms,\n    MAX(t.Milliseconds) AS max_ms\n  FROM Track t\n),\nbounds AS (\n  SELECT\n    min_ms,\n    avg_ms,\n    max_ms,\n    (min_ms + avg_ms) / 2.0 AS mid_min_avg,\n    (avg_ms + max_ms) / 2.0 AS mid_avg_max\n  FROM stats\n),\ntrack_class AS (\n  SELECT\n    t.TrackId,\n    CASE\n      WHEN t.Milliseconds >= b.min_ms AND t.Milliseconds <  b.mid_min_avg THEN 'Short'\n      WHEN t.Milliseconds >= b.mid_min_avg AND t.Milliseconds <  b.mid_avg_max THEN 'Medium'\n      WHEN t.Milliseconds >= b.mid_avg_max AND t.Milliseconds <= b.max_ms THEN 'Long'\n    END AS length_type,\n    t.Milliseconds\n  FROM Track t\n  CROSS JOIN bounds b\n),\nrevenue_by_track AS (\n  SELECT\n    il.TrackId,\n    SUM(il.UnitPrice * il.Quantity) AS revenue\n  FROM InvoiceLine il\n  GROUP BY il.TrackId\n)\nSELECT\n  tc.length_type AS category,\n  ROUND(MIN(tc.Milliseconds) / 60000.0, 4) AS min_minutes,\n  ROUND(MAX(tc.Milliseconds) / 60000.0, 4) AS max_minutes,\n  ROUND(COALESCE(SUM(rbt.revenue), 0), 2) AS total_revenue\nFROM track_class tc\nLEFT JOIN revenue_by_track rbt\n  ON rbt.TrackId = tc.TrackId\nGROUP BY tc.length_type\nORDER BY\n  CASE tc.length_type\n    WHEN 'Short' THEN 1\n    WHEN 'Medium' THEN 2\n    WHEN 'Long' THEN 3\n  END;\t----- bird -----\tmusic_spider2",
    "101": "WITH cleaned AS (\n  SELECT\n    CompanyName,\n    Location,\n    CAST(\n      NULLIF(\n        REPLACE(\n          REPLACE(\n            REPLACE(\n              REPLACE(\n                REPLACE(\n                  REPLACE(\n                    REPLACE(\n                      REPLACE(LOWER(Salary), '\u20b9', ''),\n                    '$', ''),\n                  ',', ''),\n                'per year', ''),\n              'per annum', ''),\n            'pa', ''),\n          'lpa', ''),\n        ' ', ''\n      ) AS REAL\n    ) AS salary_num\n  FROM SalaryDataset\n  WHERE Location IN ('Mumbai', 'Pune', 'New Delhi', 'Hyderabad')\n),\nvalid AS (\n  SELECT *\n  FROM cleaned\n  WHERE salary_num IS NOT NULL\n    AND salary_num > 0\n),\ncountry_avg AS (\n  SELECT AVG(salary_num) AS avg_salary_country\n  FROM valid\n),\ncompany_city_avg AS (\n  SELECT\n    Location,\n    CompanyName,\n    AVG(salary_num) AS avg_salary_city\n  FROM valid\n  GROUP BY Location, CompanyName\n),\nranked AS (\n  SELECT\n    c.Location,\n    c.CompanyName,\n    c.avg_salary_city,\n    (SELECT avg_salary_country FROM country_avg) AS avg_salary_country,\n    ROW_NUMBER() OVER (\n      PARTITION BY c.Location\n      ORDER BY c.avg_salary_city DESC\n    ) AS rn\n  FROM company_city_avg c\n)\nSELECT\n  Location AS \"Location\",\n  CompanyName AS \"Company Name\",\n  ROUND(avg_salary_city, 2) AS \"Average Salary in State\",\n  ROUND(avg_salary_country, 2) AS \"Average Salary in Country\"\nFROM ranked\nWHERE rn <= 5\nORDER BY\n  Location,\n  \"Average Salary in State\" DESC,\n  \"Company Name\";\t----- bird -----\teducation_business_spider2",
    "105": "WITH per_step AS (\n  SELECT\n    ms.name,\n    ms.version,\n    ms.step,\n    MAX(CASE WHEN ms.model <> 'Stack' THEN ms.test_score END) AS max_non_stack_test,\n    MAX(CASE WHEN ms.model = 'Stack' THEN ms.test_score END)     AS stack_test\n  FROM model_score AS ms\n  GROUP BY ms.name, ms.version, ms.step\n),\nstatus_per_model AS (\n  SELECT\n    name,\n    version,\n    CASE\n      WHEN MAX(CASE WHEN max_non_stack_test < stack_test THEN 1 ELSE 0 END) = 1 THEN 'strong'\n      WHEN MAX(CASE WHEN max_non_stack_test = stack_test THEN 1 ELSE 0 END) = 1 THEN 'soft'\n      ELSE NULL\n    END AS status\n  FROM per_step\n  GROUP BY name, version\n),\nl1_per_model AS (\n  SELECT\n    m.name,\n    m.version,\n    m.L1_model\n  FROM model AS m\n  WHERE m.L1_model IS NOT NULL\n  GROUP BY m.name, m.version, m.L1_model\n),\ncounts AS (\n  SELECT\n    spm.status,\n    lpm.L1_model,\n    COUNT(*) AS occurrences\n  FROM status_per_model AS spm\n  JOIN l1_per_model AS lpm\n    ON lpm.name = spm.name\n   AND lpm.version = spm.version\n  WHERE spm.status IN ('strong', 'soft')\n  GROUP BY spm.status, lpm.L1_model\n),\nranked AS (\n  SELECT\n    status,\n    L1_model,\n    occurrences,\n    ROW_NUMBER() OVER (\n      PARTITION BY status\n      ORDER BY occurrences DESC, L1_model\n    ) AS rn\n  FROM counts\n)\nSELECT\n  status,\n  L1_model,\n  occurrences\nFROM ranked\nWHERE rn = 1\nORDER BY status;\t----- bird -----\tstacking_spider2",
    "107": "WITH RECURSIVE\n-- Expand each packaging into its leaf-level components, multiplying quantities along the way.\n-- A \"leaf\" is a packaging item that does not contain any other packaging items.\nexpanded(root_packaging_id, leaf_packaging_id, qty_mult) AS (\n  -- Start from every packaging as a potential \"final combination\"\n  SELECT p.id AS root_packaging_id,\n         p.id AS leaf_packaging_id,\n         1.0 AS qty_mult\n  FROM packaging p\n\n  UNION ALL\n\n  -- Replace a node by its children, accumulating multiplicative quantities\n  SELECT e.root_packaging_id,\n         pr.contains_id AS leaf_packaging_id,\n         e.qty_mult * pr.qty AS qty_mult\n  FROM expanded e\n  JOIN packaging_relations pr\n    ON pr.packaging_id = e.leaf_packaging_id\n),\nleaf_totals AS (\n  -- Keep only leaf-level items (those that do not contain anything)\n  SELECT e.root_packaging_id,\n         SUM(e.qty_mult) AS total_leaf_qty\n  FROM expanded e\n  LEFT JOIN packaging_relations pr2\n    ON pr2.packaging_id = e.leaf_packaging_id\n  WHERE pr2.packaging_id IS NULL\n  GROUP BY e.root_packaging_id\n)\nSELECT AVG(total_leaf_qty) AS avg_total_leaf_qty_across_final_packaging\nFROM leaf_totals;\t----- bird -----\toracle_sql_spider2",
    "108": "WITH RECURSIVE\n-- Top-level containers: packaging that is never a \"contains_id\"\ntop_level AS (\n  SELECT p.id, p.name\n  FROM packaging p\n  WHERE NOT EXISTS (\n    SELECT 1\n    FROM packaging_relations pr\n    WHERE pr.contains_id = p.id\n  )\n),\n-- Expand containment hierarchy from each top-level container downwards,\n-- carrying the multiplicative quantity along the path.\ntree AS (\n  -- direct children of top-level containers\n  SELECT\n    tl.id   AS top_id,\n    tl.name AS top_name,\n    pr.contains_id AS item_id,\n    pr.qty AS mult_qty\n  FROM top_level tl\n  JOIN packaging_relations pr\n    ON pr.packaging_id = tl.id\n\n  UNION ALL\n\n  -- deeper levels\n  SELECT\n    t.top_id,\n    t.top_name,\n    pr.contains_id AS item_id,\n    t.mult_qty * pr.qty AS mult_qty\n  FROM tree t\n  JOIN packaging_relations pr\n    ON pr.packaging_id = t.item_id\n),\ntotals AS (\n  SELECT\n    top_id,\n    top_name,\n    item_id,\n    SUM(mult_qty) AS total_qty\n  FROM tree\n  GROUP BY top_id, top_name, item_id\n)\nSELECT\n  tot.top_name  AS container_name,\n  p2.name       AS item_name,\n  tot.total_qty\nFROM totals tot\nJOIN packaging p2\n  ON p2.id = tot.item_id\nWHERE tot.total_qty > 500\nORDER BY container_name, item_name;\t----- bird -----\toracle_sql_spider2",
    "98": "WITH\n-- Total runs per season per batsman\nruns_by_season AS (\n  SELECT\n    m.season_id,\n    bbb.striker AS player_id,\n    SUM(bs.runs_scored) AS total_runs\n  FROM ball_by_ball AS bbb\n  JOIN batsman_scored AS bs\n    ON bs.match_id = bbb.match_id\n   AND bs.innings_no = bbb.innings_no\n   AND bs.over_id = bbb.over_id\n   AND bs.ball_id = bbb.ball_id\n  JOIN match AS m\n    ON m.match_id = bbb.match_id\n  GROUP BY m.season_id, bbb.striker\n),\nranked_batsmen AS (\n  SELECT\n    season_id,\n    player_id,\n    total_runs,\n    ROW_NUMBER() OVER (\n      PARTITION BY season_id\n      ORDER BY total_runs DESC, player_id ASC\n    ) AS pos\n  FROM runs_by_season\n),\ntop_batsmen AS (\n  SELECT season_id, pos, player_id, total_runs\n  FROM ranked_batsmen\n  WHERE pos <= 3\n),\n\n-- Total wickets per season per bowler (excluding specified dismissal kinds)\nwickets_by_season AS (\n  SELECT\n    m.season_id,\n    bbb.bowler AS player_id,\n    COUNT(*) AS total_wickets\n  FROM wicket_taken AS wt\n  JOIN ball_by_ball AS bbb\n    ON bbb.match_id = wt.match_id\n   AND bbb.innings_no = wt.innings_no\n   AND bbb.over_id = wt.over_id\n   AND bbb.ball_id = wt.ball_id\n  JOIN match AS m\n    ON m.match_id = wt.match_id\n  WHERE wt.kind_out NOT IN ('run out', 'hit wicket', 'retired hurt')\n  GROUP BY m.season_id, bbb.bowler\n),\nranked_bowlers AS (\n  SELECT\n    season_id,\n    player_id,\n    total_wickets,\n    ROW_NUMBER() OVER (\n      PARTITION BY season_id\n      ORDER BY total_wickets DESC, player_id ASC\n    ) AS pos\n  FROM wickets_by_season\n),\ntop_bowlers AS (\n  SELECT season_id, pos, player_id, total_wickets\n  FROM ranked_bowlers\n  WHERE pos <= 3\n)\n\nSELECT\n  b.season_id,\n  b.pos AS rank_position,\n\n  b.player_id AS batsman_id,\n  pb.player_name AS batsman_name,\n  b.total_runs,\n\n  w.player_id AS bowler_id,\n  pw.player_name AS bowler_name,\n  w.total_wickets\nFROM top_batsmen AS b\nJOIN top_bowlers AS w\n  ON w.season_id = b.season_id\n AND w.pos = b.pos\nLEFT JOIN player AS pb\n  ON pb.player_id = b.player_id\nLEFT JOIN player AS pw\n  ON pw.player_id = w.player_id\nORDER BY b.season_id ASC, b.pos ASC;\t----- bird -----\tIPL_spider2",
    "111": "WITH picked AS (\n  SELECT\n    pl.order_id,\n    pl.product_id,\n    pl.qty AS picked_qty\n  FROM picking_line pl\n  WHERE pl.order_id = 421\n),\nfifo_layers AS (\n  -- FIFO layers: purchases ordered by purchased date (then id) for each product\n  SELECT\n    p.product_id,\n    p.id AS purchase_id,\n    p.purchased,\n    p.qty AS layer_qty,\n    SUM(p.qty) OVER (\n      PARTITION BY p.product_id\n      ORDER BY p.purchased, p.id\n      ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n    ) AS cum_qty\n  FROM purchases p\n  WHERE p.product_id IN (SELECT DISTINCT product_id FROM picked)\n),\nalloc AS (\n  -- Allocate each picked quantity across FIFO layers and compute weighted average units per layer\n  SELECT\n    pk.order_id,\n    pk.product_id,\n    fl.purchase_id,\n    fl.purchased,\n    CASE\n      WHEN pk.picked_qty <= IFNULL(LAG(fl.cum_qty) OVER (PARTITION BY fl.product_id ORDER BY fl.purchased, fl.purchase_id), 0)\n        THEN 0\n      ELSE\n        MAX(\n          0,\n          MIN(\n            fl.layer_qty,\n            pk.picked_qty - IFNULL(LAG(fl.cum_qty) OVER (PARTITION BY fl.product_id ORDER BY fl.purchased, fl.purchase_id), 0)\n          )\n        )\n    END AS alloc_qty\n  FROM picked pk\n  JOIN fifo_layers fl\n    ON fl.product_id = pk.product_id\n)\nSELECT\n  a.product_id,\n  pr.name AS product_name,\n  SUM(a.alloc_qty) AS total_units_picked,\n  CASE\n    WHEN SUM(CASE WHEN a.alloc_qty > 0 THEN 1 ELSE 0 END) = 0 THEN NULL\n    ELSE 1.0 * SUM(a.alloc_qty) / SUM(CASE WHEN a.alloc_qty > 0 THEN 1 ELSE 0 END)\n  END AS avg_units_picked_fifo\nFROM alloc a\nJOIN products pr\n  ON pr.id = a.product_id\nWHERE a.alloc_qty > 0\nGROUP BY a.product_id, pr.name\nORDER BY pr.name;\t----- bird -----\toracle_sql_spider2",
    "116": "WITH item_loss AS (\n  SELECT\n    item_code,\n    item_name,\n    CAST(REPLACE(\"loss_rate_%\", '%', '') AS REAL) AS loss_rate\n  FROM veg_loss_rate_df\n  WHERE \"loss_rate_%\" IS NOT NULL\n),\nstats AS (\n  SELECT\n    AVG(loss_rate) AS avg_loss_rate,\n    -- population standard deviation: sqrt(E[x^2] - (E[x])^2)\n    SQRT(AVG(loss_rate * loss_rate) - AVG(loss_rate) * AVG(loss_rate)) AS stddev_loss_rate\n  FROM item_loss\n)\nSELECT\n  stats.avg_loss_rate,\n  stats.stddev_loss_rate,\n  COUNT(*) AS total_items,\n  SUM(CASE WHEN il.loss_rate <  stats.avg_loss_rate - stats.stddev_loss_rate THEN 1 ELSE 0 END) AS below_1_stddev_count,\n  SUM(CASE WHEN il.loss_rate >  stats.avg_loss_rate + stats.stddev_loss_rate THEN 1 ELSE 0 END) AS above_1_stddev_count,\n  SUM(CASE WHEN il.loss_rate BETWEEN stats.avg_loss_rate - stats.stddev_loss_rate\n                         AND     stats.avg_loss_rate + stats.stddev_loss_rate\n           THEN 1 ELSE 0 END) AS within_1_stddev_count\nFROM item_loss il\nCROSS JOIN stats;\t----- bird -----\tbank_sales_trading_spider2",
    "112": "WITH sales AS (\n  -- monthly sales starting Jan 2016\n  SELECT\n    ms.product_id,\n    date(ms.mth || '-01') AS mth,\n    ms.qty * 1.0 AS qty\n  FROM monthly_sales ms\n  WHERE date(ms.mth || '-01') >= date('2016-01-01')\n),\nidx AS (\n  -- month index since 2016-01 (t=1 for 2016-01)\n  SELECT\n    s.*,\n    (CAST(strftime('%Y', s.mth) AS INTEGER) - 2016) * 12\n    + CAST(strftime('%m', s.mth) AS INTEGER) AS t\n  FROM sales s\n),\ncma AS (\n  -- centered moving average via two overlapping 12-month windows:\n  -- avg(t-5..t+6) and avg(t-6..t+5), then average those two avgs\n  SELECT\n    i.product_id,\n    i.mth,\n    i.t,\n    i.qty,\n    (\n      AVG(i.qty) OVER (\n        PARTITION BY i.product_id\n        ORDER BY i.t\n        ROWS BETWEEN 5 PRECEDING AND 6 FOLLOWING\n      )\n      +\n      AVG(i.qty) OVER (\n        PARTITION BY i.product_id\n        ORDER BY i.t\n        ROWS BETWEEN 6 PRECEDING AND 5 FOLLOWING\n      )\n    ) / 2.0 AS cma_qty\n  FROM idx i\n),\nratios AS (\n  SELECT\n    product_id,\n    mth,\n    t,\n    qty,\n    cma_qty,\n    CASE WHEN cma_qty IS NULL OR cma_qty = 0 THEN NULL ELSE qty / cma_qty END AS sales_to_cma_ratio\n  FROM cma\n  -- restrict to months 7..30 to avoid edge effects\n  WHERE t BETWEEN 7 AND 30\n),\ny2017 AS (\n  SELECT *\n  FROM ratios\n  WHERE mth >= date('2017-01-01') AND mth < date('2018-01-01')\n)\nSELECT\n  p.id AS product_id,\n  p.name AS product_name\nFROM y2017 y\nJOIN products p ON p.id = y.product_id\nGROUP BY p.id, p.name\nHAVING\n  COUNT(*) = 12\n  AND MIN(y.sales_to_cma_ratio) > 2.0;\t----- bird -----\toracle_sql_spider2",
    "110": "WITH\n-- Order demand per order/product\norder_demand AS (\n  SELECT\n    pl.order_id,\n    pl.product_id,\n    SUM(pl.qty) AS order_qty\n  FROM picking_line pl\n  GROUP BY pl.order_id, pl.product_id\n),\n\n-- Inventory lots per product/location with FIFO keys:\n-- earliest purchase date first, then smallest available qty, then stable tie-breakers\ninv_lots AS (\n  SELECT\n    i.product_id,\n    i.location_id,\n    i.purchase_id,\n    p.purchased AS purchased_dt,\n    i.qty AS inv_qty\n  FROM inventory i\n  JOIN purchases p\n    ON p.id = i.purchase_id\n),\n\n-- Rank inventory lots within each product by FIFO rule\ninv_ranked AS (\n  SELECT\n    il.*,\n    ROW_NUMBER() OVER (\n      PARTITION BY il.product_id\n      ORDER BY il.purchased_dt, il.inv_qty, il.purchase_id, il.location_id\n    ) AS lot_seq,\n    SUM(il.inv_qty) OVER (\n      PARTITION BY il.product_id\n      ORDER BY il.purchased_dt, il.inv_qty, il.purchase_id, il.location_id\n      ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING\n    ) AS inv_before\n  FROM inv_lots il\n),\n\n-- For each order/product, compute how much of its demand overlaps each FIFO lot\nalloc AS (\n  SELECT\n    od.order_id,\n    od.product_id,\n    ir.location_id,\n    ir.purchase_id,\n    ir.purchased_dt,\n    ir.inv_qty,\n    od.order_qty,\n    COALESCE(ir.inv_before, 0) AS inv_before,\n    -- overlap between [inv_before, inv_before+inv_qty] and [0, order_qty]\n    MAX(\n      0,\n      MIN(od.order_qty, COALESCE(ir.inv_before, 0) + ir.inv_qty) - COALESCE(ir.inv_before, 0)\n    ) AS picked_qty\n  FROM order_demand od\n  JOIN inv_ranked ir\n    ON ir.product_id = od.product_id\n),\n\n-- Pick percentage per order/product (picked / required), capped by overlap logic above\norder_pick_pct AS (\n  SELECT\n    a.order_id,\n    a.product_id,\n    a.order_qty,\n    SUM(a.picked_qty) AS total_picked_qty,\n    CASE\n      WHEN a.order_qty = 0 THEN NULL\n      ELSE 1.0 * SUM(a.picked_qty) / a.order_qty\n    END AS pick_pct\n  FROM alloc a\n  GROUP BY a.order_id, a.product_id, a.order_qty\n)\n\nSELECT\n  pr.name AS product_name,\n  AVG(opp.pick_pct) AS avg_pick_percentage\nFROM order_pick_pct opp\nJOIN products pr\n  ON pr.id = opp.product_id\nGROUP BY pr.name\nORDER BY pr.name;\t----- bird -----\toracle_sql_spider2",
    "115": "WITH match_points AS (\n  SELECT\n    m.season,\n    m.league_id,\n    m.country_id,\n    m.home_team_api_id AS team_api_id,\n    CASE\n      WHEN m.home_team_goal > m.away_team_goal THEN 3\n      WHEN m.home_team_goal = m.away_team_goal THEN 1\n      ELSE 0\n    END AS points\n  FROM Match m\n\n  UNION ALL\n\n  SELECT\n    m.season,\n    m.league_id,\n    m.country_id,\n    m.away_team_api_id AS team_api_id,\n    CASE\n      WHEN m.away_team_goal > m.home_team_goal THEN 3\n      WHEN m.away_team_goal = m.home_team_goal THEN 1\n      ELSE 0\n    END AS points\n  FROM Match m\n),\nteam_season_points AS (\n  SELECT\n    season,\n    league_id,\n    country_id,\n    team_api_id,\n    SUM(points) AS total_points\n  FROM match_points\n  GROUP BY season, league_id, country_id, team_api_id\n),\nranked AS (\n  SELECT\n    tsp.*,\n    ROW_NUMBER() OVER (\n      PARTITION BY tsp.season, tsp.league_id\n      ORDER BY tsp.total_points DESC, tsp.team_api_id\n    ) AS rn\n  FROM team_season_points tsp\n)\nSELECT\n  r.season,\n  t.team_long_name AS champion_team,\n  l.name AS league,\n  c.name AS country,\n  r.total_points\nFROM ranked r\nJOIN Team t    ON t.team_api_id = r.team_api_id\nJOIN League l  ON l.id = r.league_id\nJOIN Country c ON c.id = r.country_id\nWHERE r.rn = 1\nORDER BY r.season, c.name, l.name;\t----- bird -----\tEU_soccer_spider2",
    "97": "\t----- bird -----\tEU_soccer_spider2",
    "121": "WITH input_sessions AS (\n  SELECT\n    session,\n    MIN(stamp) AS input_time\n  FROM form_log\n  WHERE path = '/regist/input'\n  GROUP BY session\n),\nconfirm_sessions AS (\n  SELECT\n    session,\n    MIN(stamp) AS confirm_time\n  FROM form_log\n  WHERE path = '/regist/confirm'\n  GROUP BY session\n)\nSELECT\n  COUNT(DISTINCT i.session) AS unique_sessions\nFROM input_sessions i\nJOIN confirm_sessions c\n  ON c.session = i.session\n AND c.confirm_time > i.input_time;\t----- bird -----\tlog_spider2",
    "103": "\t----- bird -----\tIPL_spider2",
    "119": "WITH base AS (\n  SELECT\n    calendar_year AS year,\n    date(week_date_formatted) AS week_date,\n    sales\n  FROM cleaned_weekly_sales\n  WHERE calendar_year IN (2018, 2019, 2020)\n),\nmid_june AS (\n  SELECT\n    year,\n    date(year || '-06-15') AS mid_date\n  FROM (SELECT DISTINCT year FROM base)\n),\nwindowed AS (\n  SELECT\n    b.year,\n    CASE\n      WHEN b.week_date >= date(m.mid_date, '-28 days') AND b.week_date < m.mid_date THEN 'pre_4w'\n      WHEN b.week_date >= m.mid_date AND b.week_date < date(m.mid_date, '+28 days') THEN 'post_4w'\n    END AS period,\n    b.sales\n  FROM base b\n  JOIN mid_june m\n    ON m.year = b.year\n  WHERE\n    (b.week_date >= date(m.mid_date, '-28 days') AND b.week_date < m.mid_date)\n    OR\n    (b.week_date >= m.mid_date AND b.week_date < date(m.mid_date, '+28 days'))\n),\nagg AS (\n  SELECT\n    year,\n    SUM(CASE WHEN period = 'pre_4w'  THEN sales END)  AS sales_pre_4w,\n    SUM(CASE WHEN period = 'post_4w' THEN sales END)  AS sales_post_4w\n  FROM windowed\n  GROUP BY year\n)\nSELECT\n  year,\n  sales_pre_4w,\n  sales_post_4w,\n  ROUND(\n    (sales_post_4w - sales_pre_4w) * 100.0 / NULLIF(sales_pre_4w, 0),\n    2\n  ) AS pct_change_sales_post_vs_pre\nFROM agg\nORDER BY year;\t----- bird -----\tbank_sales_trading_spider2",
    "99": "\t----- bird -----\tIPL_spider2",
    "123": "WITH ordered AS (\n  SELECT\n    session,\n    stamp,\n    url,\n    LAG(url, 1) OVER (PARTITION BY session ORDER BY stamp) AS prev_url,\n    LAG(url, 2) OVER (PARTITION BY session ORDER BY stamp) AS prev2_url\n  FROM read_log\n),\nthird_after_two_details AS (\n  SELECT\n    url AS third_url\n  FROM ordered\n  WHERE prev_url = '/detail'\n    AND prev2_url = '/detail'\n    AND url IS NOT NULL\n)\nSELECT\n  third_url,\n  COUNT(*) AS occurrences\nFROM third_after_two_details\nGROUP BY third_url\nORDER BY occurrences DESC, third_url\nLIMIT 3;\t----- bird -----\tlog_spider2",
    "102": "WITH\n-- Runs off the bat per delivery (ignore extras entirely)\nbat_runs AS (\n  SELECT\n    b.match_id, b.innings_no, b.over_id, b.ball_id,\n    bb.bowler,\n    COALESCE(bs.runs_scored, 0) AS bat_runs\n  FROM ball_by_ball bb\n  LEFT JOIN batsman_scored bs\n    ON bs.match_id = bb.match_id\n   AND bs.innings_no = bb.innings_no\n   AND bs.over_id = bb.over_id\n   AND bs.ball_id = bb.ball_id\n),\n\n-- Legal balls only (exclude wides and no-balls from balls bowled)\nlegal_balls AS (\n  SELECT\n    bb.match_id, bb.innings_no, bb.over_id, bb.ball_id,\n    bb.bowler\n  FROM ball_by_ball bb\n  LEFT JOIN extra_runs er\n    ON er.match_id = bb.match_id\n   AND er.innings_no = bb.innings_no\n   AND er.over_id = bb.over_id\n   AND er.ball_id = bb.ball_id\n   AND er.extra_type IN ('wides', 'wide', 'no ball', 'noball', 'no-ball')\n  WHERE er.match_id IS NULL\n),\n\n-- Bowler-attributed wickets (exclude run outs and other non-bowler dismissals)\nbowler_wickets AS (\n  SELECT\n    wt.match_id,\n    bb.bowler,\n    COUNT(*) AS wickets\n  FROM wicket_taken wt\n  JOIN ball_by_ball bb\n    ON bb.match_id = wt.match_id\n   AND bb.innings_no = wt.innings_no\n   AND bb.over_id = wt.over_id\n   AND bb.ball_id = wt.ball_id\n  WHERE LOWER(wt.kind_out) NOT IN (\n    'run out','retired hurt','obstructing the field','hit wicket',\n    'handled the ball','timed out'\n  )\n  GROUP BY wt.match_id, bb.bowler\n),\n\n-- Per match bowling summary (legal balls, bat runs conceded, wickets)\nper_match AS (\n  SELECT\n    lb.match_id,\n    lb.bowler,\n    COUNT(*) AS balls_bowled,\n    SUM(br.bat_runs) AS runs_conceded,\n    COALESCE(bw.wickets, 0) AS wickets\n  FROM legal_balls lb\n  JOIN bat_runs br\n    ON br.match_id = lb.match_id\n   AND br.innings_no = lb.innings_no\n   AND br.over_id = lb.over_id\n   AND br.ball_id = lb.ball_id\n   AND br.bowler = lb.bowler\n  LEFT JOIN bowler_wickets bw\n    ON bw.match_id = lb.match_id\n   AND bw.bowler = lb.bowler\n  GROUP BY lb.match_id, lb.bowler\n),\n\n-- Career totals per bowler\ncareer AS (\n  SELECT\n    bowler,\n    SUM(balls_bowled) AS balls_bowled,\n    SUM(runs_conceded) AS runs_conceded,\n    SUM(wickets) AS wickets\n  FROM per_match\n  GROUP BY bowler\n),\n\n-- Best match (most wickets; tie-breaker: fewer runs, then fewer balls, then match_id)\nbest_match AS (\n  SELECT\n    pm.*,\n    ROW_NUMBER() OVER (\n      PARTITION BY pm.bowler\n      ORDER BY pm.wickets DESC, pm.runs_conceded ASC, pm.balls_bowled ASC, pm.match_id ASC\n    ) AS rn\n  FROM per_match pm\n)\n\nSELECT\n  p.player_id AS bowler_id,\n  p.player_name AS bowler_name,\n  c.wickets AS total_wickets,\n  ROUND( (1.0 * c.runs_conceded / NULLIF(c.balls_bowled, 0)) * 6.0, 2) AS economy_rate,\n  ROUND( 1.0 * c.balls_bowled / NULLIF(c.wickets, 0), 2) AS strike_rate,\n  (bm.wickets || '-' || bm.runs_conceded) AS best_bowling_match\nFROM career c\nJOIN player p\n  ON p.player_id = c.bowler\nLEFT JOIN best_match bm\n  ON bm.bowler = c.bowler\n AND bm.rn = 1\nORDER BY total_wickets DESC, economy_rate ASC, strike_rate ASC, bowler_name;\t----- bird -----\tIPL_spider2",
    "122": "WITH ranked AS (\n  SELECT\n    session,\n    path,\n    stamp,\n    ROW_NUMBER() OVER (PARTITION BY session ORDER BY stamp)        AS rn_first,\n    ROW_NUMBER() OVER (PARTITION BY session ORDER BY stamp DESC)   AS rn_last\n  FROM activity_log\n  WHERE path IS NOT NULL\n),\nlanding_exit AS (\n  SELECT session, path\n  FROM ranked\n  WHERE rn_first = 1 OR rn_last = 1\n  GROUP BY session, path   -- ensure a session is counted once per page even if both landing & exit\n)\nSELECT\n  path AS page,\n  COUNT(*) AS unique_sessions_landing_or_exit\nFROM landing_exit\nGROUP BY path\nORDER BY unique_sessions_landing_or_exit DESC, page;\t----- bird -----\tlog_spider2",
    "124": "WITH user_ages AS (\n  SELECT\n    user_id,\n    CAST(strftime('%Y', 'now') AS INTEGER) - CAST(strftime('%Y', birth_date) AS INTEGER)\n      - CASE\n          WHEN strftime('%m-%d', 'now') < strftime('%m-%d', birth_date) THEN 1\n          ELSE 0\n        END AS age\n  FROM mst_users\n  WHERE birth_date IS NOT NULL\n),\nage_buckets AS (\n  SELECT\n    user_id,\n    CASE\n      WHEN age BETWEEN 20 AND 29 THEN '20s'\n      WHEN age BETWEEN 30 AND 39 THEN '30s'\n      WHEN age BETWEEN 40 AND 49 THEN '40s'\n      WHEN age BETWEEN 50 AND 59 THEN '50s'\n      ELSE 'others'\n    END AS age_category\n  FROM user_ages\n)\nSELECT\n  age_category,\n  COUNT(DISTINCT user_id) AS user_count\nFROM age_buckets\nGROUP BY age_category\nORDER BY\n  CASE age_category\n    WHEN '20s' THEN 1\n    WHEN '30s' THEN 2\n    WHEN '40s' THEN 3\n    WHEN '50s' THEN 4\n    ELSE 5\n  END;\t----- bird -----\tlog_spider2",
    "125": "WITH first_target AS (\n  SELECT\n    session,\n    MIN(stamp) AS first_target_stamp\n  FROM activity_log\n  WHERE action IN ('click', 'conversion')\n    AND path IN ('/detail', '/complete')\n  GROUP BY session\n),\npre_events AS (\n  SELECT\n    a.session,\n    a.path,\n    a.search_type,\n    COUNT(*) AS pre_event_count\n  FROM activity_log AS a\n  JOIN first_target AS ft\n    ON ft.session = a.session\n  WHERE a.search_type IS NOT NULL\n    AND a.search_type <> ''\n    AND a.stamp < ft.first_target_stamp\n  GROUP BY a.session, a.path, a.search_type\n),\nmin_per_session AS (\n  SELECT\n    session,\n    MIN(pre_event_count) AS min_pre_event_count\n  FROM pre_events\n  GROUP BY session\n),\nglobal_min AS (\n  SELECT MIN(min_pre_event_count) AS global_min_count\n  FROM min_per_session\n)\nSELECT\n  p.session,\n  p.path,\n  p.search_type\nFROM pre_events AS p\nJOIN min_per_session AS ms\n  ON ms.session = p.session\n AND ms.min_pre_event_count = p.pre_event_count\nCROSS JOIN global_min AS gm\nWHERE ms.min_pre_event_count = gm.global_min_count\nORDER BY p.session, p.path, p.search_type;\t----- bird -----\tlog_spider2",
    "109": "WITH\n-- Order lines for the target order, keeping a deterministic sequence\nol AS (\n  SELECT\n    ol.id            AS orderline_id,\n    ol.order_id,\n    ol.product_id,\n    ol.qty           AS line_qty,\n    ROW_NUMBER() OVER (PARTITION BY ol.product_id ORDER BY ol.id) AS line_seq,\n    SUM(ol.qty) OVER (\n      PARTITION BY ol.product_id\n      ORDER BY ol.id\n      ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n    ) AS cum_line_qty\n  FROM orderlines ol\n  WHERE ol.order_id = 423\n),\n-- Inventory in warehouse 1, expanded to location + purchase date, with a deterministic pick priority:\n-- earlier purchase date first, then smaller quantities, then stable tie-breakers\ninv AS (\n  SELECT\n    i.product_id,\n    i.location_id,\n    l.aisle,\n    l.position,\n    p.purchased,\n    i.qty AS inv_qty,\n    ROW_NUMBER() OVER (\n      PARTITION BY i.product_id\n      ORDER BY p.purchased, i.qty, i.location_id, p.id\n    ) AS inv_seq,\n    SUM(i.qty) OVER (\n      PARTITION BY i.product_id\n      ORDER BY p.purchased, i.qty, i.location_id, p.id\n      ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n    ) AS cum_inv_qty\n  FROM inventory i\n  JOIN locations l ON l.id = i.location_id\n  JOIN purchases  p ON p.id = i.purchase_id\n  WHERE l.warehouse = 1\n),\n-- Total ordered per product (to cap picking at demand)\ndemand AS (\n  SELECT product_id, SUM(line_qty) AS total_ordered\n  FROM ol\n  GROUP BY product_id\n),\n-- Cap inventory cumulative sums at total demand so we never \"pick\" beyond what is needed\ninv_capped AS (\n  SELECT\n    inv.*,\n    d.total_ordered,\n    MIN(inv.cum_inv_qty, d.total_ordered) AS cum_inv_capped,\n    MIN(inv.cum_inv_qty - inv.inv_qty, d.total_ordered) AS prev_cum_inv_capped\n  FROM inv\n  JOIN demand d USING (product_id)\n),\n-- Allocate inventory to each order line by intersecting cumulative demand intervals with capped cumulative supply intervals\nalloc AS (\n  SELECT\n    ol.order_id,\n    ol.orderline_id,\n    ol.product_id,\n    ol.line_seq,\n    ol.line_qty,\n    (ol.cum_line_qty - ol.line_qty) AS prev_cum_line_qty,\n    ol.cum_line_qty,\n    ic.location_id,\n    ic.aisle,\n    ic.position,\n    ic.purchased,\n    ic.inv_seq,\n    ic.inv_qty,\n    ic.total_ordered,\n    ic.prev_cum_inv_capped,\n    ic.cum_inv_capped,\n    -- interval intersection length:\n    MAX(\n      0,\n      MIN(ol.cum_line_qty, ic.cum_inv_capped) - MAX((ol.cum_line_qty - ol.line_qty), ic.prev_cum_inv_capped)\n    ) AS pick_qty\n  FROM ol\n  JOIN inv_capped ic\n    ON ic.product_id = ol.product_id\n   AND ic.cum_inv_capped > (ol.cum_line_qty - ol.line_qty)\n   AND ic.prev_cum_inv_capped < ol.cum_line_qty\n)\nSELECT\n  order_id,\n  orderline_id,\n  product_id,\n  aisle,\n  position,\n  pick_qty\nFROM alloc\nWHERE pick_qty > 0\nORDER BY\n  product_id,\n  line_seq,          -- respects sequence of order lines per product\n  purchased,         -- earlier purchases first\n  inv_qty,           -- smaller quantities first\n  location_id;\t----- bird -----\toracle_sql_spider2",
    "118": "WITH seller_item_sales AS (\n  SELECT\n    oi.seller_id,\n    oi.order_id,\n    oi.product_id,\n    oi.price,\n    oi.shipping_limit_date,\n    o.order_purchase_timestamp,\n    p.product_category_name\n  FROM order_items oi\n  JOIN orders o\n    ON o.order_id = oi.order_id\n  LEFT JOIN products p\n    ON p.product_id = oi.product_id\n  WHERE o.order_status IN ('delivered', 'shipped', 'invoiced', 'approved')\n),\nseller_metrics AS (\n  SELECT\n    sis.seller_id,\n    COUNT(*) AS total_products_sold,\n    SUM(sis.price) AS total_sales,\n    AVG(sis.price) AS avg_item_price,\n    AVG(\n      (julianday(sis.shipping_limit_date) - julianday(sis.order_purchase_timestamp)) * 24.0\n    ) AS avg_packing_time_hours\n  FROM seller_item_sales sis\n  GROUP BY sis.seller_id\n  HAVING COUNT(*) > 100\n),\nseller_reviews AS (\n  SELECT\n    oi.seller_id,\n    AVG(r.review_score) AS avg_review_score\n  FROM order_items oi\n  JOIN order_reviews r\n    ON r.order_id = oi.order_id\n  GROUP BY oi.seller_id\n),\nseller_category_sales AS (\n  SELECT\n    sis.seller_id,\n    COALESCE(t.product_category_name_english, sis.product_category_name, 'unknown') AS category_english,\n    COUNT(*) AS category_units_sold,\n    SUM(sis.price) AS category_sales\n  FROM seller_item_sales sis\n  LEFT JOIN product_category_name_translation t\n    ON t.product_category_name = sis.product_category_name\n  GROUP BY sis.seller_id, category_english\n),\nseller_top_category AS (\n  SELECT\n    seller_id,\n    category_english AS top_category_english,\n    category_units_sold AS top_category_units_sold,\n    category_sales AS top_category_sales\n  FROM (\n    SELECT\n      scs.*,\n      ROW_NUMBER() OVER (\n        PARTITION BY scs.seller_id\n        ORDER BY scs.category_units_sold DESC, scs.category_sales DESC, scs.category_english\n      ) AS rn\n    FROM seller_category_sales scs\n  )\n  WHERE rn = 1\n)\nSELECT\n  sm.seller_id,\n  sm.total_products_sold,\n  ROUND(sm.total_sales, 2) AS total_sales,\n  ROUND(sm.avg_item_price, 2) AS avg_item_price,\n  ROUND(COALESCE(sr.avg_review_score, NULL), 2) AS avg_review_score,\n  ROUND(sm.avg_packing_time_hours, 2) AS avg_packing_time_hours,\n  stc.top_category_english,\n  stc.top_category_units_sold,\n  ROUND(stc.top_category_sales, 2) AS top_category_sales\nFROM seller_metrics sm\nLEFT JOIN seller_reviews sr\n  ON sr.seller_id = sm.seller_id\nLEFT JOIN seller_top_category stc\n  ON stc.seller_id = sm.seller_id\nORDER BY total_sales DESC, sm.total_products_sold DESC;\t----- bird -----\telectronic_sales_spider2",
    "130": "WITH\ndriver_year_points AS (\n  SELECT\n    r.race_id,\n    r.driver_id,\n    SUM(r.points) AS driver_points\n  FROM results r\n  GROUP BY r.race_id, r.driver_id\n),\nconstructor_year_points AS (\n  SELECT\n    r.race_id,\n    r.constructor_id,\n    SUM(r.points) AS constructor_points\n  FROM results r\n  GROUP BY r.race_id, r.constructor_id\n),\nmax_driver_by_year AS (\n  SELECT\n    ra.year,\n    MAX(dyp.driver_points) AS max_driver_points\n  FROM driver_year_points dyp\n  JOIN races ra ON ra.race_id = dyp.race_id\n  GROUP BY ra.year\n),\nmax_constructor_by_year AS (\n  SELECT\n    ra.year,\n    MAX(cyp.constructor_points) AS max_constructor_points\n  FROM constructor_year_points cyp\n  JOIN races ra ON ra.race_id = cyp.race_id\n  GROUP BY ra.year\n)\nSELECT\n  d.year,\n  (d.max_driver_points + c.max_constructor_points) AS smallest_sum_max_driver_plus_max_constructor\nFROM max_driver_by_year d\nJOIN max_constructor_by_year c\n  ON c.year = d.year\nORDER BY smallest_sum_max_driver_plus_max_constructor ASC, d.year ASC\nLIMIT 3;\t----- bird -----\tf1_spider2",
    "131": "WITH driver_points AS (\n  SELECT\n    r.year,\n    res.constructor_id,\n    res.driver_id,\n    SUM(res.points) AS driver_points\n  FROM results res\n  JOIN races r ON r.race_id = res.race_id\n  GROUP BY r.year, res.constructor_id, res.driver_id\n),\nbest_driver_per_constructor_year AS (\n  SELECT\n    year,\n    constructor_id,\n    MAX(driver_points) AS best_driver_points\n  FROM driver_points\n  GROUP BY year, constructor_id\n),\nteam_points AS (\n  SELECT\n    r.year,\n    res.constructor_id,\n    SUM(res.points) AS team_points\n  FROM results res\n  JOIN races r ON r.race_id = res.race_id\n  GROUP BY r.year, res.constructor_id\n),\ncombined AS (\n  SELECT\n    tp.year,\n    tp.constructor_id,\n    (tp.team_points + bd.best_driver_points) AS combined_points\n  FROM team_points tp\n  JOIN best_driver_per_constructor_year bd\n    ON bd.year = tp.year\n   AND bd.constructor_id = tp.constructor_id\n),\nranked AS (\n  SELECT\n    c.name AS constructor_name,\n    combined.year,\n    combined.combined_points,\n    DENSE_RANK() OVER (ORDER BY combined.combined_points DESC) AS overall_rank\n  FROM combined\n  JOIN constructors c ON c.constructor_id = combined.constructor_id\n)\nSELECT\n  constructor_name,\n  year,\n  combined_points\nFROM ranked\nWHERE overall_rank <= 3\nORDER BY combined_points DESC, year, constructor_name;\t----- bird -----\tf1_spider2",
    "113": "\t----- bird -----\toracle_sql_spider2",
    "128": "WITH season_driver_points AS (\n  -- Total points per driver per season (only seasons since 2001)\n  SELECT\n    r.year,\n    res.driver_id,\n    res.constructor_id,\n    SUM(res.points) AS season_points\n  FROM results res\n  JOIN races r\n    ON r.race_id = res.race_id\n  WHERE r.year >= 2001\n  GROUP BY r.year, res.driver_id, res.constructor_id\n),\npoint_scoring_drivers AS (\n  -- Keep only drivers who scored points in the season\n  SELECT *\n  FROM season_driver_points\n  WHERE season_points > 0\n),\nseason_min_points AS (\n  -- For each season, find the minimum points among point-scoring drivers\n  SELECT\n    year,\n    MIN(season_points) AS min_points\n  FROM point_scoring_drivers\n  GROUP BY year\n),\nseason_min_point_drivers AS (\n  -- Drivers (and their constructors) who achieved that minimum in the season\n  SELECT\n    psd.year,\n    psd.constructor_id\n  FROM point_scoring_drivers psd\n  JOIN season_min_points smp\n    ON smp.year = psd.year\n   AND smp.min_points = psd.season_points\n),\nconstructor_season_counts AS (\n  -- Count seasons per constructor (distinct seasons to avoid double-counting ties within a season)\n  SELECT\n    constructor_id,\n    COUNT(DISTINCT year) AS seasons_with_min_point_driver\n  FROM season_min_point_drivers\n  GROUP BY constructor_id\n)\nSELECT\n  c.name AS constructor_name,\n  csc.seasons_with_min_point_driver\nFROM constructor_season_counts csc\nJOIN constructors c\n  ON c.constructor_id = csc.constructor_id\nORDER BY\n  csc.seasons_with_min_point_driver DESC,\n  constructor_name ASC\nLIMIT 5;\t----- bird -----\tf1_spider2",
    "129": "WITH driver_year_points AS (\n  SELECT\n    r.year,\n    res.driver_id,\n    SUM(res.points) AS total_points\n  FROM results res\n  JOIN races r ON r.race_id = res.race_id\n  GROUP BY r.year, res.driver_id\n),\ndriver_year_winners AS (\n  SELECT\n    year,\n    driver_id,\n    total_points,\n    DENSE_RANK() OVER (PARTITION BY year ORDER BY total_points DESC) AS rk\n  FROM driver_year_points\n),\nconstructor_year_points AS (\n  SELECT\n    r.year,\n    res.constructor_id,\n    SUM(res.points) AS total_points\n  FROM results res\n  JOIN races r ON r.race_id = res.race_id\n  GROUP BY r.year, res.constructor_id\n),\nconstructor_year_winners AS (\n  SELECT\n    year,\n    constructor_id,\n    total_points,\n    DENSE_RANK() OVER (PARTITION BY year ORDER BY total_points DESC) AS rk\n  FROM constructor_year_points\n)\nSELECT\n  dyw.year,\n  COALESCE(de.full_name, d.forename || ' ' || d.surname) AS top_driver_full_name,\n  dyw.total_points AS top_driver_points,\n  c.name AS top_constructor_name,\n  cyw.total_points AS top_constructor_points\nFROM driver_year_winners dyw\nJOIN constructor_year_winners cyw\n  ON cyw.year = dyw.year\nLEFT JOIN drivers_ext de\n  ON de.driver_id = dyw.driver_id\nLEFT JOIN drivers d\n  ON d.driver_id = dyw.driver_id\nJOIN constructors c\n  ON c.constructor_id = cyw.constructor_id\nWHERE dyw.rk = 1\n  AND cyw.rk = 1\nORDER BY dyw.year;\t----- bird -----\tf1_spider2",
    "117": "WITH whsle AS (\n  SELECT\n    CAST(strftime('%Y', whsle_date) AS INTEGER) AS year,\n    item_code,\n    whsle_px_rmb-kg AS whsle_price\n  FROM veg_whsle_df\n  WHERE CAST(strftime('%Y', whsle_date) AS INTEGER) BETWEEN 2020 AND 2023\n),\nsales AS (\n  SELECT\n    CAST(strftime('%Y', txn_date) AS INTEGER) AS year,\n    item_code,\n    SUM(CASE WHEN \"sale/return\" = 'sale' THEN \"qty_sold(kg)\" ELSE -1 * \"qty_sold(kg)\" END) AS net_qty_kg,\n    SUM(\n      (CASE WHEN \"sale/return\" = 'sale' THEN \"qty_sold(kg)\" ELSE -1 * \"qty_sold(kg)\" END)\n      * \"unit_selling_px_rmb/kg\"\n      * (1.0 - COALESCE(\"discount(%)\", 0) / 100.0)\n    ) AS total_selling_price\n  FROM veg_txn_df\n  WHERE CAST(strftime('%Y', txn_date) AS INTEGER) BETWEEN 2020 AND 2023\n  GROUP BY 1, 2\n),\nloss AS (\n  SELECT\n    item_code,\n    AVG(\"loss_rate_%\") AS avg_loss_rate\n  FROM veg_loss_rate_df\n  GROUP BY 1\n),\ncat AS (\n  SELECT\n    item_code,\n    category_name\n  FROM veg_cat\n),\nwhsle_cat_year AS (\n  SELECT\n    w.year,\n    c.category_name,\n    AVG(w.whsle_price) AS avg_whsle_price,\n    MAX(w.whsle_price) AS max_whsle_price,\n    MIN(w.whsle_price) AS min_whsle_price,\n    (MAX(w.whsle_price) - MIN(w.whsle_price)) AS whsle_price_diff\n  FROM whsle w\n  JOIN cat c ON c.item_code = w.item_code\n  GROUP BY 1, 2\n),\nqty_cat_year AS (\n  SELECT\n    s.year,\n    c.category_name,\n    SUM(s.net_qty_kg) AS total_qty_kg,\n    SUM(s.total_selling_price) AS total_selling_price\n  FROM sales s\n  JOIN cat c ON c.item_code = s.item_code\n  GROUP BY 1, 2\n),\nloss_cat_year AS (\n  SELECT\n    s.year,\n    c.category_name,\n    AVG(COALESCE(l.avg_loss_rate, 0)) AS avg_loss_rate\n  FROM sales s\n  JOIN cat c ON c.item_code = s.item_code\n  LEFT JOIN loss l ON l.item_code = s.item_code\n  GROUP BY 1, 2\n)\nSELECT\n  wcy.year,\n  wcy.category_name,\n\n  ROUND(wcy.avg_whsle_price, 2) AS avg_wholesale_price,\n  ROUND(wcy.max_whsle_price, 2) AS max_wholesale_price,\n  ROUND(wcy.min_whsle_price, 2) AS min_wholesale_price,\n  ROUND(wcy.whsle_price_diff, 2) AS wholesale_price_difference,\n\n  ROUND(COALESCE(qcy.total_qty_kg, 0) * wcy.avg_whsle_price, 2) AS total_wholesale_price,\n  ROUND(COALESCE(qcy.total_selling_price, 0), 2) AS total_selling_price,\n\n  ROUND(COALESCE(lcy.avg_loss_rate, 0), 2) AS avg_loss_rate,\n  ROUND((COALESCE(qcy.total_qty_kg, 0) * COALESCE(lcy.avg_loss_rate, 0) / 100.0) * wcy.avg_whsle_price, 2) AS total_loss,\n\n  ROUND(\n    COALESCE(qcy.total_selling_price, 0)\n    - (COALESCE(qcy.total_qty_kg, 0) * wcy.avg_whsle_price)\n    - ((COALESCE(qcy.total_qty_kg, 0) * COALESCE(lcy.avg_loss_rate, 0) / 100.0) * wcy.avg_whsle_price),\n    2\n  ) AS profit\nFROM whsle_cat_year wcy\nLEFT JOIN qty_cat_year qcy\n  ON qcy.year = wcy.year\n AND qcy.category_name = wcy.category_name\nLEFT JOIN loss_cat_year lcy\n  ON lcy.year = wcy.year\n AND lcy.category_name = wcy.category_name\nORDER BY wcy.year, wcy.category_name;\t----- bird -----\tbank_sales_trading_spider2",
    "120": "WITH params AS (\n  SELECT\n    date('2020-06-15') AS pivot_date,\n    date('2020-06-15', '-84 days') AS pre_start,   -- 12 weeks before\n    date('2020-06-15', '-1 day')   AS pre_end,\n    date('2020-06-15')             AS post_start,  -- 12 weeks after (inclusive)\n    date('2020-06-15', '+83 days') AS post_end\n),\nbase AS (\n  SELECT\n    date(week_date_formatted) AS week_dt,\n    region,\n    platform,\n    age_band,\n    demographic,\n    customer_type,\n    sales\n  FROM cleaned_weekly_sales\n),\nwindowed AS (\n  SELECT\n    b.*,\n    CASE\n      WHEN b.week_dt BETWEEN p.pre_start AND p.pre_end THEN 'pre'\n      WHEN b.week_dt BETWEEN p.post_start AND p.post_end THEN 'post'\n    END AS period\n  FROM base b\n  CROSS JOIN params p\n  WHERE b.week_dt BETWEEN p.pre_start AND p.post_end\n),\n-- Aggregate sales per attribute value for pre vs post\nattr_value_sales AS (\n  SELECT 'region' AS attribute_type, region AS attribute_value, period, SUM(sales) AS total_sales\n  FROM windowed\n  WHERE period IS NOT NULL\n  GROUP BY 1,2,3\n\n  UNION ALL\n  SELECT 'platform', platform, period, SUM(sales)\n  FROM windowed\n  WHERE period IS NOT NULL\n  GROUP BY 1,2,3\n\n  UNION ALL\n  SELECT 'age_band', age_band, period, SUM(sales)\n  FROM windowed\n  WHERE period IS NOT NULL\n  GROUP BY 1,2,3\n\n  UNION ALL\n  SELECT 'demographic', demographic, period, SUM(sales)\n  FROM windowed\n  WHERE period IS NOT NULL\n  GROUP BY 1,2,3\n\n  UNION ALL\n  SELECT 'customer_type', customer_type, period, SUM(sales)\n  FROM windowed\n  WHERE period IS NOT NULL\n  GROUP BY 1,2,3\n),\n-- Compute % change per attribute value: (post - pre) / pre * 100\nattr_value_pct_change AS (\n  SELECT\n    attribute_type,\n    attribute_value,\n    100.0 * (\n      SUM(CASE WHEN period = 'post' THEN total_sales END) -\n      SUM(CASE WHEN period = 'pre'  THEN total_sales END)\n    ) / NULLIF(SUM(CASE WHEN period = 'pre' THEN total_sales END), 0) AS pct_change\n  FROM attr_value_sales\n  GROUP BY attribute_type, attribute_value\n),\n-- Average % change across all values within each attribute type\nattr_type_avg_change AS (\n  SELECT\n    attribute_type,\n    AVG(pct_change) AS avg_pct_change\n  FROM attr_value_pct_change\n  WHERE pct_change IS NOT NULL\n  GROUP BY attribute_type\n)\nSELECT\n  attribute_type,\n  avg_pct_change\nFROM attr_type_avg_change\nORDER BY avg_pct_change ASC\nLIMIT 1;\t----- bird -----\tbank_sales_trading_spider2",
    "114": "\t----- bird -----\toracle_sql_spider2",
    "133": "WITH year_rounds AS (\n  SELECT\n    year,\n    MAX(round) AS max_round\n  FROM races\n  GROUP BY year\n),\ndriver_year_rounds AS (\n  -- For each driver/year, list the rounds they actually raced (from results)\n  SELECT DISTINCT\n    r.year,\n    res.driver_id,\n    r.round\n  FROM results res\n  JOIN races r\n    ON r.race_id = res.race_id\n),\ndriver_year_gaps AS (\n  -- Identify gaps between consecutive raced rounds within a year\n  SELECT\n    dyr.year,\n    dyr.driver_id,\n    dyr.round AS prev_round,\n    LEAD(dyr.round) OVER (PARTITION BY dyr.year, dyr.driver_id ORDER BY dyr.round) AS next_round\n  FROM driver_year_rounds dyr\n),\ncandidate_hiatus AS (\n  -- Convert gaps into missed-round intervals (first_missed..last_missed)\n  SELECT\n    g.year,\n    g.driver_id,\n    g.prev_round,\n    g.next_round,\n    (g.prev_round + 1) AS first_missed_round,\n    (g.next_round - 1) AS last_missed_round,\n    (g.next_round - g.prev_round - 1) AS races_missed\n  FROM driver_year_gaps g\n  WHERE g.next_round IS NOT NULL\n    AND (g.next_round - g.prev_round - 1) BETWEEN 1 AND 2  -- missed fewer than 3 races\n),\nprev_next_constructors AS (\n  -- Get constructor before the gap and after the gap (must exist and differ)\n  SELECT\n    ch.year,\n    ch.driver_id,\n    ch.first_missed_round,\n    ch.last_missed_round,\n    ch.races_missed,\n    (\n      SELECT res1.constructor_id\n      FROM results res1\n      JOIN races r1 ON r1.race_id = res1.race_id\n      WHERE r1.year = ch.year\n        AND r1.round = ch.prev_round\n        AND res1.driver_id = ch.driver_id\n      LIMIT 1\n    ) AS constructor_before,\n    (\n      SELECT res2.constructor_id\n      FROM results res2\n      JOIN races r2 ON r2.race_id = res2.race_id\n      WHERE r2.year = ch.year\n        AND r2.round = ch.next_round\n        AND res2.driver_id = ch.driver_id\n      LIMIT 1\n    ) AS constructor_after\n  FROM candidate_hiatus ch\n)\nSELECT\n  AVG(first_missed_round) AS overall_avg_first_missed_round,\n  AVG(last_missed_round)  AS overall_avg_last_missed_round\nFROM prev_next_constructors\nWHERE constructor_before IS NOT NULL\n  AND constructor_after IS NOT NULL\n  AND constructor_before <> constructor_after;\t----- bird -----\tf1_spider2",
    "132": "WITH races_50s AS (\n  SELECT race_id, year, round, date\n  FROM races\n  WHERE year BETWEEN 1950 AND 1959\n),\ndriver_season_races AS (\n  -- races a driver actually started/was classified in (i.e., has a results row)\n  SELECT\n    r.year,\n    res.driver_id,\n    res.race_id,\n    r.round,\n    r.date\n  FROM results res\n  JOIN races_50s r\n    ON r.race_id = res.race_id\n),\nseason_bounds AS (\n  -- first and last race (by date/round) the driver participated in that season\n  SELECT\n    year,\n    driver_id,\n    MIN(date) AS first_date,\n    MAX(date) AS last_date,\n    COUNT(DISTINCT round) AS distinct_rounds\n  FROM driver_season_races\n  GROUP BY year, driver_id\n  HAVING COUNT(DISTINCT round) >= 2\n),\nfirst_last_races AS (\n  -- resolve the actual race_id for the first and last participation (tie-break by round)\n  SELECT\n    sb.year,\n    sb.driver_id,\n    (SELECT dsr.race_id\n     FROM driver_season_races dsr\n     WHERE dsr.year = sb.year\n       AND dsr.driver_id = sb.driver_id\n       AND dsr.date = sb.first_date\n     ORDER BY dsr.round ASC\n     LIMIT 1) AS first_race_id,\n    (SELECT dsr.race_id\n     FROM driver_season_races dsr\n     WHERE dsr.year = sb.year\n       AND dsr.driver_id = sb.driver_id\n       AND dsr.date = sb.last_date\n     ORDER BY dsr.round DESC\n     LIMIT 1) AS last_race_id,\n    sb.distinct_rounds\n  FROM season_bounds sb\n),\nfirst_last_constructors AS (\n  SELECT\n    fl.year,\n    fl.driver_id,\n    fl.distinct_rounds,\n    r1.constructor_id AS first_constructor_id,\n    r2.constructor_id AS last_constructor_id\n  FROM first_last_races fl\n  JOIN results r1\n    ON r1.race_id = fl.first_race_id\n   AND r1.driver_id = fl.driver_id\n  JOIN results r2\n    ON r2.race_id = fl.last_race_id\n   AND r2.driver_id = fl.driver_id\n)\nSELECT\n  flc.year,\n  d.driver_id,\n  d.forename || ' ' || d.surname AS driver_name,\n  c.name AS constructor_name,\n  flc.distinct_rounds\nFROM first_last_constructors flc\nJOIN drivers d\n  ON d.driver_id = flc.driver_id\nJOIN constructors c\n  ON c.constructor_id = flc.first_constructor_id\nWHERE flc.first_constructor_id = flc.last_constructor_id\nORDER BY flc.year, driver_name;\t----- bird -----\tf1_spider2",
    "134": "WITH\n-- Only consider \"race laps\" (exclude lap 1 start movements)\nrace_laps AS (\n  SELECT race_id, driver_id, lap, position\n  FROM lap_positions\n  WHERE lap_type = 'race'\n    AND lap > 1\n),\n\n-- Detect on-track position changes between consecutive laps\npos_changes AS (\n  SELECT\n    cur.race_id,\n    cur.driver_id,\n    cur.lap,\n    prev.position AS prev_pos,\n    cur.position  AS cur_pos,\n    (prev.position - cur.position) AS delta  -- >0 gained places, <0 lost places\n  FROM race_laps cur\n  JOIN race_laps prev\n    ON prev.race_id = cur.race_id\n   AND prev.driver_id = cur.driver_id\n   AND prev.lap = cur.lap - 1\n  WHERE prev.position IS NOT NULL\n    AND cur.position  IS NOT NULL\n    AND prev.position <> cur.position\n),\n\n-- Exclude laps where a driver pitted (pit entry/exit effects)\npos_changes_no_pit AS (\n  SELECT pc.*\n  FROM pos_changes pc\n  LEFT JOIN pit_stops ps\n    ON ps.race_id = pc.race_id\n   AND ps.driver_id = pc.driver_id\n   AND (ps.lap = pc.lap OR ps.lap = pc.lap - 1)\n  WHERE ps.race_id IS NULL\n),\n\n-- Exclude laps where a driver retired (and the lap immediately after, where others may inherit places)\npos_changes_no_pit_no_ret AS (\n  SELECT pc.*\n  FROM pos_changes_no_pit pc\n  LEFT JOIN retirements rt\n    ON rt.race_id = pc.race_id\n   AND rt.driver_id = pc.driver_id\n   AND (CAST(rt.lap AS INTEGER) = pc.lap OR CAST(rt.lap AS INTEGER) = pc.lap - 1)\n  WHERE rt.race_id IS NULL\n),\n\n-- Aggregate: count places gained/lost as overtakes/being overtaken\ndriver_overtake_balance AS (\n  SELECT\n    driver_id,\n    SUM(CASE WHEN delta > 0 THEN delta ELSE 0 END) AS overtakes_made,\n    SUM(CASE WHEN delta < 0 THEN -delta ELSE 0 END) AS overtaken_by\n  FROM pos_changes_no_pit_no_ret\n  GROUP BY driver_id\n)\n\nSELECT d.full_name\nFROM driver_overtake_balance b\nJOIN drivers_ext d\n  ON d.driver_id = b.driver_id\nWHERE b.overtaken_by > b.overtakes_made\nORDER BY d.full_name;\t----- bird -----\tf1_spider2",
    "126": "WITH pit_races AS (\n  SELECT race_id\n  FROM races_ext\n  WHERE is_pit_data_available = 'True'\n),\nlp AS (\n  SELECT\n    race_id,\n    driver_id,\n    lap,\n    position,\n    LAG(position) OVER (PARTITION BY race_id, driver_id ORDER BY lap) AS prev_position\n  FROM lap_positions\n  WHERE lap_type = 'Race'\n    AND race_id IN (SELECT race_id FROM pit_races)\n),\n-- Candidate \"gains\": driver improved position vs previous lap\ngains AS (\n  SELECT\n    race_id,\n    lap,\n    driver_id AS overtaker_id,\n    prev_position AS overtaker_prev_pos,\n    position AS overtaker_curr_pos\n  FROM lp\n  WHERE prev_position IS NOT NULL\n    AND position < prev_position\n),\n-- For each gain, find the specific driver(s) that this driver moved ahead of:\n-- those whose previous position was between the overtaker's new and old positions,\n-- and whose current position is now behind the overtaker.\novertakes AS (\n  SELECT\n    g.race_id,\n    g.lap,\n    g.overtaker_id,\n    o.driver_id AS overtaken_id,\n    g.overtaker_prev_pos,\n    g.overtaker_curr_pos,\n    o.prev_position AS overtaken_prev_pos,\n    o.position AS overtaken_curr_pos\n  FROM gains g\n  JOIN lp o\n    ON o.race_id = g.race_id\n   AND o.lap     = g.lap\n   AND o.prev_position IS NOT NULL\n   AND o.driver_id <> g.overtaker_id\n   AND o.prev_position >= g.overtaker_curr_pos\n   AND o.prev_position <  g.overtaker_prev_pos\n   AND o.position > g.overtaker_curr_pos\n),\nret AS (\n  SELECT race_id, driver_id, CAST(lap AS INTEGER) AS lap\n  FROM retirements\n),\nps AS (\n  SELECT race_id, driver_id, lap\n  FROM pit_stops\n),\nres AS (\n  SELECT race_id, driver_id, grid\n  FROM results\n),\nclassified AS (\n  SELECT\n    o.*,\n    CASE\n      -- R: overtaken driver retires on the same lap\n      WHEN EXISTS (\n        SELECT 1\n        FROM ret r\n        WHERE r.race_id = o.race_id\n          AND r.driver_id = o.overtaken_id\n          AND r.lap = o.lap\n      ) THEN 'R'\n\n      -- P: pit entry (overtaken pits on same lap) OR pit exit (overtaken pitted previous lap)\n      WHEN EXISTS (\n        SELECT 1\n        FROM ps p\n        WHERE p.race_id = o.race_id\n          AND p.driver_id = o.overtaken_id\n          AND p.lap = o.lap\n      )\n      OR EXISTS (\n        SELECT 1\n        FROM ps p\n        WHERE p.race_id = o.race_id\n          AND p.driver_id = o.overtaken_id\n          AND p.lap = o.lap - 1\n      ) THEN 'P'\n\n      -- S: lap 1 and within 2 grid positions at the start\n      WHEN o.lap = 1\n       AND EXISTS (\n         SELECT 1\n         FROM res ro\n         JOIN res rt\n           ON rt.race_id = ro.race_id\n          AND rt.driver_id = o.overtaker_id\n         WHERE ro.race_id = o.race_id\n           AND ro.driver_id = o.overtaken_id\n           AND ro.grid IS NOT NULL AND rt.grid IS NOT NULL\n           AND ABS(rt.grid - ro.grid) <= 2\n       ) THEN 'S'\n\n      -- T: normal track overtake\n      ELSE 'T'\n    END AS overtake_type\n  FROM overtakes o\n)\nSELECT\n  overtake_type,\n  COUNT(*) AS overtake_count\nFROM classified\nGROUP BY overtake_type\nORDER BY\n  CASE overtake_type\n    WHEN 'R' THEN 1\n    WHEN 'P' THEN 2\n    WHEN 'S' THEN 3\n    WHEN 'T' THEN 4\n    ELSE 5\n  END;\t----- bird -----\tf1_spider2",
    "127": "WITH\n-- Positions per lap (race position at end of lap)\nlp AS (\n  SELECT\n    race_id,\n    driver_id,\n    lap,\n    position\n  FROM lap_positions\n  WHERE lap BETWEEN 1 AND 5\n),\n\n-- Detect overtakes as pairwise position swaps between consecutive laps:\n-- A overtakes B on lap L if A was behind B on lap L-1 and ahead on lap L.\novertakes AS (\n  SELECT\n    a.race_id,\n    a.lap AS lap,                 -- lap on which the overtake is realized\n    a.driver_id AS overtaker_id,\n    b.driver_id AS overtaken_id\n  FROM lp a\n  JOIN lp a_prev\n    ON a_prev.race_id = a.race_id\n   AND a_prev.driver_id = a.driver_id\n   AND a_prev.lap = a.lap - 1\n  JOIN lp b\n    ON b.race_id = a.race_id\n   AND b.lap = a.lap\n   AND b.driver_id <> a.driver_id\n  JOIN lp b_prev\n    ON b_prev.race_id = b.race_id\n   AND b_prev.driver_id = b.driver_id\n   AND b_prev.lap = b.lap - 1\n  WHERE a.lap BETWEEN 1 AND 5\n    AND a_prev.position > b_prev.position   -- A was behind B\n    AND a.position < b.position             -- A is now ahead of B\n),\n\n-- Retirements: driver retired on that lap\nret AS (\n  SELECT race_id, driver_id, CAST(lap AS INTEGER) AS lap\n  FROM retirements\n  WHERE CAST(lap AS INTEGER) BETWEEN 1 AND 5\n),\n\n-- Pit stops: driver pitted on that lap\npits AS (\n  SELECT race_id, driver_id, lap\n  FROM pit_stops\n  WHERE lap BETWEEN 1 AND 5\n),\n\n-- Grid positions for start-related classification\ngrid AS (\n  SELECT race_id, driver_id, grid\n  FROM results\n),\n\nclassified AS (\n  SELECT\n    o.race_id,\n    o.lap,\n    o.overtaker_id,\n    o.overtaken_id,\n    CASE\n      -- 1) Retirement\n      WHEN r.driver_id IS NOT NULL THEN 'R'\n      -- 2) Pit-related (pit entry same lap for overtaken, or pit exit: overtaken pitted previous lap)\n      WHEN p_same.driver_id IS NOT NULL OR p_prev.driver_id IS NOT NULL THEN 'P'\n      -- 3) Start-related (lap 1 and within 2 grid positions)\n      WHEN o.lap = 1\n       AND g1.grid IS NOT NULL AND g2.grid IS NOT NULL\n       AND ABS(g1.grid - g2.grid) <= 2 THEN 'S'\n      -- 4) Normal track pass\n      ELSE 'T'\n    END AS category\n  FROM overtakes o\n  LEFT JOIN ret r\n    ON r.race_id = o.race_id\n   AND r.driver_id = o.overtaken_id\n   AND r.lap = o.lap\n  LEFT JOIN pits p_same\n    ON p_same.race_id = o.race_id\n   AND p_same.driver_id = o.overtaken_id\n   AND p_same.lap = o.lap\n  LEFT JOIN pits p_prev\n    ON p_prev.race_id = o.race_id\n   AND p_prev.driver_id = o.overtaken_id\n   AND p_prev.lap = o.lap - 1\n  LEFT JOIN grid g1\n    ON g1.race_id = o.race_id\n   AND g1.driver_id = o.overtaker_id\n  LEFT JOIN grid g2\n    ON g2.race_id = o.race_id\n   AND g2.driver_id = o.overtaken_id\n)\n\nSELECT\n  category,\n  COUNT(*) AS overtake_count\nFROM classified\nGROUP BY category\nORDER BY CASE category\n  WHEN 'R' THEN 1\n  WHEN 'P' THEN 2\n  WHEN 'S' THEN 3\n  WHEN 'T' THEN 4\n  ELSE 5\nEND;\t----- bird -----\tf1_spider2"
}